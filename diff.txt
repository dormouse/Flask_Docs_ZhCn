diff --git a/.devcontainer/on-create-command.sh b/.devcontainer/on-create-command.sh
index deffa37b..fdf77952 100755
--- a/.devcontainer/on-create-command.sh
+++ b/.devcontainer/on-create-command.sh
@@ -3,7 +3,7 @@ set -e
 
 python3 -m venv .venv
 . .venv/bin/activate
-pip install -U pip setuptools wheel
+pip install -U pip
 pip install -r requirements/dev.txt
 pip install -e .
 pre-commit install --install-hooks
diff --git a/.flake8 b/.flake8
deleted file mode 100644
index 8f3b4fd4..00000000
--- a/.flake8
+++ /dev/null
@@ -1,25 +0,0 @@
-[flake8]
-extend-select =
-    # bugbear
-    B
-    # bugbear opinions
-    B9
-    # implicit str concat
-    ISC
-extend-ignore =
-    # slice notation whitespace, invalid
-    E203
-    # line length, handled by bugbear B950
-    E501
-    # bare except, handled by bugbear B001
-    E722
-    # zip with strict=, requires python >= 3.10
-    B905
-    # string formatting opinion, B028 renamed to B907
-    B028
-    B907
-# up to 88 allowed by bugbear B950
-max-line-length = 80
-per-file-ignores =
-    # __init__ exports names
-    src/flask/__init__.py: F401
diff --git a/.github/workflows/lock.yaml b/.github/workflows/lock.yaml
index c790fae5..e19cdb71 100644
--- a/.github/workflows/lock.yaml
+++ b/.github/workflows/lock.yaml
@@ -3,23 +3,19 @@ name: 'Lock threads'
 # two weeks. This does not close open issues, only humans may do that.
 # We find that it is easier to respond to new issues with fresh examples
 # rather than continuing discussions on old issues.
-
 on:
   schedule:
     - cron: '0 0 * * *'
-
 permissions:
   issues: write
   pull-requests: write
-
 concurrency:
   group: lock
-
 jobs:
   lock:
     runs-on: ubuntu-latest
     steps:
-      - uses: dessant/lock-threads@c1b35aecc5cdb1a34539d14196df55838bb2f836
+      - uses: dessant/lock-threads@7de207be1d3ce97a9abe6ff1306222982d1ca9f9
         with:
           issue-inactive-days: 14
           pr-inactive-days: 14
diff --git a/.github/workflows/publish.yaml b/.github/workflows/publish.yaml
index 45a9c51b..a6ae6e42 100644
--- a/.github/workflows/publish.yaml
+++ b/.github/workflows/publish.yaml
@@ -9,12 +9,12 @@ jobs:
     outputs:
       hash: ${{ steps.hash.outputs.hash }}
     steps:
-      - uses: actions/checkout@8f4b7f84864484a7bf31766abe9204da3cbe65b3
-      - uses: actions/setup-python@d27e3f3d7c64b4bbf8e4abfb9b63b83e846e0435
+      - uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11
+      - uses: actions/setup-python@0a5c61591373683505ea898e09a3ea4f39ef2b9c
         with:
           python-version: '3.x'
-          cache: 'pip'
-          cache-dependency-path: 'requirements/*.txt'
+          cache: pip
+          cache-dependency-path: requirements*/*.txt
       - run: pip install -r requirements/build.txt
       # Use the commit date instead of the current date during the build.
       - run: echo "SOURCE_DATE_EPOCH=$(git log -1 --pretty=%ct)" >> $GITHUB_ENV
@@ -23,23 +23,24 @@ jobs:
       - name: generate hash
         id: hash
         run: cd dist && echo "hash=$(sha256sum * | base64 -w0)" >> $GITHUB_OUTPUT
-      - uses: actions/upload-artifact@0b7f8abb1508181956e8e162db84b466c27e18ce
+      - uses: actions/upload-artifact@a8a3f3ad30e3422c9c7b888a15615d19a852ae32
         with:
+          name: dist
           path: ./dist
   provenance:
-    needs: ['build']
+    needs: [build]
     permissions:
       actions: read
       id-token: write
       contents: write
     # Can't pin with hash due to how this workflow works.
-    uses: slsa-framework/slsa-github-generator/.github/workflows/generator_generic_slsa3.yml@v1.5.0
+    uses: slsa-framework/slsa-github-generator/.github/workflows/generator_generic_slsa3.yml@v1.9.0
     with:
       base64-subjects: ${{ needs.build.outputs.hash }}
   create-release:
     # Upload the sdist, wheels, and provenance to a GitHub release. They remain
     # available as build artifacts for a while as well.
-    needs: ['provenance']
+    needs: [provenance]
     runs-on: ubuntu-latest
     permissions:
       contents: write
@@ -49,24 +50,20 @@ jobs:
         run: >
           gh release create --draft --repo ${{ github.repository }}
           ${{ github.ref_name }}
-          *.intoto.jsonl/* artifact/*
+          *.intoto.jsonl/* dist/*
         env:
           GH_TOKEN: ${{ github.token }}
   publish-pypi:
-    needs: ['provenance']
+    needs: [provenance]
     # Wait for approval before attempting to upload to PyPI. This allows reviewing the
     # files in the draft release.
-    environment: 'publish'
+    environment: publish
     runs-on: ubuntu-latest
     permissions:
       id-token: write
     steps:
       - uses: actions/download-artifact@9bc31d5ccc31df68ecc42ccf4149144866c47d8a
-      # Try uploading to Test PyPI first, in case something fails.
-      - uses: pypa/gh-action-pypi-publish@29930c9cf57955dc1b98162d0d8bc3ec80d9e75c
+      - uses: pypa/gh-action-pypi-publish@f946db0f765b9ae754e44bfd5ae5b8b91cfb37ef
         with:
-          repository_url: https://test.pypi.org/legacy/
-          packages_dir: artifact/
-      - uses: pypa/gh-action-pypi-publish@29930c9cf57955dc1b98162d0d8bc3ec80d9e75c
-        with:
-          packages_dir: artifact/
+          repository-url: https://test.pypi.org/legacy/
+      - uses: pypa/gh-action-pypi-publish@f946db0f765b9ae754e44bfd5ae5b8b91cfb37ef
diff --git a/.github/workflows/tests.yaml b/.github/workflows/tests.yaml
index 79c382fe..b47ea3b3 100644
--- a/.github/workflows/tests.yaml
+++ b/.github/workflows/tests.yaml
@@ -9,9 +9,6 @@ on:
       - '*.md'
       - '*.rst'
   pull_request:
-    branches:
-      - main
-      - '*.x'
     paths-ignore:
       - 'docs/**'
       - '*.md'
@@ -24,31 +21,26 @@ jobs:
       fail-fast: false
       matrix:
         include:
-          - {name: Linux, python: '3.11', os: ubuntu-latest, tox: py311}
-          - {name: Windows, python: '3.11', os: windows-latest, tox: py311}
-          - {name: Mac, python: '3.11', os: macos-latest, tox: py311}
-          - {name: '3.12-dev', python: '3.12-dev', os: ubuntu-latest, tox: py312}
+          - {name: Linux, python: '3.12', os: ubuntu-latest, tox: py312}
+          - {name: Windows, python: '3.12', os: windows-latest, tox: py312}
+          - {name: Mac, python: '3.12', os: macos-latest, tox: py312}
+          - {name: '3.11', python: '3.11', os: ubuntu-latest, tox: py311}
           - {name: '3.10', python: '3.10', os: ubuntu-latest, tox: py310}
           - {name: '3.9', python: '3.9', os: ubuntu-latest, tox: py39}
           - {name: '3.8', python: '3.8', os: ubuntu-latest, tox: py38}
-          - {name: 'PyPy', python: 'pypy-3.9', os: ubuntu-latest, tox: pypy39}
-          - {name: 'Minimum Versions', python: '3.11', os: ubuntu-latest, tox: py311-min}
+          - {name: 'PyPy', python: 'pypy-3.10', os: ubuntu-latest, tox: pypy310}
+          - {name: 'Minimum Versions', python: '3.12', os: ubuntu-latest, tox: py312-min}
           - {name: 'Development Versions', python: '3.8', os: ubuntu-latest, tox: py38-dev}
-          - {name: Typing, python: '3.11', os: ubuntu-latest, tox: typing}
+          - {name: Typing, python: '3.12', os: ubuntu-latest, tox: typing}
     steps:
-      - uses: actions/checkout@8f4b7f84864484a7bf31766abe9204da3cbe65b3
-      - uses: actions/setup-python@d27e3f3d7c64b4bbf8e4abfb9b63b83e846e0435
+      - uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11
+      - uses: actions/setup-python@0a5c61591373683505ea898e09a3ea4f39ef2b9c
         with:
           python-version: ${{ matrix.python }}
           cache: 'pip'
-          cache-dependency-path: 'requirements/*.txt'
-      - name: update pip
-        run: |
-          pip install -U wheel
-          pip install -U setuptools
-          python -m pip install -U pip
+          cache-dependency-path: requirements*/*.txt
       - name: cache mypy
-        uses: actions/cache@88522ab9f39a2ea568f7027eddc7d8d8bc9d59c8
+        uses: actions/cache@13aacd865c20de90d75de3b17ebe84f7a17d57d2
         with:
           path: ./.mypy_cache
           key: mypy|${{ matrix.python }}|${{ hashFiles('pyproject.toml') }}
diff --git a/.gitignore b/.gitignore
index e6713351..83aa92e5 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,25 +1,10 @@
-.DS_Store
-.env
-.flaskenv
-*.pyc
-*.pyo
-env/
-venv/
-.venv/
-env*
-dist/
-build/
-*.egg
-*.egg-info/
-.tox/
-.cache/
-.pytest_cache/
 .idea/
-docs/_build/
-.vscode
-
-# Coverage reports
-htmlcov/
+.vscode/
+__pycache__/
+.tox/
 .coverage
 .coverage.*
-*,cover
+htmlcov/
+docs/_build/
+dist/
+venv/
diff --git a/.pre-commit-config.yaml b/.pre-commit-config.yaml
index 79b632ae..81e76c2e 100644
--- a/.pre-commit-config.yaml
+++ b/.pre-commit-config.yaml
@@ -1,37 +1,16 @@
 ci:
-  autoupdate_branch: "2.2.x"
   autoupdate_schedule: monthly
 repos:
-  - repo: https://github.com/asottile/pyupgrade
-    rev: v3.3.2
+  - repo: https://github.com/astral-sh/ruff-pre-commit
+    rev: v0.1.13
     hooks:
-      - id: pyupgrade
-        args: ["--py38-plus"]
-  - repo: https://github.com/asottile/reorder_python_imports
-    rev: v3.9.0
-    hooks:
-      - id: reorder-python-imports
-        name: Reorder Python imports (src, tests)
-        files: "^(?!examples/)"
-        args: ["--application-directories", "src"]
-  - repo: https://github.com/psf/black
-    rev: 23.3.0
-    hooks:
-      - id: black
-  - repo: https://github.com/PyCQA/flake8
-    rev: 6.0.0
-    hooks:
-      - id: flake8
-        additional_dependencies:
-          - flake8-bugbear
-          - flake8-implicit-str-concat
-  - repo: https://github.com/peterdemin/pip-compile-multi
-    rev: v2.6.2
-    hooks:
-      - id: pip-compile-multi-verify
+      - id: ruff
+      - id: ruff-format
   - repo: https://github.com/pre-commit/pre-commit-hooks
-    rev: v4.4.0
+    rev: v4.5.0
     hooks:
+      - id: check-merge-conflict
+      - id: debug-statements
       - id: fix-byte-order-marker
       - id: trailing-whitespace
       - id: end-of-file-fixer
diff --git a/.readthedocs.yaml b/.readthedocs.yaml
index 346900b2..5ffe32b3 100644
--- a/.readthedocs.yaml
+++ b/.readthedocs.yaml
@@ -1,8 +1,8 @@
 version: 2
 build:
-  os: ubuntu-20.04
+  os: ubuntu-22.04
   tools:
-    python: "3.10"
+    python: "3.12"
 python:
   install:
     - requirements: requirements/docs.txt
diff --git a/CHANGES.rst b/CHANGES.rst
index 1ba0f341..37c54f97 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -1,7 +1,55 @@
+Version 3.0.2
+-------------
+
+Released 2024-02-03
+
+-   Correct type for ``jinja_loader`` property. :issue:`5388`
+-   Fix error with ``--extra-files`` and ``--exclude-patterns`` CLI options.
+    :issue:`5391`
+
+
+Version 3.0.1
+-------------
+
+Released 2024-01-18
+
+-   Correct type for ``path`` argument to ``send_file``. :issue:`5230`
+-   Fix a typo in an error message for the ``flask run --key`` option. :pr:`5344`
+-   Session data is untagged without relying on the built-in ``json.loads``
+    ``object_hook``. This allows other JSON providers that don't implement that.
+    :issue:`5381`
+-   Address more type findings when using mypy strict mode. :pr:`5383`
+
+
+Version 3.0.0
+-------------
+
+Released 2023-09-30
+
+-   Remove previously deprecated code. :pr:`5223`
+-   Deprecate the ``__version__`` attribute. Use feature detection, or
+    ``importlib.metadata.version("flask")``, instead. :issue:`5230`
+-   Restructure the code such that the Flask (app) and Blueprint
+    classes have Sans-IO bases. :pr:`5127`
+-   Allow self as an argument to url_for. :pr:`5264`
+-   Require Werkzeug >= 3.0.0.
+
+
+Version 2.3.3
+-------------
+
+Released 2023-08-21
+
+-   Python 3.12 compatibility.
+-   Require Werkzeug >= 2.3.7.
+-   Use ``flit_core`` instead of ``setuptools`` as build backend.
+-   Refactor how an app's root and instance paths are determined. :issue:`5160`
+
+
 Version 2.3.2
 -------------
 
-Released 2022-05-01
+Released 2023-05-01
 
 -   Set ``Vary: Cookie`` header when the session is accessed, modified, or refreshed.
 -   Update Werkzeug requirement to >=2.3.3 to apply recent bug fixes.
@@ -69,6 +117,15 @@ Released 2023-04-25
 -   Use postponed evaluation of annotations. :pr:`5071`
 
 
+Version 2.2.5
+-------------
+
+Released 2023-05-02
+
+-   Update for compatibility with Werkzeug 2.3.3.
+-   Set ``Vary: Cookie`` header when the session is accessed, modified, or refreshed.
+
+
 Version 2.2.4
 -------------
 
@@ -289,7 +346,7 @@ Released 2022-03-28
     or ``AppContext.g`` instead. :issue:`3898`
 -   ``copy_current_request_context`` can decorate async functions.
     :pr:`4303`
--   The CLI uses ``importlib.metadata`` instead of ``setuptools`` to
+-   The CLI uses ``importlib.metadata`` instead of ``pkg_resources`` to
     load command entry points. :issue:`4419`
 -   Overriding ``FlaskClient.open`` will not cause an error on redirect.
     :issue:`3396`
diff --git a/CONTRIBUTING.rst b/CONTRIBUTING.rst
index 24daa729..fed44978 100644
--- a/CONTRIBUTING.rst
+++ b/CONTRIBUTING.rst
@@ -127,7 +127,7 @@ First time setup in your local environment
 
     .. code-block:: text
 
-        $ python -m pip install -U pip setuptools wheel
+        $ python -m pip install -U pip
         $ pip install -r requirements/dev.txt && pip install -e .
 
 -   Install the pre-commit hooks.
diff --git a/MANIFEST.in b/MANIFEST.in
deleted file mode 100644
index 65a97749..00000000
--- a/MANIFEST.in
+++ /dev/null
@@ -1,11 +0,0 @@
-include CHANGES.rst
-include CONTRIBUTING.rst
-include tox.ini
-include requirements/*.txt
-graft artwork
-graft docs
-prune docs/_build
-graft examples
-graft tests
-include src/flask/py.typed
-global-exclude *.pyc
diff --git a/docs/api.rst b/docs/api.rst
index 043beb07..1aa8048f 100644
--- a/docs/api.rst
+++ b/docs/api.rst
@@ -519,11 +519,6 @@ Signals are provided by the `Blinker`_ library. See :doc:`signals` for an introd
 
    .. versionadded:: 0.10
 
-.. data:: signals.signals_available
-
-    .. deprecated:: 2.3
-        Will be removed in Flask 2.4. Signals are always available
-
 
 Class-Based Views
 -----------------
diff --git a/docs/config.rst b/docs/config.rst
index 3c06b29c..7828fb92 100644
--- a/docs/config.rst
+++ b/docs/config.rst
@@ -410,8 +410,8 @@ from a TOML file:
 
 .. code-block:: python
 
-    import toml
-    app.config.from_file("config.toml", load=toml.load)
+    import tomllib
+    app.config.from_file("config.toml", load=tomllib.load, text=False)
 
 Or from a JSON file:
 
diff --git a/docs/errorhandling.rst b/docs/errorhandling.rst
index c281055f..faca58c2 100644
--- a/docs/errorhandling.rst
+++ b/docs/errorhandling.rst
@@ -231,7 +231,7 @@ responses, you could also pass them through directly.
 Error handlers still respect the exception class hierarchy. If you
 register handlers for both ``HTTPException`` and ``Exception``, the
 ``Exception`` handler will not handle ``HTTPException`` subclasses
-because it the ``HTTPException`` handler is more specific.
+because the ``HTTPException`` handler is more specific.
 
 
 Unhandled Exceptions
diff --git a/docs/patterns/appdispatch.rst b/docs/patterns/appdispatch.rst
index efa470a7..f22c8060 100644
--- a/docs/patterns/appdispatch.rst
+++ b/docs/patterns/appdispatch.rst
@@ -18,34 +18,20 @@ Working with this Document
 --------------------------
 
 Each of the techniques and examples below results in an ``application``
-object that can be run with any WSGI server. For production, see
-:doc:`/deploying/index`. For development, Werkzeug provides a server
-through :func:`werkzeug.serving.run_simple`::
+object that can be run with any WSGI server. For development, use the
+``flask run`` command to start a development server. For production, see
+:doc:`/deploying/index`.
 
-    from werkzeug.serving import run_simple
-    run_simple('localhost', 5000, application, use_reloader=True)
-
-Note that :func:`run_simple <werkzeug.serving.run_simple>` is not intended for
-use in production.  Use a production WSGI server. See :doc:`/deploying/index`.
-
-In order to use the interactive debugger, debugging must be enabled both on
-the application and the simple server. Here is the "hello world" example with
-debugging and :func:`run_simple <werkzeug.serving.run_simple>`::
+.. code-block:: python
 
     from flask import Flask
-    from werkzeug.serving import run_simple
 
     app = Flask(__name__)
-    app.debug = True
 
     @app.route('/')
     def hello_world():
         return 'Hello World!'
 
-    if __name__ == '__main__':
-        run_simple('localhost', 5000, app,
-                   use_reloader=True, use_debugger=True, use_evalex=True)
-
 
 Combining Applications
 ----------------------
@@ -58,7 +44,9 @@ are combined by the dispatcher middleware into a larger one that is
 dispatched based on prefix.
 
 For example you could have your main application run on ``/`` and your
-backend interface on ``/backend``::
+backend interface on ``/backend``.
+
+.. code-block:: python
 
     from werkzeug.middleware.dispatcher import DispatcherMiddleware
     from frontend_app import application as frontend
@@ -89,7 +77,9 @@ the dynamic application creation.
 The perfect level for abstraction in that regard is the WSGI layer.  You
 write your own WSGI application that looks at the request that comes and
 delegates it to your Flask application.  If that application does not
-exist yet, it is dynamically created and remembered::
+exist yet, it is dynamically created and remembered.
+
+.. code-block:: python
 
     from threading import Lock
 
@@ -117,7 +107,9 @@ exist yet, it is dynamically created and remembered::
             return app(environ, start_response)
 
 
-This dispatcher can then be used like this::
+This dispatcher can then be used like this:
+
+.. code-block:: python
 
     from myapplication import create_app, get_user_for_subdomain
     from werkzeug.exceptions import NotFound
@@ -143,10 +135,12 @@ Dispatch by Path
 
 Dispatching by a path on the URL is very similar.  Instead of looking at
 the ``Host`` header to figure out the subdomain one simply looks at the
-request path up to the first slash::
+request path up to the first slash.
+
+.. code-block:: python
 
     from threading import Lock
-    from werkzeug.wsgi import pop_path_info, peek_path_info
+    from wsgiref.util import shift_path_info
 
     class PathDispatcher:
 
@@ -166,15 +160,24 @@ request path up to the first slash::
                 return app
 
         def __call__(self, environ, start_response):
-            app = self.get_application(peek_path_info(environ))
+            app = self.get_application(_peek_path_info(environ))
             if app is not None:
-                pop_path_info(environ)
+                shift_path_info(environ)
             else:
                 app = self.default_app
             return app(environ, start_response)
 
+    def _peek_path_info(environ):
+        segments = environ.get("PATH_INFO", "").lstrip("/").split("/", 1)
+        if segments:
+            return segments[0]
+
+        return None
+
 The big difference between this and the subdomain one is that this one
-falls back to another application if the creator function returns ``None``::
+falls back to another application if the creator function returns ``None``.
+
+.. code-block:: python
 
     from myapplication import create_app, default_app, get_user_for_prefix
 
diff --git a/docs/patterns/javascript.rst b/docs/patterns/javascript.rst
index 4b1d7e0f..d58a3eb6 100644
--- a/docs/patterns/javascript.rst
+++ b/docs/patterns/javascript.rst
@@ -125,8 +125,8 @@ in a Flask view.
 .. code-block:: javascript
 
     let data = new FormData()
-    data.append("name": "Flask Room")
-    data.append("description": "Talk about Flask here.")
+    data.append("name", "Flask Room")
+    data.append("description", "Talk about Flask here.")
     fetch(room_url, {
         "method": "POST",
         "body": data,
@@ -197,7 +197,7 @@ in the previous section. The following example shows how to replace a
         const geology_div = getElementById("geology-fact")
         fetch(geology_url)
             .then(response => response.text)
-            .then(text => geology_div.innerHtml = text)
+            .then(text => geology_div.innerHTML = text)
     </script>
 
 
diff --git a/docs/patterns/packages.rst b/docs/patterns/packages.rst
index 239a3fa2..90fa8a8f 100644
--- a/docs/patterns/packages.rst
+++ b/docs/patterns/packages.rst
@@ -54,8 +54,8 @@ a big problem, just add a new file called :file:`pyproject.toml` next to the inn
     ]
 
     [build-system]
-    requires = ["setuptools"]
-    build-backend = "setuptools.build_meta"
+    requires = ["flit_core<4"]
+    build-backend = "flit_core.buildapi"
 
 Install your application so it is importable:
 
diff --git a/docs/patterns/sqlalchemy.rst b/docs/patterns/sqlalchemy.rst
index 734d550c..7e4108d0 100644
--- a/docs/patterns/sqlalchemy.rst
+++ b/docs/patterns/sqlalchemy.rst
@@ -34,8 +34,7 @@ official documentation on the `declarative`_ extension.
 Here's the example :file:`database.py` module for your application::
 
     from sqlalchemy import create_engine
-    from sqlalchemy.orm import scoped_session, sessionmaker
-    from sqlalchemy.ext.declarative import declarative_base
+    from sqlalchemy.orm import scoped_session, sessionmaker, declarative_base
 
     engine = create_engine('sqlite:////tmp/test.db')
     db_session = scoped_session(sessionmaker(autocommit=False,
diff --git a/docs/server.rst b/docs/server.rst
index d38aa120..11e976bc 100644
--- a/docs/server.rst
+++ b/docs/server.rst
@@ -76,8 +76,8 @@ following example shows that process id 6847 is using port 5000.
             TCP 127.0.0.1:5000 0.0.0.0:0 LISTENING 6847
 
 macOS Monterey and later automatically starts a service that uses port
-5000. To disable the service, go to System Preferences, Sharing, and
-disable "AirPlay Receiver".
+5000. You can choose to disable this service instead of using a different port by
+searching for "AirPlay Receiver" in System Preferences and toggling it off.
 
 
 Deferred Errors on Reload
diff --git a/docs/tutorial/install.rst b/docs/tutorial/install.rst
index 9bb1234e..db83e106 100644
--- a/docs/tutorial/install.rst
+++ b/docs/tutorial/install.rst
@@ -35,35 +35,19 @@ The ``pyproject.toml`` file describes your project and how to build it.
     [project]
     name = "flaskr"
     version = "1.0.0"
+    description = "The basic blog app built in the Flask tutorial."
     dependencies = [
         "flask",
     ]
 
     [build-system]
-    requires = ["setuptools"]
-    build-backend = "setuptools.build_meta"
+    requires = ["flit_core<4"]
+    build-backend = "flit_core.buildapi"
 
-
-The setuptools build backend needs another file named ``MANIFEST.in`` to tell it about
-non-Python files to include.
-
-.. code-block:: none
-    :caption: ``MANIFEST.in``
-
-    include flaskr/schema.sql
-    graft flaskr/static
-    graft flaskr/templates
-    global-exclude *.pyc
-
-This tells the build to copy everything in the ``static`` and ``templates`` directories,
-and the ``schema.sql`` file, but to exclude all bytecode files.
-
-See the official `Packaging tutorial <packaging tutorial_>`_ and
-`detailed guide <packaging guide_>`_ for more explanation of the files
-and options used.
+See the official `Packaging tutorial <packaging tutorial_>`_ for more
+explanation of the files and options used.
 
 .. _packaging tutorial: https://packaging.python.org/tutorials/packaging-projects/
-.. _packaging guide: https://packaging.python.org/guides/distributing-packages-using-setuptools/
 
 
 Install the Project
@@ -95,9 +79,7 @@ You can observe that the project is now installed with ``pip list``.
     Jinja2         2.10
     MarkupSafe     1.0
     pip            9.0.3
-    setuptools     39.0.1
     Werkzeug       0.14.1
-    wheel          0.30.0
 
 Nothing changes from how you've been running your project so far.
 ``--app`` is still set to ``flaskr`` and ``flask run`` still runs
diff --git a/examples/celery/pyproject.toml b/examples/celery/pyproject.toml
index e480aebc..25887ca2 100644
--- a/examples/celery/pyproject.toml
+++ b/examples/celery/pyproject.toml
@@ -7,5 +7,11 @@ requires-python = ">=3.8"
 dependencies = ["flask>=2.2.2", "celery[redis]>=5.2.7"]
 
 [build-system]
-requires = ["setuptools"]
-build-backend = "setuptools.build_meta"
+requires = ["flit_core<4"]
+build-backend = "flit_core.buildapi"
+
+[tool.flit.module]
+name = "task_app"
+
+[tool.ruff]
+src = ["src"]
diff --git a/examples/celery/requirements.txt b/examples/celery/requirements.txt
index ce9ae72c..29075ab5 100644
--- a/examples/celery/requirements.txt
+++ b/examples/celery/requirements.txt
@@ -1,5 +1,5 @@
 #
-# This file is autogenerated by pip-compile with Python 3.10
+# This file is autogenerated by pip-compile with Python 3.11
 # by the following command:
 #
 #    pip-compile --resolver=backtracking pyproject.toml
@@ -10,6 +10,8 @@ async-timeout==4.0.2
     # via redis
 billiard==3.6.4.0
     # via celery
+blinker==1.6.2
+    # via flask
 celery[redis]==5.2.7
     # via flask-example-celery (pyproject.toml)
 click==8.1.3
@@ -25,7 +27,7 @@ click-plugins==1.1.1
     # via celery
 click-repl==0.2.0
     # via celery
-flask==2.2.3
+flask==2.3.2
     # via flask-example-celery (pyproject.toml)
 itsdangerous==2.1.2
     # via flask
@@ -37,11 +39,11 @@ markupsafe==2.1.2
     # via
     #   jinja2
     #   werkzeug
-prompt-toolkit==3.0.37
+prompt-toolkit==3.0.38
     # via click-repl
-pytz==2022.7.1
+pytz==2023.3
     # via celery
-redis==4.5.1
+redis==4.5.4
     # via celery
 six==1.16.0
     # via click-repl
@@ -52,5 +54,5 @@ vine==5.0.0
     #   kombu
 wcwidth==0.2.6
     # via prompt-toolkit
-werkzeug==2.2.3
+werkzeug==2.3.3
     # via flask
diff --git a/examples/javascript/MANIFEST.in b/examples/javascript/MANIFEST.in
deleted file mode 100644
index c730a34e..00000000
--- a/examples/javascript/MANIFEST.in
+++ /dev/null
@@ -1,4 +0,0 @@
-include LICENSE.rst
-graft js_example/templates
-graft tests
-global-exclude *.pyc
diff --git a/examples/javascript/js_example/views.py b/examples/javascript/js_example/views.py
index 0d4b6561..9f0d26c5 100644
--- a/examples/javascript/js_example/views.py
+++ b/examples/javascript/js_example/views.py
@@ -2,7 +2,7 @@ from flask import jsonify
 from flask import render_template
 from flask import request
 
-from js_example import app
+from . import app
 
 
 @app.route("/", defaults={"js": "fetch"})
diff --git a/examples/javascript/pyproject.toml b/examples/javascript/pyproject.toml
index e74415b8..0ec631d2 100644
--- a/examples/javascript/pyproject.toml
+++ b/examples/javascript/pyproject.toml
@@ -3,7 +3,7 @@ name = "js_example"
 version = "1.1.0"
 description = "Demonstrates making AJAX requests to Flask."
 readme = "README.rst"
-license = {text = "BSD-3-Clause"}
+license = {file = "LICENSE.rst"}
 maintainers = [{name = "Pallets", email = "contact@palletsprojects.com"}]
 dependencies = ["flask"]
 
@@ -14,8 +14,11 @@ Documentation = "https://flask.palletsprojects.com/patterns/jquery/"
 test = ["pytest"]
 
 [build-system]
-requires = ["setuptools"]
-build-backend = "setuptools.build_meta"
+requires = ["flit_core<4"]
+build-backend = "flit_core.buildapi"
+
+[tool.flit.module]
+name = "js_example"
 
 [tool.pytest.ini_options]
 testpaths = ["tests"]
@@ -24,3 +27,6 @@ filterwarnings = ["error"]
 [tool.coverage.run]
 branch = true
 source = ["js_example", "tests"]
+
+[tool.ruff]
+src = ["src"]
diff --git a/examples/tutorial/MANIFEST.in b/examples/tutorial/MANIFEST.in
deleted file mode 100644
index 97d55d51..00000000
--- a/examples/tutorial/MANIFEST.in
+++ /dev/null
@@ -1,6 +0,0 @@
-include LICENSE.rst
-include flaskr/schema.sql
-graft flaskr/static
-graft flaskr/templates
-graft tests
-global-exclude *.pyc
diff --git a/examples/tutorial/flaskr/__init__.py b/examples/tutorial/flaskr/__init__.py
index bb9cce5a..e35934d6 100644
--- a/examples/tutorial/flaskr/__init__.py
+++ b/examples/tutorial/flaskr/__init__.py
@@ -31,12 +31,13 @@ def create_app(test_config=None):
         return "Hello, World!"
 
     # register the database commands
-    from flaskr import db
+    from . import db
 
     db.init_app(app)
 
     # apply the blueprints to the app
-    from flaskr import auth, blog
+    from . import auth
+    from . import blog
 
     app.register_blueprint(auth.bp)
     app.register_blueprint(blog.bp)
diff --git a/examples/tutorial/flaskr/auth.py b/examples/tutorial/flaskr/auth.py
index b423e6ae..34c03a20 100644
--- a/examples/tutorial/flaskr/auth.py
+++ b/examples/tutorial/flaskr/auth.py
@@ -11,7 +11,7 @@ from flask import url_for
 from werkzeug.security import check_password_hash
 from werkzeug.security import generate_password_hash
 
-from flaskr.db import get_db
+from .db import get_db
 
 bp = Blueprint("auth", __name__, url_prefix="/auth")
 
diff --git a/examples/tutorial/flaskr/blog.py b/examples/tutorial/flaskr/blog.py
index 3704626b..be0d92c4 100644
--- a/examples/tutorial/flaskr/blog.py
+++ b/examples/tutorial/flaskr/blog.py
@@ -7,8 +7,8 @@ from flask import request
 from flask import url_for
 from werkzeug.exceptions import abort
 
-from flaskr.auth import login_required
-from flaskr.db import get_db
+from .auth import login_required
+from .db import get_db
 
 bp = Blueprint("blog", __name__)
 
diff --git a/examples/tutorial/pyproject.toml b/examples/tutorial/pyproject.toml
index c86eb61f..73a674ce 100644
--- a/examples/tutorial/pyproject.toml
+++ b/examples/tutorial/pyproject.toml
@@ -16,8 +16,16 @@ Documentation = "https://flask.palletsprojects.com/tutorial/"
 test = ["pytest"]
 
 [build-system]
-requires = ["setuptools"]
-build-backend = "setuptools.build_meta"
+requires = ["flit_core<4"]
+build-backend = "flit_core.buildapi"
+
+[tool.flit.module]
+name = "flaskr"
+
+[tool.flit.sdist]
+include = [
+    "tests/",
+]
 
 [tool.pytest.ini_options]
 testpaths = ["tests"]
@@ -26,3 +34,6 @@ filterwarnings = ["error"]
 [tool.coverage.run]
 branch = true
 source = ["flaskr", "tests"]
+
+[tool.ruff]
+src = ["src"]
diff --git a/pyproject.toml b/pyproject.toml
index 400ed59f..3fefae18 100644
--- a/pyproject.toml
+++ b/pyproject.toml
@@ -1,10 +1,10 @@
 [project]
 name = "Flask"
+version = "3.0.2"
 description = "A simple framework for building complex web applications."
 readme = "README.rst"
-license = {text = "BSD-3-Clause"}
+license = {file = "LICENSE.rst"}
 maintainers = [{name = "Pallets", email = "contact@palletsprojects.com"}]
-authors = [{name = "Armin Ronacher", email = "armin.ronacher@active-4.com"}]
 classifiers = [
     "Development Status :: 5 - Production/Stable",
     "Environment :: Web Environment",
@@ -20,14 +20,13 @@ classifiers = [
 ]
 requires-python = ">=3.8"
 dependencies = [
-    "Werkzeug>=2.3.3",
+    "Werkzeug>=3.0.0",
     "Jinja2>=3.1.2",
     "itsdangerous>=2.1.2",
     "click>=8.1.3",
     "blinker>=1.6.2",
     "importlib-metadata>=3.6.0; python_version < '3.10'",
 ]
-dynamic = ["version"]
 
 [project.urls]
 Donate = "https://palletsprojects.com/donate"
@@ -45,18 +44,30 @@ dotenv = ["python-dotenv"]
 flask = "flask.cli:main"
 
 [build-system]
-requires = ["setuptools"]
-build-backend = "setuptools.build_meta"
+requires = ["flit_core<4"]
+build-backend = "flit_core.buildapi"
 
-[tool.setuptools.dynamic]
-version = {attr = "flask.__version__"}
+[tool.flit.module]
+name = "flask"
+
+[tool.flit.sdist]
+include = [
+    "docs/",
+    "examples/",
+    "requirements/",
+    "tests/",
+    "CHANGES.rst",
+    "CONTRIBUTING.rst",
+    "tox.ini",
+]
+exclude = [
+    "docs/_build/",
+]
 
 [tool.pytest.ini_options]
 testpaths = ["tests"]
 filterwarnings = [
     "error",
-    # change in Python 3.12 alpha causes warning from inside pytest
-    "ignore:onerror argument:DeprecationWarning",
 ]
 
 [tool.coverage.run]
@@ -68,24 +79,10 @@ source = ["src", "*/site-packages"]
 
 [tool.mypy]
 python_version = "3.8"
-files = ["src/flask"]
+files = ["src/flask", "tests/typing"]
 show_error_codes = true
 pretty = true
-#strict = true
-allow_redefinition = true
-disallow_subclassing_any = true
-#disallow_untyped_calls = true
-#disallow_untyped_defs = true
-#disallow_incomplete_defs = true
-no_implicit_optional = true
-local_partial_types = true
-#no_implicit_reexport = true
-strict_equality = true
-warn_redundant_casts = true
-warn_unused_configs = true
-warn_unused_ignores = true
-#warn_return_any = true
-#warn_unreachable = true
+strict = true
 
 [[tool.mypy.overrides]]
 module = [
@@ -95,3 +92,24 @@ module = [
     "importlib_metadata",
 ]
 ignore_missing_imports = true
+
+[tool.ruff]
+src = ["src"]
+fix = true
+show-fixes = true
+show-source = true
+
+[tool.ruff.lint]
+select = [
+    "B",  # flake8-bugbear
+    "E",  # pycodestyle error
+    "F",  # pyflakes
+    "I",  # isort
+    "UP",  # pyupgrade
+    "W",  # pycodestyle warning
+]
+ignore-init-module-imports = true
+
+[tool.ruff.lint.isort]
+force-single-line = true
+order-by-type = false
diff --git a/requirements-skip/README.md b/requirements-skip/README.md
new file mode 100644
index 00000000..675ca4ab
--- /dev/null
+++ b/requirements-skip/README.md
@@ -0,0 +1,2 @@
+Dependabot will only update files in the `requirements` directory. This directory is
+separate because the pins in here should not be updated automatically.
diff --git a/requirements-skip/tests-dev.txt b/requirements-skip/tests-dev.txt
new file mode 100644
index 00000000..3e7f028e
--- /dev/null
+++ b/requirements-skip/tests-dev.txt
@@ -0,0 +1,6 @@
+https://github.com/pallets/werkzeug/archive/refs/heads/main.tar.gz
+https://github.com/pallets/jinja/archive/refs/heads/main.tar.gz
+https://github.com/pallets/markupsafe/archive/refs/heads/main.tar.gz
+https://github.com/pallets/itsdangerous/archive/refs/heads/main.tar.gz
+https://github.com/pallets/click/archive/refs/heads/main.tar.gz
+https://github.com/pallets-eco/blinker/archive/refs/heads/main.tar.gz
diff --git a/requirements/tests-pallets-min.in b/requirements-skip/tests-min.in
similarity index 50%
rename from requirements/tests-pallets-min.in
rename to requirements-skip/tests-min.in
index 5b2a6ff7..c7ec9969 100644
--- a/requirements/tests-pallets-min.in
+++ b/requirements-skip/tests-min.in
@@ -1,6 +1,6 @@
-Werkzeug==2.3.3
-Jinja2==3.1.2
-MarkupSafe==2.1.1
+werkzeug==3.0.0
+jinja2==3.1.2
+markupsafe==2.1.1
 itsdangerous==2.1.2
 click==8.1.3
 blinker==1.6.2
diff --git a/requirements-skip/tests-min.txt b/requirements-skip/tests-min.txt
new file mode 100644
index 00000000..8a6cbf02
--- /dev/null
+++ b/requirements-skip/tests-min.txt
@@ -0,0 +1,21 @@
+#
+# This file is autogenerated by pip-compile with Python 3.11
+# by the following command:
+#
+#    pip-compile tests-min.in
+#
+blinker==1.6.2
+    # via -r tests-min.in
+click==8.1.3
+    # via -r tests-min.in
+itsdangerous==2.1.2
+    # via -r tests-min.in
+jinja2==3.1.2
+    # via -r tests-min.in
+markupsafe==2.1.1
+    # via
+    #   -r tests-min.in
+    #   jinja2
+    #   werkzeug
+werkzeug==3.0.0
+    # via -r tests-min.in
diff --git a/requirements/build.txt b/requirements/build.txt
index 196545d0..6bfd666c 100644
--- a/requirements/build.txt
+++ b/requirements/build.txt
@@ -1,13 +1,12 @@
-# SHA1:80754af91bfb6d1073585b046fe0a474ce868509
 #
-# This file is autogenerated by pip-compile-multi
-# To update, run:
+# This file is autogenerated by pip-compile with Python 3.11
+# by the following command:
 #
-#    pip-compile-multi
+#    pip-compile build.in
 #
-build==0.10.0
-    # via -r requirements/build.in
-packaging==23.1
+build==1.0.3
+    # via -r build.in
+packaging==23.2
     # via build
 pyproject-hooks==1.0.0
     # via build
diff --git a/requirements/dev.in b/requirements/dev.in
index 99f5942f..2588467c 100644
--- a/requirements/dev.in
+++ b/requirements/dev.in
@@ -1,6 +1,6 @@
 -r docs.in
 -r tests.in
 -r typing.in
-pip-compile-multi
+pip-tools
 pre-commit
 tox
diff --git a/requirements/dev.txt b/requirements/dev.txt
index f9732cc9..454616e2 100644
--- a/requirements/dev.txt
+++ b/requirements/dev.txt
@@ -1,62 +1,149 @@
-# SHA1:54b5b77ec8c7a0064ffa93b2fd16cb0130ba177c
 #
-# This file is autogenerated by pip-compile-multi
-# To update, run:
+# This file is autogenerated by pip-compile with Python 3.11
+# by the following command:
 #
-#    pip-compile-multi
+#    pip-compile dev.in
 #
--r docs.txt
--r tests.txt
--r typing.txt
-build==0.10.0
+alabaster==0.7.16
+    # via sphinx
+asgiref==3.7.2
+    # via
+    #   -r tests.in
+    #   -r typing.in
+babel==2.14.0
+    # via sphinx
+build==1.0.3
     # via pip-tools
-cachetools==5.3.0
+cachetools==5.3.2
     # via tox
-cfgv==3.3.1
+certifi==2023.11.17
+    # via requests
+cffi==1.16.0
+    # via cryptography
+cfgv==3.4.0
     # via pre-commit
-chardet==5.1.0
+chardet==5.2.0
     # via tox
-click==8.1.3
-    # via
-    #   pip-compile-multi
-    #   pip-tools
+charset-normalizer==3.3.2
+    # via requests
+click==8.1.7
+    # via pip-tools
 colorama==0.4.6
     # via tox
-distlib==0.3.6
+cryptography==41.0.7
+    # via -r typing.in
+distlib==0.3.8
     # via virtualenv
-filelock==3.12.0
+docutils==0.18.1
+    # via
+    #   sphinx
+    #   sphinx-tabs
+filelock==3.13.1
     # via
     #   tox
     #   virtualenv
-identify==2.5.22
+identify==2.5.33
     # via pre-commit
-nodeenv==1.7.0
+idna==3.6
+    # via requests
+imagesize==1.4.1
+    # via sphinx
+iniconfig==2.0.0
+    # via pytest
+jinja2==3.1.3
+    # via sphinx
+markupsafe==2.1.3
+    # via jinja2
+mypy==1.8.0
+    # via -r typing.in
+mypy-extensions==1.0.0
+    # via mypy
+nodeenv==1.8.0
     # via pre-commit
-pip-compile-multi==2.6.2
-    # via -r requirements/dev.in
-pip-tools==6.13.0
-    # via pip-compile-multi
-platformdirs==3.3.0
+packaging==23.2
+    # via
+    #   build
+    #   pallets-sphinx-themes
+    #   pyproject-api
+    #   pytest
+    #   sphinx
+    #   tox
+pallets-sphinx-themes==2.1.1
+    # via -r docs.in
+pip-tools==7.3.0
+    # via -r dev.in
+platformdirs==4.1.0
     # via
     #   tox
     #   virtualenv
-pre-commit==3.2.2
-    # via -r requirements/dev.in
-pyproject-api==1.5.1
+pluggy==1.3.0
+    # via
+    #   pytest
+    #   tox
+pre-commit==3.6.0
+    # via -r dev.in
+pycparser==2.21
+    # via cffi
+pygments==2.17.2
+    # via
+    #   sphinx
+    #   sphinx-tabs
+pyproject-api==1.6.1
     # via tox
 pyproject-hooks==1.0.0
     # via build
-pyyaml==6.0
+pytest==7.4.4
+    # via -r tests.in
+python-dotenv==1.0.0
+    # via
+    #   -r tests.in
+    #   -r typing.in
+pyyaml==6.0.1
     # via pre-commit
-toposort==1.10
-    # via pip-compile-multi
-tox==4.5.0
-    # via -r requirements/dev.in
-virtualenv==20.22.0
+requests==2.31.0
+    # via sphinx
+snowballstemmer==2.2.0
+    # via sphinx
+sphinx==7.2.6
+    # via
+    #   -r docs.in
+    #   pallets-sphinx-themes
+    #   sphinx-issues
+    #   sphinx-tabs
+    #   sphinxcontrib-log-cabinet
+sphinx-issues==3.0.1
+    # via -r docs.in
+sphinx-tabs==3.4.4
+    # via -r docs.in
+sphinxcontrib-applehelp==1.0.8
+    # via sphinx
+sphinxcontrib-devhelp==1.0.6
+    # via sphinx
+sphinxcontrib-htmlhelp==2.0.5
+    # via sphinx
+sphinxcontrib-jsmath==1.0.1
+    # via sphinx
+sphinxcontrib-log-cabinet==1.0.1
+    # via -r docs.in
+sphinxcontrib-qthelp==1.0.7
+    # via sphinx
+sphinxcontrib-serializinghtml==1.1.10
+    # via sphinx
+tox==4.12.0
+    # via -r dev.in
+types-contextvars==2.4.7.3
+    # via -r typing.in
+types-dataclasses==0.6.6
+    # via -r typing.in
+typing-extensions==4.9.0
+    # via mypy
+urllib3==2.1.0
+    # via requests
+virtualenv==20.25.0
     # via
     #   pre-commit
     #   tox
-wheel==0.40.0
+wheel==0.42.0
     # via pip-tools
 
 # The following packages are considered to be unsafe in a requirements file:
diff --git a/requirements/docs.in b/requirements/docs.in
index 3a389e2b..a00c08f8 100644
--- a/requirements/docs.in
+++ b/requirements/docs.in
@@ -1,7 +1,5 @@
-Pallets-Sphinx-Themes
-# sphinx 5 introduced error in references from werkzeug in docstrings
-Sphinx < 5
+pallets-sphinx-themes
+sphinx
 sphinx-issues
 sphinxcontrib-log-cabinet
-# sphinx-tabs 3.4 requires docutils 0.18, sphinx < 5 requires < 0.18
-sphinx-tabs < 3.4
+sphinx-tabs
diff --git a/requirements/docs.txt b/requirements/docs.txt
index 7ee48f68..fed1b7b9 100644
--- a/requirements/docs.txt
+++ b/requirements/docs.txt
@@ -1,68 +1,67 @@
-# SHA1:323f1c1134d78952ea63131c187303def63b56bd
 #
-# This file is autogenerated by pip-compile-multi
-# To update, run:
+# This file is autogenerated by pip-compile with Python 3.11
+# by the following command:
 #
-#    pip-compile-multi
+#    pip-compile docs.in
 #
-alabaster==0.7.13
+alabaster==0.7.16
     # via sphinx
-babel==2.12.1
+babel==2.14.0
     # via sphinx
-certifi==2022.12.7
+certifi==2023.11.17
     # via requests
-charset-normalizer==3.1.0
+charset-normalizer==3.3.2
     # via requests
-docutils==0.17.1
+docutils==0.18.1
     # via
     #   sphinx
     #   sphinx-tabs
-idna==3.4
+idna==3.6
     # via requests
 imagesize==1.4.1
     # via sphinx
-jinja2==3.1.2
+jinja2==3.1.3
     # via sphinx
-markupsafe==2.1.2
+markupsafe==2.1.3
     # via jinja2
-packaging==23.1
+packaging==23.2
     # via
     #   pallets-sphinx-themes
     #   sphinx
-pallets-sphinx-themes==2.1.0
-    # via -r requirements/docs.in
-pygments==2.15.1
+pallets-sphinx-themes==2.1.1
+    # via -r docs.in
+pygments==2.17.2
     # via
     #   sphinx
     #   sphinx-tabs
-requests==2.28.2
+requests==2.31.0
     # via sphinx
 snowballstemmer==2.2.0
     # via sphinx
-sphinx==4.5.0
+sphinx==7.2.6
     # via
-    #   -r requirements/docs.in
+    #   -r docs.in
     #   pallets-sphinx-themes
     #   sphinx-issues
     #   sphinx-tabs
     #   sphinxcontrib-log-cabinet
 sphinx-issues==3.0.1
-    # via -r requirements/docs.in
-sphinx-tabs==3.3.1
-    # via -r requirements/docs.in
-sphinxcontrib-applehelp==1.0.4
+    # via -r docs.in
+sphinx-tabs==3.4.4
+    # via -r docs.in
+sphinxcontrib-applehelp==1.0.8
     # via sphinx
-sphinxcontrib-devhelp==1.0.2
+sphinxcontrib-devhelp==1.0.6
     # via sphinx
-sphinxcontrib-htmlhelp==2.0.1
+sphinxcontrib-htmlhelp==2.0.5
     # via sphinx
 sphinxcontrib-jsmath==1.0.1
     # via sphinx
 sphinxcontrib-log-cabinet==1.0.1
-    # via -r requirements/docs.in
-sphinxcontrib-qthelp==1.0.3
+    # via -r docs.in
+sphinxcontrib-qthelp==1.0.7
     # via sphinx
-sphinxcontrib-serializinghtml==1.1.5
+sphinxcontrib-serializinghtml==1.1.10
     # via sphinx
-urllib3==1.26.15
+urllib3==2.1.0
     # via requests
diff --git a/requirements/tests-pallets-min.txt b/requirements/tests-pallets-min.txt
deleted file mode 100644
index 1a79a37b..00000000
--- a/requirements/tests-pallets-min.txt
+++ /dev/null
@@ -1,22 +0,0 @@
-# SHA1:0b58503b99aabc227b7f39357216d676d9987a12
-#
-# This file is autogenerated by pip-compile-multi
-# To update, run:
-#
-#    pip-compile-multi
-#
-blinker==1.6.2
-    # via -r requirements/tests-pallets-min.in
-click==8.1.3
-    # via -r requirements/tests-pallets-min.in
-itsdangerous==2.1.2
-    # via -r requirements/tests-pallets-min.in
-jinja2==3.1.2
-    # via -r requirements/tests-pallets-min.in
-markupsafe==2.1.1
-    # via
-    #   -r requirements/tests-pallets-min.in
-    #   jinja2
-    #   werkzeug
-werkzeug==2.3.3
-    # via -r requirements/tests-pallets-min.in
diff --git a/requirements/tests.txt b/requirements/tests.txt
index 29044fb5..4f7a590c 100644
--- a/requirements/tests.txt
+++ b/requirements/tests.txt
@@ -1,19 +1,18 @@
-# SHA1:42d37aff22e2f1fc447e20d483e13d6d4e066b10
 #
-# This file is autogenerated by pip-compile-multi
-# To update, run:
+# This file is autogenerated by pip-compile with Python 3.11
+# by the following command:
 #
-#    pip-compile-multi
+#    pip-compile tests.in
 #
-asgiref==3.6.0
-    # via -r requirements/tests.in
+asgiref==3.7.2
+    # via -r tests.in
 iniconfig==2.0.0
     # via pytest
-packaging==23.1
+packaging==23.2
     # via pytest
-pluggy==1.0.0
+pluggy==1.3.0
     # via pytest
-pytest==7.3.1
-    # via -r requirements/tests.in
+pytest==7.4.4
+    # via -r tests.in
 python-dotenv==1.0.0
-    # via -r requirements/tests.in
+    # via -r tests.in
diff --git a/requirements/typing.in b/requirements/typing.in
index 2c589ea0..211e0bd7 100644
--- a/requirements/typing.in
+++ b/requirements/typing.in
@@ -1,5 +1,6 @@
 mypy
 types-contextvars
 types-dataclasses
-types-setuptools
+asgiref
 cryptography
+python-dotenv
diff --git a/requirements/typing.txt b/requirements/typing.txt
index 7b40becb..adbef1ab 100644
--- a/requirements/typing.txt
+++ b/requirements/typing.txt
@@ -1,25 +1,26 @@
-# SHA1:7cc3f64d4e78db89d81680ac81503d5ac35d31a9
 #
-# This file is autogenerated by pip-compile-multi
-# To update, run:
+# This file is autogenerated by pip-compile with Python 3.11
+# by the following command:
 #
-#    pip-compile-multi
+#    pip-compile typing.in
 #
-cffi==1.15.1
+asgiref==3.7.2
+    # via -r typing.in
+cffi==1.16.0
     # via cryptography
-cryptography==40.0.2
-    # via -r requirements/typing.in
-mypy==1.2.0
-    # via -r requirements/typing.in
+cryptography==41.0.7
+    # via -r typing.in
+mypy==1.8.0
+    # via -r typing.in
 mypy-extensions==1.0.0
     # via mypy
 pycparser==2.21
     # via cffi
-types-contextvars==2.4.7.2
-    # via -r requirements/typing.in
+python-dotenv==1.0.0
+    # via -r typing.in
+types-contextvars==2.4.7.3
+    # via -r typing.in
 types-dataclasses==0.6.6
-    # via -r requirements/typing.in
-types-setuptools==67.7.0.0
-    # via -r requirements/typing.in
-typing-extensions==4.5.0
+    # via -r typing.in
+typing-extensions==4.9.0
     # via mypy
diff --git a/src/flask/__init__.py b/src/flask/__init__.py
index 0bef2213..e86eb43e 100644
--- a/src/flask/__init__.py
+++ b/src/flask/__init__.py
@@ -1,7 +1,9 @@
+from __future__ import annotations
+
+import typing as t
+
 from . import json as json
 from .app import Flask as Flask
-from .app import Request as Request
-from .app import Response as Response
 from .blueprints import Blueprint as Blueprint
 from .config import Config as Config
 from .ctx import after_this_request as after_this_request
@@ -37,66 +39,22 @@ from .templating import render_template as render_template
 from .templating import render_template_string as render_template_string
 from .templating import stream_template as stream_template
 from .templating import stream_template_string as stream_template_string
+from .wrappers import Request as Request
+from .wrappers import Response as Response
 
-__version__ = "2.3.2"
-
-
-def __getattr__(name):
-    if name == "_app_ctx_stack":
-        import warnings
-        from .globals import __app_ctx_stack
-
-        warnings.warn(
-            "'_app_ctx_stack' is deprecated and will be removed in Flask 2.4.",
-            DeprecationWarning,
-            stacklevel=2,
-        )
-        return __app_ctx_stack
-
-    if name == "_request_ctx_stack":
-        import warnings
-        from .globals import __request_ctx_stack
-
-        warnings.warn(
-            "'_request_ctx_stack' is deprecated and will be removed in Flask 2.4.",
-            DeprecationWarning,
-            stacklevel=2,
-        )
-        return __request_ctx_stack
-
-    if name == "escape":
-        import warnings
-        from markupsafe import escape
-
-        warnings.warn(
-            "'flask.escape' is deprecated and will be removed in Flask 2.4. Import"
-            " 'markupsafe.escape' instead.",
-            DeprecationWarning,
-            stacklevel=2,
-        )
-        return escape
-
-    if name == "Markup":
-        import warnings
-        from markupsafe import Markup
-
-        warnings.warn(
-            "'flask.Markup' is deprecated and will be removed in Flask 2.4. Import"
-            " 'markupsafe.Markup' instead.",
-            DeprecationWarning,
-            stacklevel=2,
-        )
-        return Markup
 
-    if name == "signals_available":
+def __getattr__(name: str) -> t.Any:
+    if name == "__version__":
+        import importlib.metadata
         import warnings
 
         warnings.warn(
-            "'signals_available' is deprecated and will be removed in Flask 2.4."
-            " Signals are always available",
+            "The '__version__' attribute is deprecated and will be removed in"
+            " Flask 3.1. Use feature detection or"
+            " 'importlib.metadata.version(\"flask\")' instead.",
             DeprecationWarning,
             stacklevel=2,
         )
-        return True
+        return importlib.metadata.version("flask")
 
     raise AttributeError(name)
diff --git a/src/flask/app.py b/src/flask/app.py
index 3b6b38d8..12ac50d4 100644
--- a/src/flask/app.py
+++ b/src/flask/app.py
@@ -1,11 +1,10 @@
 from __future__ import annotations
 
-import logging
+import collections.abc as cabc
 import os
 import sys
 import typing as t
 import weakref
-from collections.abc import Iterator as _abc_Iterator
 from datetime import timedelta
 from inspect import iscoroutinefunction
 from itertools import chain
@@ -15,47 +14,34 @@ from urllib.parse import quote as _url_quote
 import click
 from werkzeug.datastructures import Headers
 from werkzeug.datastructures import ImmutableDict
-from werkzeug.exceptions import Aborter
-from werkzeug.exceptions import BadRequest
 from werkzeug.exceptions import BadRequestKeyError
 from werkzeug.exceptions import HTTPException
 from werkzeug.exceptions import InternalServerError
 from werkzeug.routing import BuildError
-from werkzeug.routing import Map
 from werkzeug.routing import MapAdapter
 from werkzeug.routing import RequestRedirect
 from werkzeug.routing import RoutingException
 from werkzeug.routing import Rule
 from werkzeug.serving import is_running_from_reloader
-from werkzeug.utils import cached_property
-from werkzeug.utils import redirect as _wz_redirect
 from werkzeug.wrappers import Response as BaseResponse
 
 from . import cli
 from . import typing as ft
-from .config import Config
-from .config import ConfigAttribute
-from .ctx import _AppCtxGlobals
 from .ctx import AppContext
 from .ctx import RequestContext
 from .globals import _cv_app
 from .globals import _cv_request
+from .globals import current_app
 from .globals import g
 from .globals import request
 from .globals import request_ctx
 from .globals import session
-from .helpers import _split_blueprint_path
 from .helpers import get_debug_flag
 from .helpers import get_flashed_messages
 from .helpers import get_load_dotenv
-from .json.provider import DefaultJSONProvider
-from .json.provider import JSONProvider
-from .logging import create_logger
-from .scaffold import _endpoint_from_view_func
-from .scaffold import _sentinel
-from .scaffold import find_package
-from .scaffold import Scaffold
-from .scaffold import setupmethod
+from .helpers import send_from_directory
+from .sansio.app import App
+from .sansio.scaffold import _sentinel
 from .sessions import SecureCookieSessionInterface
 from .sessions import SessionInterface
 from .signals import appcontext_tearing_down
@@ -63,13 +49,14 @@ from .signals import got_request_exception
 from .signals import request_finished
 from .signals import request_started
 from .signals import request_tearing_down
-from .templating import DispatchingJinjaLoader
 from .templating import Environment
 from .wrappers import Request
 from .wrappers import Response
 
 if t.TYPE_CHECKING:  # pragma: no cover
-    from .blueprints import Blueprint
+    from _typeshed.wsgi import StartResponse
+    from _typeshed.wsgi import WSGIEnvironment
+
     from .testing import FlaskClient
     from .testing import FlaskCliRunner
 
@@ -89,7 +76,7 @@ def _make_timedelta(value: timedelta | int | None) -> timedelta | None:
     return timedelta(seconds=value)
 
 
-class Flask(Scaffold):
+class Flask(App):
     """The flask object implements a WSGI application and acts as the central
     object.  It is passed the name of the module or package of the
     application.  Once it is created it will act as a central registry for
@@ -186,111 +173,6 @@ class Flask(Scaffold):
         automatically, such as for namespace packages.
     """
 
-    #: The class that is used for request objects.  See :class:`~flask.Request`
-    #: for more information.
-    request_class = Request
-
-    #: The class that is used for response objects.  See
-    #: :class:`~flask.Response` for more information.
-    response_class = Response
-
-    #: The class of the object assigned to :attr:`aborter`, created by
-    #: :meth:`create_aborter`. That object is called by
-    #: :func:`flask.abort` to raise HTTP errors, and can be
-    #: called directly as well.
-    #:
-    #: Defaults to :class:`werkzeug.exceptions.Aborter`.
-    #:
-    #: .. versionadded:: 2.2
-    aborter_class = Aborter
-
-    #: The class that is used for the Jinja environment.
-    #:
-    #: .. versionadded:: 0.11
-    jinja_environment = Environment
-
-    #: The class that is used for the :data:`~flask.g` instance.
-    #:
-    #: Example use cases for a custom class:
-    #:
-    #: 1. Store arbitrary attributes on flask.g.
-    #: 2. Add a property for lazy per-request database connectors.
-    #: 3. Return None instead of AttributeError on unexpected attributes.
-    #: 4. Raise exception if an unexpected attr is set, a "controlled" flask.g.
-    #:
-    #: In Flask 0.9 this property was called `request_globals_class` but it
-    #: was changed in 0.10 to :attr:`app_ctx_globals_class` because the
-    #: flask.g object is now application context scoped.
-    #:
-    #: .. versionadded:: 0.10
-    app_ctx_globals_class = _AppCtxGlobals
-
-    #: The class that is used for the ``config`` attribute of this app.
-    #: Defaults to :class:`~flask.Config`.
-    #:
-    #: Example use cases for a custom class:
-    #:
-    #: 1. Default values for certain config options.
-    #: 2. Access to config values through attributes in addition to keys.
-    #:
-    #: .. versionadded:: 0.11
-    config_class = Config
-
-    #: The testing flag.  Set this to ``True`` to enable the test mode of
-    #: Flask extensions (and in the future probably also Flask itself).
-    #: For example this might activate test helpers that have an
-    #: additional runtime cost which should not be enabled by default.
-    #:
-    #: If this is enabled and PROPAGATE_EXCEPTIONS is not changed from the
-    #: default it's implicitly enabled.
-    #:
-    #: This attribute can also be configured from the config with the
-    #: ``TESTING`` configuration key.  Defaults to ``False``.
-    testing = ConfigAttribute("TESTING")
-
-    #: If a secret key is set, cryptographic components can use this to
-    #: sign cookies and other things. Set this to a complex random value
-    #: when you want to use the secure cookie for instance.
-    #:
-    #: This attribute can also be configured from the config with the
-    #: :data:`SECRET_KEY` configuration key. Defaults to ``None``.
-    secret_key = ConfigAttribute("SECRET_KEY")
-
-    #: A :class:`~datetime.timedelta` which is used to set the expiration
-    #: date of a permanent session.  The default is 31 days which makes a
-    #: permanent session survive for roughly one month.
-    #:
-    #: This attribute can also be configured from the config with the
-    #: ``PERMANENT_SESSION_LIFETIME`` configuration key.  Defaults to
-    #: ``timedelta(days=31)``
-    permanent_session_lifetime = ConfigAttribute(
-        "PERMANENT_SESSION_LIFETIME", get_converter=_make_timedelta
-    )
-
-    json_provider_class: type[JSONProvider] = DefaultJSONProvider
-    """A subclass of :class:`~flask.json.provider.JSONProvider`. An
-    instance is created and assigned to :attr:`app.json` when creating
-    the app.
-
-    The default, :class:`~flask.json.provider.DefaultJSONProvider`, uses
-    Python's built-in :mod:`json` library. A different provider can use
-    a different JSON library.
-
-    .. versionadded:: 2.2
-    """
-
-    #: Options that are passed to the Jinja environment in
-    #: :meth:`create_jinja_environment`. Changing these options after
-    #: the environment is created (accessing :attr:`jinja_env`) will
-    #: have no effect.
-    #:
-    #: .. versionchanged:: 1.1.0
-    #:     This is a ``dict`` instead of an ``ImmutableDict`` to allow
-    #:     easier configuration.
-    #:
-    jinja_options: dict = {}
-
-    #: Default configuration parameters.
     default_config = ImmutableDict(
         {
             "DEBUG": None,
@@ -319,31 +201,13 @@ class Flask(Scaffold):
         }
     )
 
-    #: The rule object to use for URL rules created.  This is used by
-    #: :meth:`add_url_rule`.  Defaults to :class:`werkzeug.routing.Rule`.
-    #:
-    #: .. versionadded:: 0.7
-    url_rule_class = Rule
-
-    #: The map object to use for storing the URL rules and routing
-    #: configuration parameters. Defaults to :class:`werkzeug.routing.Map`.
-    #:
-    #: .. versionadded:: 1.1.0
-    url_map_class = Map
-
-    #: The :meth:`test_client` method creates an instance of this test
-    #: client class. Defaults to :class:`~flask.testing.FlaskClient`.
-    #:
-    #: .. versionadded:: 0.7
-    test_client_class: type[FlaskClient] | None = None
+    #: The class that is used for request objects.  See :class:`~flask.Request`
+    #: for more information.
+    request_class: type[Request] = Request
 
-    #: The :class:`~click.testing.CliRunner` subclass, by default
-    #: :class:`~flask.testing.FlaskCliRunner` that is used by
-    #: :meth:`test_cli_runner`. Its ``__init__`` method should take a
-    #: Flask app object as the first argument.
-    #:
-    #: .. versionadded:: 1.0
-    test_cli_runner_class: type[FlaskCliRunner] | None = None
+    #: The class that is used for response objects.  See
+    #: :class:`~flask.Response` for more information.
+    response_class: type[Response] = Response
 
     #: the session interface to use.  By default an instance of
     #: :class:`~flask.sessions.SecureCookieSessionInterface` is used here.
@@ -355,134 +219,28 @@ class Flask(Scaffold):
         self,
         import_name: str,
         static_url_path: str | None = None,
-        static_folder: str | os.PathLike | None = "static",
+        static_folder: str | os.PathLike[str] | None = "static",
         static_host: str | None = None,
         host_matching: bool = False,
         subdomain_matching: bool = False,
-        template_folder: str | os.PathLike | None = "templates",
+        template_folder: str | os.PathLike[str] | None = "templates",
         instance_path: str | None = None,
         instance_relative_config: bool = False,
         root_path: str | None = None,
     ):
         super().__init__(
             import_name=import_name,
-            static_folder=static_folder,
             static_url_path=static_url_path,
+            static_folder=static_folder,
+            static_host=static_host,
+            host_matching=host_matching,
+            subdomain_matching=subdomain_matching,
             template_folder=template_folder,
+            instance_path=instance_path,
+            instance_relative_config=instance_relative_config,
             root_path=root_path,
         )
 
-        if instance_path is None:
-            instance_path = self.auto_find_instance_path()
-        elif not os.path.isabs(instance_path):
-            raise ValueError(
-                "If an instance path is provided it must be absolute."
-                " A relative path was given instead."
-            )
-
-        #: Holds the path to the instance folder.
-        #:
-        #: .. versionadded:: 0.8
-        self.instance_path = instance_path
-
-        #: The configuration dictionary as :class:`Config`.  This behaves
-        #: exactly like a regular dictionary but supports additional methods
-        #: to load a config from files.
-        self.config = self.make_config(instance_relative_config)
-
-        #: An instance of :attr:`aborter_class` created by
-        #: :meth:`make_aborter`. This is called by :func:`flask.abort`
-        #: to raise HTTP errors, and can be called directly as well.
-        #:
-        #: .. versionadded:: 2.2
-        #:     Moved from ``flask.abort``, which calls this object.
-        self.aborter = self.make_aborter()
-
-        self.json: JSONProvider = self.json_provider_class(self)
-        """Provides access to JSON methods. Functions in ``flask.json``
-        will call methods on this provider when the application context
-        is active. Used for handling JSON requests and responses.
-
-        An instance of :attr:`json_provider_class`. Can be customized by
-        changing that attribute on a subclass, or by assigning to this
-        attribute afterwards.
-
-        The default, :class:`~flask.json.provider.DefaultJSONProvider`,
-        uses Python's built-in :mod:`json` library. A different provider
-        can use a different JSON library.
-
-        .. versionadded:: 2.2
-        """
-
-        #: A list of functions that are called by
-        #: :meth:`handle_url_build_error` when :meth:`.url_for` raises a
-        #: :exc:`~werkzeug.routing.BuildError`. Each function is called
-        #: with ``error``, ``endpoint`` and ``values``. If a function
-        #: returns ``None`` or raises a ``BuildError``, it is skipped.
-        #: Otherwise, its return value is returned by ``url_for``.
-        #:
-        #: .. versionadded:: 0.9
-        self.url_build_error_handlers: list[
-            t.Callable[[Exception, str, dict[str, t.Any]], str]
-        ] = []
-
-        #: A list of functions that are called when the application context
-        #: is destroyed.  Since the application context is also torn down
-        #: if the request ends this is the place to store code that disconnects
-        #: from databases.
-        #:
-        #: .. versionadded:: 0.9
-        self.teardown_appcontext_funcs: list[ft.TeardownCallable] = []
-
-        #: A list of shell context processor functions that should be run
-        #: when a shell context is created.
-        #:
-        #: .. versionadded:: 0.11
-        self.shell_context_processors: list[ft.ShellContextProcessorCallable] = []
-
-        #: Maps registered blueprint names to blueprint objects. The
-        #: dict retains the order the blueprints were registered in.
-        #: Blueprints can be registered multiple times, this dict does
-        #: not track how often they were attached.
-        #:
-        #: .. versionadded:: 0.7
-        self.blueprints: dict[str, Blueprint] = {}
-
-        #: a place where extensions can store application specific state.  For
-        #: example this is where an extension could store database engines and
-        #: similar things.
-        #:
-        #: The key must match the name of the extension module. For example in
-        #: case of a "Flask-Foo" extension in `flask_foo`, the key would be
-        #: ``'foo'``.
-        #:
-        #: .. versionadded:: 0.7
-        self.extensions: dict = {}
-
-        #: The :class:`~werkzeug.routing.Map` for this instance.  You can use
-        #: this to change the routing converters after the class was created
-        #: but before any routes are connected.  Example::
-        #:
-        #:    from werkzeug.routing import BaseConverter
-        #:
-        #:    class ListConverter(BaseConverter):
-        #:        def to_python(self, value):
-        #:            return value.split(',')
-        #:        def to_url(self, values):
-        #:            return ','.join(super(ListConverter, self).to_url(value)
-        #:                            for value in values)
-        #:
-        #:    app = Flask(__name__)
-        #:    app.url_map.converters['list'] = ListConverter
-        self.url_map = self.url_map_class()
-
-        self.url_map.host_matching = host_matching
-        self.subdomain_matching = subdomain_matching
-
-        # tracks internally if the application already handled at least one
-        # request.
-        self._got_first_request = False
-
         # Add a static route using the provided static_url_path, static_host,
         # and static_folder if there is a configured static_folder.
         # Note we do this without checking if static_folder exists.
@@ -502,135 +260,81 @@ class Flask(Scaffold):
                 view_func=lambda **kw: self_ref().send_static_file(**kw),  # type: ignore # noqa: B950
             )
 
-        # Set the name of the Click group in case someone wants to add
-        # the app's commands to another CLI tool.
-        self.cli.name = self.name
-
-    def _check_setup_finished(self, f_name: str) -> None:
-        if self._got_first_request:
-            raise AssertionError(
-                f"The setup method '{f_name}' can no longer be called"
-                " on the application. It has already handled its first"
-                " request, any changes will not be applied"
-                " consistently.\n"
-                "Make sure all imports, decorators, functions, etc."
-                " needed to set up the application are done before"
-                " running it."
-            )
-
-    @cached_property
-    def name(self) -> str:  # type: ignore
-        """The name of the application.  This is usually the import name
-        with the difference that it's guessed from the run file if the
-        import name is main.  This name is used as a display name when
-        Flask needs the name of the application.  It can be set and overridden
-        to change the value.
+    def get_send_file_max_age(self, filename: str | None) -> int | None:
+        """Used by :func:`send_file` to determine the ``max_age`` cache
+        value for a given file path if it wasn't passed.
 
-        .. versionadded:: 0.8
-        """
-        if self.import_name == "__main__":
-            fn = getattr(sys.modules["__main__"], "__file__", None)
-            if fn is None:
-                return "__main__"
-            return os.path.splitext(os.path.basename(fn))[0]
-        return self.import_name
-
-    @cached_property
-    def logger(self) -> logging.Logger:
-        """A standard Python :class:`~logging.Logger` for the app, with
-        the same name as :attr:`name`.
+        By default, this returns :data:`SEND_FILE_MAX_AGE_DEFAULT` from
+        the configuration of :data:`~flask.current_app`. This defaults
+        to ``None``, which tells the browser to use conditional requests
+        instead of a timed cache, which is usually preferable.
 
-        In debug mode, the logger's :attr:`~logging.Logger.level` will
-        be set to :data:`~logging.DEBUG`.
+        Note this is a duplicate of the same method in the Flask
+        class.
 
-        If there are no handlers configured, a default handler will be
-        added. See :doc:`/logging` for more information.
+        .. versionchanged:: 2.0
+            The default configuration is ``None`` instead of 12 hours.
 
-        .. versionchanged:: 1.1.0
-            The logger takes the same name as :attr:`name` rather than
-            hard-coding ``"flask.app"``.
+        .. versionadded:: 0.9
+        """
+        value = current_app.config["SEND_FILE_MAX_AGE_DEFAULT"]
 
-        .. versionchanged:: 1.0.0
-            Behavior was simplified. The logger is always named
-            ``"flask.app"``. The level is only set during configuration,
-            it doesn't check ``app.debug`` each time. Only one format is
-            used, not different ones depending on ``app.debug``. No
-            handlers are removed, and a handler is only added if no
-            handlers are already configured.
+        if value is None:
+            return None
 
-        .. versionadded:: 0.3
-        """
-        return create_logger(self)
+        if isinstance(value, timedelta):
+            return int(value.total_seconds())
 
-    @cached_property
-    def jinja_env(self) -> Environment:
-        """The Jinja environment used to load templates.
+        return value  # type: ignore[no-any-return]
 
-        The environment is created the first time this property is
-        accessed. Changing :attr:`jinja_options` after that will have no
-        effect.
-        """
-        return self.create_jinja_environment()
+    def send_static_file(self, filename: str) -> Response:
+        """The view function used to serve files from
+        :attr:`static_folder`. A route is automatically registered for
+        this view at :attr:`static_url_path` if :attr:`static_folder` is
+        set.
 
-    @property
-    def got_first_request(self) -> bool:
-        """This attribute is set to ``True`` if the application started
-        handling the first request.
+        Note this is a duplicate of the same method in the Flask
+        class.
 
-        .. deprecated:: 2.3
-            Will be removed in Flask 2.4.
+        .. versionadded:: 0.5
 
-        .. versionadded:: 0.8
         """
-        import warnings
-
-        warnings.warn(
-            "'got_first_request' is deprecated and will be removed in Flask 2.4.",
-            DeprecationWarning,
-            stacklevel=2,
+        if not self.has_static_folder:
+            raise RuntimeError("'static_folder' must be set to serve static_files.")
+
+        # send_file only knows to call get_send_file_max_age on the app,
+        # call it here so it works for blueprints too.
+        max_age = self.get_send_file_max_age(filename)
+        return send_from_directory(
+            t.cast(str, self.static_folder), filename, max_age=max_age
         )
-        return self._got_first_request
 
-    def make_config(self, instance_relative: bool = False) -> Config:
-        """Used to create the config attribute by the Flask constructor.
-        The `instance_relative` parameter is passed in from the constructor
-        of Flask (there named `instance_relative_config`) and indicates if
-        the config should be relative to the instance path or the root path
-        of the application.
+    def open_resource(self, resource: str, mode: str = "rb") -> t.IO[t.AnyStr]:
+        """Open a resource file relative to :attr:`root_path` for
+        reading.
 
-        .. versionadded:: 0.8
-        """
-        root_path = self.root_path
-        if instance_relative:
-            root_path = self.instance_path
-        defaults = dict(self.default_config)
-        defaults["DEBUG"] = get_debug_flag()
-        return self.config_class(root_path, defaults)
+        For example, if the file ``schema.sql`` is next to the file
+        ``app.py`` where the ``Flask`` app is defined, it can be opened
+        with:
 
-    def make_aborter(self) -> Aborter:
-        """Create the object to assign to :attr:`aborter`. That object
-        is called by :func:`flask.abort` to raise HTTP errors, and can
-        be called directly as well.
+        .. code-block:: python
 
-        By default, this creates an instance of :attr:`aborter_class`,
-        which defaults to :class:`werkzeug.exceptions.Aborter`.
+            with app.open_resource("schema.sql") as f:
+                conn.executescript(f.read())
 
-        .. versionadded:: 2.2
-        """
-        return self.aborter_class()
+        :param resource: Path to the resource relative to
+            :attr:`root_path`.
+        :param mode: Open the file in this mode. Only reading is
+            supported, valid values are "r" (or "rt") and "rb".
 
-    def auto_find_instance_path(self) -> str:
-        """Tries to locate the instance path if it was not provided to the
-        constructor of the application class.  It will basically calculate
-        the path to a folder named ``instance`` next to your main file or
-        the package.
+        Note this is a duplicate of the same method in the Flask
+        class.
 
-        .. versionadded:: 0.8
         """
-        prefix, package_path = find_package(self.import_name)
-        if prefix is None:
-            return os.path.join(package_path, "instance")
-        return os.path.join(prefix, "var", f"{self.name}-instance")
+        if mode not in {"r", "rt", "rb"}:
+            raise ValueError("Resources can only be opened for reading.")
+
+        return open(os.path.join(self.root_path, resource), mode)
 
     def open_instance_resource(self, resource: str, mode: str = "rb") -> t.IO[t.AnyStr]:
         """Opens a resource from the application's instance folder
@@ -684,33 +388,75 @@ class Flask(Scaffold):
         rv.policies["json.dumps_function"] = self.json.dumps
         return rv
 
-    def create_global_jinja_loader(self) -> DispatchingJinjaLoader:
-        """Creates the loader for the Jinja2 environment.  Can be used to
-        override just the loader and keeping the rest unchanged.  It's
-        discouraged to override this function.  Instead one should override
-        the :meth:`jinja_loader` function instead.
+    def create_url_adapter(self, request: Request | None) -> MapAdapter | None:
+        """Creates a URL adapter for the given request. The URL adapter
+        is created at a point where the request context is not yet set
+        up so the request is passed explicitly.
 
-        The global loader dispatches between the loaders of the application
-        and the individual blueprints.
+        .. versionadded:: 0.6
 
-        .. versionadded:: 0.7
+        .. versionchanged:: 0.9
+           This can now also be called without a request object when the
+           URL adapter is created for the application context.
+
+        .. versionchanged:: 1.0
+            :data:`SERVER_NAME` no longer implicitly enables subdomain
+            matching. Use :attr:`subdomain_matching` instead.
         """
-        return DispatchingJinjaLoader(self)
+        if request is not None:
+            # If subdomain matching is disabled (the default), use the
+            # default subdomain in all cases. This should be the default
+            # in Werkzeug but it currently does not have that feature.
+            if not self.subdomain_matching:
+                subdomain = self.url_map.default_subdomain or None
+            else:
+                subdomain = None
 
-    def select_jinja_autoescape(self, filename: str) -> bool:
-        """Returns ``True`` if autoescaping should be active for the given
-        template name. If no template name is given, returns `True`.
+            return self.url_map.bind_to_environ(
+                request.environ,
+                server_name=self.config["SERVER_NAME"],
+                subdomain=subdomain,
+            )
+        # We need at the very least the server name to be set for this
+        # to work.
+        if self.config["SERVER_NAME"] is not None:
+            return self.url_map.bind(
+                self.config["SERVER_NAME"],
+                script_name=self.config["APPLICATION_ROOT"],
+                url_scheme=self.config["PREFERRED_URL_SCHEME"],
+            )
 
-        .. versionchanged:: 2.2
-            Autoescaping is now enabled by default for ``.svg`` files.
+        return None
 
-        .. versionadded:: 0.5
+    def raise_routing_exception(self, request: Request) -> t.NoReturn:
+        """Intercept routing exceptions and possibly do something else.
+
+        In debug mode, intercept a routing redirect and replace it with
+        an error if the body will be discarded.
+
+        With modern Werkzeug this shouldn't occur, since it now uses a
+        308 status which tells the browser to resend the method and
+        body.
+
+        .. versionchanged:: 2.1
+            Don't intercept 307 and 308 redirects.
+
+        :meta private:
+        :internal:
         """
-        if filename is None:
-            return True
-        return filename.endswith((".html", ".htm", ".xml", ".xhtml", ".svg"))
+        if (
+            not self.debug
+            or not isinstance(request.routing_exception, RequestRedirect)
+            or request.routing_exception.code in {307, 308}
+            or request.method in {"GET", "HEAD", "OPTIONS"}
+        ):
+            raise request.routing_exception  # type: ignore[misc]
+
+        from .debughelpers import FormDataRoutingRedirect
+
+        raise FormDataRoutingRedirect(request)
 
-    def update_template_context(self, context: dict) -> None:
+    def update_template_context(self, context: dict[str, t.Any]) -> None:
         """Update the template context with some commonly used variables.
         This injects request, session, config and g into the template
         context as well as everything template context processors want
@@ -734,11 +480,11 @@ class Flask(Scaffold):
         for name in names:
             if name in self.template_context_processors:
                 for func in self.template_context_processors[name]:
-                    context.update(func())
+                    context.update(self.ensure_sync(func)())
 
         context.update(orig_ctx)
 
-    def make_shell_context(self) -> dict:
+    def make_shell_context(self) -> dict[str, t.Any]:
         """Returns the shell context for an interactive shell for this
         application.  This runs all the registered shell context
         processors.
@@ -750,26 +496,6 @@ class Flask(Scaffold):
             rv.update(processor())
         return rv
 
-    @property
-    def debug(self) -> bool:
-        """Whether debug mode is enabled. When using ``flask run`` to start the
-        development server, an interactive debugger will be shown for unhandled
-        exceptions, and the server will be reloaded when code changes. This maps to the
-        :data:`DEBUG` config key. It may not behave as expected if set late.
-
-        **Do not enable debug mode when deploying in production.**
-
-        Default: ``False``
-        """
-        return self.config["DEBUG"]
-
-    @debug.setter
-    def debug(self, value: bool) -> None:
-        self.config["DEBUG"] = value
-
-        if self.config["TEMPLATES_AUTO_RELOAD"] is None:
-            self.jinja_env.auto_reload = value
-
     def run(
         self,
         host: str | None = None,
@@ -968,283 +694,6 @@ class Flask(Scaffold):
 
         return cls(self, **kwargs)  # type: ignore
 
-    @setupmethod
-    def register_blueprint(self, blueprint: Blueprint, **options: t.Any) -> None:
-        """Register a :class:`~flask.Blueprint` on the application. Keyword
-        arguments passed to this method will override the defaults set on the
-        blueprint.
-
-        Calls the blueprint's :meth:`~flask.Blueprint.register` method after
-        recording the blueprint in the application's :attr:`blueprints`.
-
-        :param blueprint: The blueprint to register.
-        :param url_prefix: Blueprint routes will be prefixed with this.
-        :param subdomain: Blueprint routes will match on this subdomain.
-        :param url_defaults: Blueprint routes will use these default values for
-            view arguments.
-        :param options: Additional keyword arguments are passed to
-            :class:`~flask.blueprints.BlueprintSetupState`. They can be
-            accessed in :meth:`~flask.Blueprint.record` callbacks.
-
-        .. versionchanged:: 2.0.1
-            The ``name`` option can be used to change the (pre-dotted)
-            name the blueprint is registered with. This allows the same
-            blueprint to be registered multiple times with unique names
-            for ``url_for``.
-
-        .. versionadded:: 0.7
-        """
-        blueprint.register(self, options)
-
-    def iter_blueprints(self) -> t.ValuesView[Blueprint]:
-        """Iterates over all blueprints by the order they were registered.
-
-        .. versionadded:: 0.11
-        """
-        return self.blueprints.values()
-
-    @setupmethod
-    def add_url_rule(
-        self,
-        rule: str,
-        endpoint: str | None = None,
-        view_func: ft.RouteCallable | None = None,
-        provide_automatic_options: bool | None = None,
-        **options: t.Any,
-    ) -> None:
-        if endpoint is None:
-            endpoint = _endpoint_from_view_func(view_func)  # type: ignore
-        options["endpoint"] = endpoint
-        methods = options.pop("methods", None)
-
-        # if the methods are not given and the view_func object knows its
-        # methods we can use that instead.  If neither exists, we go with
-        # a tuple of only ``GET`` as default.
-        if methods is None:
-            methods = getattr(view_func, "methods", None) or ("GET",)
-        if isinstance(methods, str):
-            raise TypeError(
-                "Allowed methods must be a list of strings, for"
-                ' example: @app.route(..., methods=["POST"])'
-            )
-        methods = {item.upper() for item in methods}
-
-        # Methods that should always be added
-        required_methods = set(getattr(view_func, "required_methods", ()))
-
-        # starting with Flask 0.8 the view_func object can disable and
-        # force-enable the automatic options handling.
-        if provide_automatic_options is None:
-            provide_automatic_options = getattr(
-                view_func, "provide_automatic_options", None
-            )
-
-        if provide_automatic_options is None:
-            if "OPTIONS" not in methods:
-                provide_automatic_options = True
-                required_methods.add("OPTIONS")
-            else:
-                provide_automatic_options = False
-
-        # Add the required methods now.
-        methods |= required_methods
-
-        rule = self.url_rule_class(rule, methods=methods, **options)
-        rule.provide_automatic_options = provide_automatic_options  # type: ignore
-
-        self.url_map.add(rule)
-        if view_func is not None:
-            old_func = self.view_functions.get(endpoint)
-            if old_func is not None and old_func != view_func:
-                raise AssertionError(
-                    "View function mapping is overwriting an existing"
-                    f" endpoint function: {endpoint}"
-                )
-            self.view_functions[endpoint] = view_func
-
-    @setupmethod
-    def template_filter(
-        self, name: str | None = None
-    ) -> t.Callable[[T_template_filter], T_template_filter]:
-        """A decorator that is used to register custom template filter.
-        You can specify a name for the filter, otherwise the function
-        name will be used. Example::
-
-          @app.template_filter()
-          def reverse(s):
-              return s[::-1]
-
-        :param name: the optional name of the filter, otherwise the
-                     function name will be used.
-        """
-
-        def decorator(f: T_template_filter) -> T_template_filter:
-            self.add_template_filter(f, name=name)
-            return f
-
-        return decorator
-
-    @setupmethod
-    def add_template_filter(
-        self, f: ft.TemplateFilterCallable, name: str | None = None
-    ) -> None:
-        """Register a custom template filter.  Works exactly like the
-        :meth:`template_filter` decorator.
-
-        :param name: the optional name of the filter, otherwise the
-                     function name will be used.
-        """
-        self.jinja_env.filters[name or f.__name__] = f
-
-    @setupmethod
-    def template_test(
-        self, name: str | None = None
-    ) -> t.Callable[[T_template_test], T_template_test]:
-        """A decorator that is used to register custom template test.
-        You can specify a name for the test, otherwise the function
-        name will be used. Example::
-
-          @app.template_test()
-          def is_prime(n):
-              if n == 2:
-                  return True
-              for i in range(2, int(math.ceil(math.sqrt(n))) + 1):
-                  if n % i == 0:
-                      return False
-              return True
-
-        .. versionadded:: 0.10
-
-        :param name: the optional name of the test, otherwise the
-                     function name will be used.
-        """
-
-        def decorator(f: T_template_test) -> T_template_test:
-            self.add_template_test(f, name=name)
-            return f
-
-        return decorator
-
-    @setupmethod
-    def add_template_test(
-        self, f: ft.TemplateTestCallable, name: str | None = None
-    ) -> None:
-        """Register a custom template test.  Works exactly like the
-        :meth:`template_test` decorator.
-
-        .. versionadded:: 0.10
-
-        :param name: the optional name of the test, otherwise the
-                     function name will be used.
-        """
-        self.jinja_env.tests[name or f.__name__] = f
-
-    @setupmethod
-    def template_global(
-        self, name: str | None = None
-    ) -> t.Callable[[T_template_global], T_template_global]:
-        """A decorator that is used to register a custom template global function.
-        You can specify a name for the global function, otherwise the function
-        name will be used. Example::
-
-            @app.template_global()
-            def double(n):
-                return 2 * n
-
-        .. versionadded:: 0.10
-
-        :param name: the optional name of the global function, otherwise the
-                     function name will be used.
-        """
-
-        def decorator(f: T_template_global) -> T_template_global:
-            self.add_template_global(f, name=name)
-            return f
-
-        return decorator
-
-    @setupmethod
-    def add_template_global(
-        self, f: ft.TemplateGlobalCallable, name: str | None = None
-    ) -> None:
-        """Register a custom template global function. Works exactly like the
-        :meth:`template_global` decorator.
-
-        .. versionadded:: 0.10
-
-        :param name: the optional name of the global function, otherwise the
-                     function name will be used.
-        """
-        self.jinja_env.globals[name or f.__name__] = f
-
-    @setupmethod
-    def teardown_appcontext(self, f: T_teardown) -> T_teardown:
-        """Registers a function to be called when the application
-        context is popped. The application context is typically popped
-        after the request context for each request, at the end of CLI
-        commands, or after a manually pushed context ends.
-
-        .. code-block:: python
-
-            with app.app_context():
-                ...
-
-        When the ``with`` block exits (or ``ctx.pop()`` is called), the
-        teardown functions are called just before the app context is
-        made inactive. Since a request context typically also manages an
-        application context it would also be called when you pop a
-        request context.
-
-        When a teardown function was called because of an unhandled
-        exception it will be passed an error object. If an
-        :meth:`errorhandler` is registered, it will handle the exception
-        and the teardown will not receive it.
-
-        Teardown functions must avoid raising exceptions. If they
-        execute code that might fail they must surround that code with a
-        ``try``/``except`` block and log any errors.
-
-        The return values of teardown functions are ignored.
-
-        .. versionadded:: 0.9
-        """
-        self.teardown_appcontext_funcs.append(f)
-        return f
-
-    @setupmethod
-    def shell_context_processor(
-        self, f: T_shell_context_processor
-    ) -> T_shell_context_processor:
-        """Registers a shell context processor function.
-
-        .. versionadded:: 0.11
-        """
-        self.shell_context_processors.append(f)
-        return f
-
-    def _find_error_handler(self, e: Exception) -> ft.ErrorHandlerCallable | None:
-        """Return a registered error handler for an exception in this order:
-        blueprint handler for a specific code, app handler for a specific code,
-        blueprint handler for an exception class, app handler for an exception
-        class, or ``None`` if a suitable handler is not found.
-        """
-        exc_class, code = self._get_exc_class_and_code(type(e))
-        names = (*request.blueprints, None)
-
-        for c in (code, None) if code is not None else (None,):
-            for name in names:
-                handler_map = self.error_handler_spec[name][c]
-
-                if not handler_map:
-                    continue
-
-                for cls in exc_class.__mro__:
-                    handler = handler_map.get(cls)
-
-                    if handler is not None:
-                        return handler
-        return None
-
     def handle_http_exception(
         self, e: HTTPException
     ) -> HTTPException | ft.ResponseReturnValue:
@@ -1275,45 +724,10 @@ class Flask(Scaffold):
         if isinstance(e, RoutingException):
             return e
 
-        handler = self._find_error_handler(e)
+        handler = self._find_error_handler(e, request.blueprints)
         if handler is None:
             return e
-        return self.ensure_sync(handler)(e)
-
-    def trap_http_exception(self, e: Exception) -> bool:
-        """Checks if an HTTP exception should be trapped or not.  By default
-        this will return ``False`` for all exceptions except for a bad request
-        key error if ``TRAP_BAD_REQUEST_ERRORS`` is set to ``True``.  It
-        also returns ``True`` if ``TRAP_HTTP_EXCEPTIONS`` is set to ``True``.
-
-        This is called for all HTTP exceptions raised by a view function.
-        If it returns ``True`` for any exception the error handler for this
-        exception is not called and it shows up as regular exception in the
-        traceback.  This is helpful for debugging implicitly raised HTTP
-        exceptions.
-
-        .. versionchanged:: 1.0
-            Bad request errors are not trapped by default in debug mode.
-
-        .. versionadded:: 0.8
-        """
-        if self.config["TRAP_HTTP_EXCEPTIONS"]:
-            return True
-
-        trap_bad_request = self.config["TRAP_BAD_REQUEST_ERRORS"]
-
-        # if unset, trap key errors in debug mode
-        if (
-            trap_bad_request is None
-            and self.debug
-            and isinstance(e, BadRequestKeyError)
-        ):
-            return True
-
-        if trap_bad_request:
-            return isinstance(e, BadRequest)
-
-        return False
+        return self.ensure_sync(handler)(e)  # type: ignore[no-any-return]
 
     def handle_user_exception(
         self, e: Exception
@@ -1340,12 +754,12 @@ class Flask(Scaffold):
         if isinstance(e, HTTPException) and not self.trap_http_exception(e):
             return self.handle_http_exception(e)
 
-        handler = self._find_error_handler(e)
+        handler = self._find_error_handler(e, request.blueprints)
 
         if handler is None:
             raise
 
-        return self.ensure_sync(handler)(e)
+        return self.ensure_sync(handler)(e)  # type: ignore[no-any-return]
 
     def handle_exception(self, e: Exception) -> Response:
         """Handle an exception that did not have an error handler
@@ -1393,7 +807,7 @@ class Flask(Scaffold):
         self.log_exception(exc_info)
         server_error: InternalServerError | ft.ResponseReturnValue
         server_error = InternalServerError(original_exception=e)
-        handler = self._find_error_handler(server_error)
+        handler = self._find_error_handler(server_error, request.blueprints)
 
         if handler is not None:
             server_error = self.ensure_sync(handler)(server_error)
@@ -1415,34 +829,6 @@ class Flask(Scaffold):
             f"Exception on {request.path} [{request.method}]", exc_info=exc_info
         )
 
-    def raise_routing_exception(self, request: Request) -> t.NoReturn:
-        """Intercept routing exceptions and possibly do something else.
-
-        In debug mode, intercept a routing redirect and replace it with
-        an error if the body will be discarded.
-
-        With modern Werkzeug this shouldn't occur, since it now uses a
-        308 status which tells the browser to resend the method and
-        body.
-
-        .. versionchanged:: 2.1
-            Don't intercept 307 and 308 redirects.
-
-        :meta private:
-        :internal:
-        """
-        if (
-            not self.debug
-            or not isinstance(request.routing_exception, RequestRedirect)
-            or request.routing_exception.code in {307, 308}
-            or request.method in {"GET", "HEAD", "OPTIONS"}
-        ):
-            raise request.routing_exception  # type: ignore
-
-        from .debughelpers import FormDataRoutingRedirect
-
-        raise FormDataRoutingRedirect(request)
-
     def dispatch_request(self) -> ft.ResponseReturnValue:
         """Does the request dispatching.  Matches the URL and returns the
         return value of the view or error handler.  This does not have to
@@ -1466,7 +852,7 @@ class Flask(Scaffold):
             return self.make_default_options_response()
         # otherwise dispatch to the handler for that endpoint
         view_args: dict[str, t.Any] = req.view_args  # type: ignore[assignment]
-        return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)
+        return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]
 
     def full_dispatch_request(self) -> Response:
         """Dispatches the request and on top of that performs request
@@ -1530,17 +916,7 @@ class Flask(Scaffold):
         rv.allow.update(methods)
         return rv
 
-    def should_ignore_error(self, error: BaseException | None) -> bool:
-        """This is called to figure out if an error should be ignored
-        or not as far as the teardown system is concerned.  If this
-        function returns ``True`` then the teardown handlers will not be
-        passed the error.
-
-        .. versionadded:: 0.10
-        """
-        return False
-
-    def ensure_sync(self, func: t.Callable) -> t.Callable:
+    def ensure_sync(self, func: t.Callable[..., t.Any]) -> t.Callable[..., t.Any]:
         """Ensure that the function is synchronous for WSGI workers.
         Plain ``def`` functions are returned as-is. ``async def``
         functions are wrapped to run and wait for the response.
@@ -1555,7 +931,7 @@ class Flask(Scaffold):
         return func
 
     def async_to_sync(
-        self, func: t.Callable[..., t.Coroutine]
+        self, func: t.Callable[..., t.Coroutine[t.Any, t.Any, t.Any]]
     ) -> t.Callable[..., t.Any]:
         """Return a sync function that will run the coroutine function.
 
@@ -1579,6 +955,7 @@ class Flask(Scaffold):
 
     def url_for(
         self,
+        /,
         endpoint: str,
         *,
         _anchor: str | None = None,
@@ -1702,20 +1079,6 @@ class Flask(Scaffold):
 
         return rv
 
-    def redirect(self, location: str, code: int = 302) -> BaseResponse:
-        """Create a redirect response object.
-
-        This is called by :func:`flask.redirect`, and can be called
-        directly as well.
-
-        :param location: The URL to redirect to.
-        :param code: The status code for the redirect.
-
-        .. versionadded:: 2.2
-            Moved from ``flask.redirect``, which calls this method.
-        """
-        return _wz_redirect(location, code=code, Response=self.response_class)
-
     def make_response(self, rv: ft.ResponseReturnValue) -> Response:
         """Convert the return value from a view function to an instance of
         :attr:`response_class`.
@@ -1806,7 +1169,7 @@ class Flask(Scaffold):
 
         # make sure the body is an instance of the response class
         if not isinstance(rv, self.response_class):
-            if isinstance(rv, (str, bytes, bytearray)) or isinstance(rv, _abc_Iterator):
+            if isinstance(rv, (str, bytes, bytearray)) or isinstance(rv, cabc.Iterator):
                 # let the response class set the status and headers instead of
                 # waiting to do it manually, so that the class can handle any
                 # special logic
@@ -1823,7 +1186,8 @@ class Flask(Scaffold):
                 # class to the correct type
                 try:
                     rv = self.response_class.force_type(
-                        rv, request.environ  # type: ignore[arg-type]
+                        rv,  # type: ignore[arg-type]
+                        request.environ,
                     )
                 except TypeError as e:
                     raise TypeError(
@@ -1856,101 +1220,6 @@ class Flask(Scaffold):
 
         return rv
 
-    def create_url_adapter(self, request: Request | None) -> MapAdapter | None:
-        """Creates a URL adapter for the given request. The URL adapter
-        is created at a point where the request context is not yet set
-        up so the request is passed explicitly.
-
-        .. versionadded:: 0.6
-
-        .. versionchanged:: 0.9
-           This can now also be called without a request object when the
-           URL adapter is created for the application context.
-
-        .. versionchanged:: 1.0
-            :data:`SERVER_NAME` no longer implicitly enables subdomain
-            matching. Use :attr:`subdomain_matching` instead.
-        """
-        if request is not None:
-            # If subdomain matching is disabled (the default), use the
-            # default subdomain in all cases. This should be the default
-            # in Werkzeug but it currently does not have that feature.
-            if not self.subdomain_matching:
-                subdomain = self.url_map.default_subdomain or None
-            else:
-                subdomain = None
-
-            return self.url_map.bind_to_environ(
-                request.environ,
-                server_name=self.config["SERVER_NAME"],
-                subdomain=subdomain,
-            )
-        # We need at the very least the server name to be set for this
-        # to work.
-        if self.config["SERVER_NAME"] is not None:
-            return self.url_map.bind(
-                self.config["SERVER_NAME"],
-                script_name=self.config["APPLICATION_ROOT"],
-                url_scheme=self.config["PREFERRED_URL_SCHEME"],
-            )
-
-        return None
-
-    def inject_url_defaults(self, endpoint: str, values: dict) -> None:
-        """Injects the URL defaults for the given endpoint directly into
-        the values dictionary passed.  This is used internally and
-        automatically called on URL building.
-
-        .. versionadded:: 0.7
-        """
-        names: t.Iterable[str | None] = (None,)
-
-        # url_for may be called outside a request context, parse the
-        # passed endpoint instead of using request.blueprints.
-        if "." in endpoint:
-            names = chain(
-                names, reversed(_split_blueprint_path(endpoint.rpartition(".")[0]))
-            )
-
-        for name in names:
-            if name in self.url_default_functions:
-                for func in self.url_default_functions[name]:
-                    func(endpoint, values)
-
-    def handle_url_build_error(
-        self, error: BuildError, endpoint: str, values: dict[str, t.Any]
-    ) -> str:
-        """Called by :meth:`.url_for` if a
-        :exc:`~werkzeug.routing.BuildError` was raised. If this returns
-        a value, it will be returned by ``url_for``, otherwise the error
-        will be re-raised.
-
-        Each function in :attr:`url_build_error_handlers` is called with
-        ``error``, ``endpoint`` and ``values``. If a function returns
-        ``None`` or raises a ``BuildError``, it is skipped. Otherwise,
-        its return value is returned by ``url_for``.
-
-        :param error: The active ``BuildError`` being handled.
-        :param endpoint: The endpoint being built.
-        :param values: The keyword arguments passed to ``url_for``.
-        """
-        for handler in self.url_build_error_handlers:
-            try:
-                rv = handler(error, endpoint, values)
-            except BuildError as e:
-                # make error available outside except block
-                error = e
-            else:
-                if rv is not None:
-                    return rv
-
-        # Re-raise if called with an active exception, otherwise raise
-        # the passed in exception.
-        if error is sys.exc_info()[1]:
-            raise
-
-        raise error
-
     def preprocess_request(self) -> ft.ResponseReturnValue | None:
         """Called before the request is dispatched. Calls
         :attr:`url_value_preprocessors` registered with the app and the
@@ -1974,7 +1243,7 @@ class Flask(Scaffold):
                     rv = self.ensure_sync(before_func)()
 
                     if rv is not None:
-                        return rv
+                        return rv  # type: ignore[no-any-return]
 
         return None
 
@@ -2007,7 +1276,8 @@ class Flask(Scaffold):
         return response
 
     def do_teardown_request(
-        self, exc: BaseException | None = _sentinel  # type: ignore
+        self,
+        exc: BaseException | None = _sentinel,  # type: ignore[assignment]
     ) -> None:
         """Called after the request is dispatched and the response is
         returned, right before the request context is popped.
@@ -2040,7 +1310,8 @@ class Flask(Scaffold):
         request_tearing_down.send(self, _async_wrapper=self.ensure_sync, exc=exc)
 
     def do_teardown_appcontext(
-        self, exc: BaseException | None = _sentinel  # type: ignore
+        self,
+        exc: BaseException | None = _sentinel,  # type: ignore[assignment]
     ) -> None:
         """Called right before the application context is popped.
 
@@ -2085,7 +1356,7 @@ class Flask(Scaffold):
         """
         return AppContext(self)
 
-    def request_context(self, environ: dict) -> RequestContext:
+    def request_context(self, environ: WSGIEnvironment) -> RequestContext:
         """Create a :class:`~flask.ctx.RequestContext` representing a
         WSGI environment. Use a ``with`` block to push the context,
         which will make :data:`request` point at this request.
@@ -2157,7 +1428,9 @@ class Flask(Scaffold):
         finally:
             builder.close()
 
-    def wsgi_app(self, environ: dict, start_response: t.Callable) -> t.Any:
+    def wsgi_app(
+        self, environ: WSGIEnvironment, start_response: StartResponse
+    ) -> cabc.Iterable[bytes]:
         """The actual WSGI application. This is not implemented in
         :meth:`__call__` so that middlewares can be applied without
         losing a reference to the app object. Instead of doing this::
@@ -2205,7 +1478,9 @@ class Flask(Scaffold):
 
             ctx.pop(error)
 
-    def __call__(self, environ: dict, start_response: t.Callable) -> t.Any:
+    def __call__(
+        self, environ: WSGIEnvironment, start_response: StartResponse
+    ) -> cabc.Iterable[bytes]:
         """The WSGI server calls the Flask application object as the
         WSGI application. This calls :meth:`wsgi_app`, which can be
         wrapped to apply middleware.
diff --git a/src/flask/blueprints.py b/src/flask/blueprints.py
index 0407f86f..52859b85 100644
--- a/src/flask/blueprints.py
+++ b/src/flask/blueprints.py
@@ -2,625 +2,90 @@ from __future__ import annotations
 
 import os
 import typing as t
-from collections import defaultdict
-from functools import update_wrapper
+from datetime import timedelta
 
-from . import typing as ft
-from .scaffold import _endpoint_from_view_func
-from .scaffold import _sentinel
-from .scaffold import Scaffold
-from .scaffold import setupmethod
+from .globals import current_app
+from .helpers import send_from_directory
+from .sansio.blueprints import Blueprint as SansioBlueprint
+from .sansio.blueprints import BlueprintSetupState as BlueprintSetupState  # noqa
 
 if t.TYPE_CHECKING:  # pragma: no cover
-    from .app import Flask
+    from .wrappers import Response
 
-DeferredSetupFunction = t.Callable[["BlueprintSetupState"], t.Callable]
-T_after_request = t.TypeVar("T_after_request", bound=ft.AfterRequestCallable)
-T_before_request = t.TypeVar("T_before_request", bound=ft.BeforeRequestCallable)
-T_error_handler = t.TypeVar("T_error_handler", bound=ft.ErrorHandlerCallable)
-T_teardown = t.TypeVar("T_teardown", bound=ft.TeardownCallable)
-T_template_context_processor = t.TypeVar(
-    "T_template_context_processor", bound=ft.TemplateContextProcessorCallable
-)
-T_template_filter = t.TypeVar("T_template_filter", bound=ft.TemplateFilterCallable)
-T_template_global = t.TypeVar("T_template_global", bound=ft.TemplateGlobalCallable)
-T_template_test = t.TypeVar("T_template_test", bound=ft.TemplateTestCallable)
-T_url_defaults = t.TypeVar("T_url_defaults", bound=ft.URLDefaultCallable)
-T_url_value_preprocessor = t.TypeVar(
-    "T_url_value_preprocessor", bound=ft.URLValuePreprocessorCallable
-)
 
+class Blueprint(SansioBlueprint):
+    def get_send_file_max_age(self, filename: str | None) -> int | None:
+        """Used by :func:`send_file` to determine the ``max_age`` cache
+        value for a given file path if it wasn't passed.
 
-class BlueprintSetupState:
-    """Temporary holder object for registering a blueprint with the
-    application.  An instance of this class is created by the
-    :meth:`~flask.Blueprint.make_setup_state` method and later passed
-    to all register callback functions.
-    """
+        By default, this returns :data:`SEND_FILE_MAX_AGE_DEFAULT` from
+        the configuration of :data:`~flask.current_app`. This defaults
+        to ``None``, which tells the browser to use conditional requests
+        instead of a timed cache, which is usually preferable.
 
-    def __init__(
-        self,
-        blueprint: Blueprint,
-        app: Flask,
-        options: t.Any,
-        first_registration: bool,
-    ) -> None:
-        #: a reference to the current application
-        self.app = app
+        Note this is a duplicate of the same method in the Flask
+        class.
 
-        #: a reference to the blueprint that created this setup state.
-        self.blueprint = blueprint
+        .. versionchanged:: 2.0
+            The default configuration is ``None`` instead of 12 hours.
 
-        #: a dictionary with all options that were passed to the
-        #: :meth:`~flask.Flask.register_blueprint` method.
-        self.options = options
-
-        #: as blueprints can be registered multiple times with the
-        #: application and not everything wants to be registered
-        #: multiple times on it, this attribute can be used to figure
-        #: out if the blueprint was registered in the past already.
-        self.first_registration = first_registration
-
-        subdomain = self.options.get("subdomain")
-        if subdomain is None:
-            subdomain = self.blueprint.subdomain
-
-        #: The subdomain that the blueprint should be active for, ``None``
-        #: otherwise.
-        self.subdomain = subdomain
-
-        url_prefix = self.options.get("url_prefix")
-        if url_prefix is None:
-            url_prefix = self.blueprint.url_prefix
-        #: The prefix that should be used for all URLs defined on the
-        #: blueprint.
-        self.url_prefix = url_prefix
-
-        self.name = self.options.get("name", blueprint.name)
-        self.name_prefix = self.options.get("name_prefix", "")
-
-        #: A dictionary with URL defaults that is added to each and every
-        #: URL that was defined with the blueprint.
-        self.url_defaults = dict(self.blueprint.url_values_defaults)
-        self.url_defaults.update(self.options.get("url_defaults", ()))
-
-    def add_url_rule(
-        self,
-        rule: str,
-        endpoint: str | None = None,
-        view_func: t.Callable | None = None,
-        **options: t.Any,
-    ) -> None:
-        """A helper method to register a rule (and optionally a view function)
-        to the application.  The endpoint is automatically prefixed with the
-        blueprint's name.
-        """
-        if self.url_prefix is not None:
-            if rule:
-                rule = "/".join((self.url_prefix.rstrip("/"), rule.lstrip("/")))
-            else:
-                rule = self.url_prefix
-        options.setdefault("subdomain", self.subdomain)
-        if endpoint is None:
-            endpoint = _endpoint_from_view_func(view_func)  # type: ignore
-        defaults = self.url_defaults
-        if "defaults" in options:
-            defaults = dict(defaults, **options.pop("defaults"))
-
-        self.app.add_url_rule(
-            rule,
-            f"{self.name_prefix}.{self.name}.{endpoint}".lstrip("."),
-            view_func,
-            defaults=defaults,
-            **options,
-        )
-
-
-class Blueprint(Scaffold):
-    """Represents a blueprint, a collection of routes and other
-    app-related functions that can be registered on a real application
-    later.
-
-    A blueprint is an object that allows defining application functions
-    without requiring an application object ahead of time. It uses the
-    same decorators as :class:`~flask.Flask`, but defers the need for an
-    application by recording them for later registration.
-
-    Decorating a function with a blueprint creates a deferred function
-    that is called with :class:`~flask.blueprints.BlueprintSetupState`
-    when the blueprint is registered on an application.
-
-    See :doc:`/blueprints` for more information.
-
-    :param name: The name of the blueprint. Will be prepended to each
-        endpoint name.
-    :param import_name: The name of the blueprint package, usually
-        ``__name__``. This helps locate the ``root_path`` for the
-        blueprint.
-    :param static_folder: A folder with static files that should be
-        served by the blueprint's static route. The path is relative to
-        the blueprint's root path. Blueprint static files are disabled
-        by default.
-    :param static_url_path: The url to serve static files from.
-        Defaults to ``static_folder``. If the blueprint does not have
-        a ``url_prefix``, the app's static route will take precedence,
-        and the blueprint's static files won't be accessible.
-    :param template_folder: A folder with templates that should be added
-        to the app's template search path. The path is relative to the
-        blueprint's root path. Blueprint templates are disabled by
-        default. Blueprint templates have a lower precedence than those
-        in the app's templates folder.
-    :param url_prefix: A path to prepend to all of the blueprint's URLs,
-        to make them distinct from the rest of the app's routes.
-    :param subdomain: A subdomain that blueprint routes will match on by
-        default.
-    :param url_defaults: A dict of default values that blueprint routes
-        will receive by default.
-    :param root_path: By default, the blueprint will automatically set
-        this based on ``import_name``. In certain situations this
-        automatic detection can fail, so the path can be specified
-        manually instead.
-
-    .. versionchanged:: 1.1.0
-        Blueprints have a ``cli`` group to register nested CLI commands.
-        The ``cli_group`` parameter controls the name of the group under
-        the ``flask`` command.
-
-    .. versionadded:: 0.7
-    """
-
-    _got_registered_once = False
-
-    def __init__(
-        self,
-        name: str,
-        import_name: str,
-        static_folder: str | os.PathLike | None = None,
-        static_url_path: str | None = None,
-        template_folder: str | os.PathLike | None = None,
-        url_prefix: str | None = None,
-        subdomain: str | None = None,
-        url_defaults: dict | None = None,
-        root_path: str | None = None,
-        cli_group: str | None = _sentinel,  # type: ignore
-    ):
-        super().__init__(
-            import_name=import_name,
-            static_folder=static_folder,
-            static_url_path=static_url_path,
-            template_folder=template_folder,
-            root_path=root_path,
-        )
-
-        if not name:
-            raise ValueError("'name' may not be empty.")
-
-        if "." in name:
-            raise ValueError("'name' may not contain a dot '.' character.")
-
-        self.name = name
-        self.url_prefix = url_prefix
-        self.subdomain = subdomain
-        self.deferred_functions: list[DeferredSetupFunction] = []
-
-        if url_defaults is None:
-            url_defaults = {}
-
-        self.url_values_defaults = url_defaults
-        self.cli_group = cli_group
-        self._blueprints: list[tuple[Blueprint, dict]] = []
-
-    def _check_setup_finished(self, f_name: str) -> None:
-        if self._got_registered_once:
-            raise AssertionError(
-                f"The setup method '{f_name}' can no longer be called on the blueprint"
-                f" '{self.name}'. It has already been registered at least once, any"
-                " changes will not be applied consistently.\n"
-                "Make sure all imports, decorators, functions, etc. needed to set up"
-                " the blueprint are done before registering it."
-            )
-
-    @setupmethod
-    def record(self, func: t.Callable) -> None:
-        """Registers a function that is called when the blueprint is
-        registered on the application.  This function is called with the
-        state as argument as returned by the :meth:`make_setup_state`
-        method.
-        """
-        self.deferred_functions.append(func)
-
-    @setupmethod
-    def record_once(self, func: t.Callable) -> None:
-        """Works like :meth:`record` but wraps the function in another
-        function that will ensure the function is only called once.  If the
-        blueprint is registered a second time on the application, the
-        function passed is not called.
-        """
-
-        def wrapper(state: BlueprintSetupState) -> None:
-            if state.first_registration:
-                func(state)
-
-        self.record(update_wrapper(wrapper, func))
-
-    def make_setup_state(
-        self, app: Flask, options: dict, first_registration: bool = False
-    ) -> BlueprintSetupState:
-        """Creates an instance of :meth:`~flask.blueprints.BlueprintSetupState`
-        object that is later passed to the register callback functions.
-        Subclasses can override this to return a subclass of the setup state.
+        .. versionadded:: 0.9
         """
-        return BlueprintSetupState(self, app, options, first_registration)
+        value = current_app.config["SEND_FILE_MAX_AGE_DEFAULT"]
 
-    @setupmethod
-    def register_blueprint(self, blueprint: Blueprint, **options: t.Any) -> None:
-        """Register a :class:`~flask.Blueprint` on this blueprint. Keyword
-        arguments passed to this method will override the defaults set
-        on the blueprint.
+        if value is None:
+            return None
 
-        .. versionchanged:: 2.0.1
-            The ``name`` option can be used to change the (pre-dotted)
-            name the blueprint is registered with. This allows the same
-            blueprint to be registered multiple times with unique names
-            for ``url_for``.
+        if isinstance(value, timedelta):
+            return int(value.total_seconds())
 
-        .. versionadded:: 2.0
-        """
-        if blueprint is self:
-            raise ValueError("Cannot register a blueprint on itself")
-        self._blueprints.append((blueprint, options))
-
-    def register(self, app: Flask, options: dict) -> None:
-        """Called by :meth:`Flask.register_blueprint` to register all
-        views and callbacks registered on the blueprint with the
-        application. Creates a :class:`.BlueprintSetupState` and calls
-        each :meth:`record` callback with it.
+        return value  # type: ignore[no-any-return]
 
-        :param app: The application this blueprint is being registered
-            with.
-        :param options: Keyword arguments forwarded from
-            :meth:`~Flask.register_blueprint`.
+    def send_static_file(self, filename: str) -> Response:
+        """The view function used to serve files from
+        :attr:`static_folder`. A route is automatically registered for
+        this view at :attr:`static_url_path` if :attr:`static_folder` is
+        set.
 
-        .. versionchanged:: 2.3
-            Nested blueprints now correctly apply subdomains.
+        Note this is a duplicate of the same method in the Flask
+        class.
 
-        .. versionchanged:: 2.1
-            Registering the same blueprint with the same name multiple
-            times is an error.
+        .. versionadded:: 0.5
 
-        .. versionchanged:: 2.0.1
-            Nested blueprints are registered with their dotted name.
-            This allows different blueprints with the same name to be
-            nested at different locations.
-
-        .. versionchanged:: 2.0.1
-            The ``name`` option can be used to change the (pre-dotted)
-            name the blueprint is registered with. This allows the same
-            blueprint to be registered multiple times with unique names
-            for ``url_for``.
         """
-        name_prefix = options.get("name_prefix", "")
-        self_name = options.get("name", self.name)
-        name = f"{name_prefix}.{self_name}".lstrip(".")
-
-        if name in app.blueprints:
-            bp_desc = "this" if app.blueprints[name] is self else "a different"
-            existing_at = f" '{name}'" if self_name != name else ""
-
-            raise ValueError(
-                f"The name '{self_name}' is already registered for"
-                f" {bp_desc} blueprint{existing_at}. Use 'name=' to"
-                f" provide a unique name."
-            )
-
-        first_bp_registration = not any(bp is self for bp in app.blueprints.values())
-        first_name_registration = name not in app.blueprints
-
-        app.blueprints[name] = self
-        self._got_registered_once = True
-        state = self.make_setup_state(app, options, first_bp_registration)
-
-        if self.has_static_folder:
-            state.add_url_rule(
-                f"{self.static_url_path}/<path:filename>",
-                view_func=self.send_static_file,
-                endpoint="static",
-            )
-
-        # Merge blueprint data into parent.
-        if first_bp_registration or first_name_registration:
-
-            def extend(bp_dict, parent_dict):
-                for key, values in bp_dict.items():
-                    key = name if key is None else f"{name}.{key}"
-                    parent_dict[key].extend(values)
-
-            for key, value in self.error_handler_spec.items():
-                key = name if key is None else f"{name}.{key}"
-                value = defaultdict(
-                    dict,
-                    {
-                        code: {
-                            exc_class: func for exc_class, func in code_values.items()
-                        }
-                        for code, code_values in value.items()
-                    },
-                )
-                app.error_handler_spec[key] = value
-
-            for endpoint, func in self.view_functions.items():
-                app.view_functions[endpoint] = func
-
-            extend(self.before_request_funcs, app.before_request_funcs)
-            extend(self.after_request_funcs, app.after_request_funcs)
-            extend(
-                self.teardown_request_funcs,
-                app.teardown_request_funcs,
-            )
-            extend(self.url_default_functions, app.url_default_functions)
-            extend(self.url_value_preprocessors, app.url_value_preprocessors)
-            extend(self.template_context_processors, app.template_context_processors)
-
-        for deferred in self.deferred_functions:
-            deferred(state)
-
-        cli_resolved_group = options.get("cli_group", self.cli_group)
-
-        if self.cli.commands:
-            if cli_resolved_group is None:
-                app.cli.commands.update(self.cli.commands)
-            elif cli_resolved_group is _sentinel:
-                self.cli.name = name
-                app.cli.add_command(self.cli)
-            else:
-                self.cli.name = cli_resolved_group
-                app.cli.add_command(self.cli)
-
-        for blueprint, bp_options in self._blueprints:
-            bp_options = bp_options.copy()
-            bp_url_prefix = bp_options.get("url_prefix")
-            bp_subdomain = bp_options.get("subdomain")
-
-            if bp_subdomain is None:
-                bp_subdomain = blueprint.subdomain
-
-            if state.subdomain is not None and bp_subdomain is not None:
-                bp_options["subdomain"] = bp_subdomain + "." + state.subdomain
-            elif bp_subdomain is not None:
-                bp_options["subdomain"] = bp_subdomain
-            elif state.subdomain is not None:
-                bp_options["subdomain"] = state.subdomain
-
-            if bp_url_prefix is None:
-                bp_url_prefix = blueprint.url_prefix
+        if not self.has_static_folder:
+            raise RuntimeError("'static_folder' must be set to serve static_files.")
 
-            if state.url_prefix is not None and bp_url_prefix is not None:
-                bp_options["url_prefix"] = (
-                    state.url_prefix.rstrip("/") + "/" + bp_url_prefix.lstrip("/")
-                )
-            elif bp_url_prefix is not None:
-                bp_options["url_prefix"] = bp_url_prefix
-            elif state.url_prefix is not None:
-                bp_options["url_prefix"] = state.url_prefix
-
-            bp_options["name_prefix"] = name
-            blueprint.register(app, bp_options)
-
-    @setupmethod
-    def add_url_rule(
-        self,
-        rule: str,
-        endpoint: str | None = None,
-        view_func: ft.RouteCallable | None = None,
-        provide_automatic_options: bool | None = None,
-        **options: t.Any,
-    ) -> None:
-        """Register a URL rule with the blueprint. See :meth:`.Flask.add_url_rule` for
-        full documentation.
-
-        The URL rule is prefixed with the blueprint's URL prefix. The endpoint name,
-        used with :func:`url_for`, is prefixed with the blueprint's name.
-        """
-        if endpoint and "." in endpoint:
-            raise ValueError("'endpoint' may not contain a dot '.' character.")
-
-        if view_func and hasattr(view_func, "__name__") and "." in view_func.__name__:
-            raise ValueError("'view_func' name may not contain a dot '.' character.")
-
-        self.record(
-            lambda s: s.add_url_rule(
-                rule,
-                endpoint,
-                view_func,
-                provide_automatic_options=provide_automatic_options,
-                **options,
-            )
+        # send_file only knows to call get_send_file_max_age on the app,
+        # call it here so it works for blueprints too.
+        max_age = self.get_send_file_max_age(filename)
+        return send_from_directory(
+            t.cast(str, self.static_folder), filename, max_age=max_age
         )
 
-    @setupmethod
-    def app_template_filter(
-        self, name: str | None = None
-    ) -> t.Callable[[T_template_filter], T_template_filter]:
-        """Register a template filter, available in any template rendered by the
-        application. Equivalent to :meth:`.Flask.template_filter`.
-
-        :param name: the optional name of the filter, otherwise the
-                     function name will be used.
-        """
-
-        def decorator(f: T_template_filter) -> T_template_filter:
-            self.add_app_template_filter(f, name=name)
-            return f
+    def open_resource(self, resource: str, mode: str = "rb") -> t.IO[t.AnyStr]:
+        """Open a resource file relative to :attr:`root_path` for
+        reading.
 
-        return decorator
+        For example, if the file ``schema.sql`` is next to the file
+        ``app.py`` where the ``Flask`` app is defined, it can be opened
+        with:
 
-    @setupmethod
-    def add_app_template_filter(
-        self, f: ft.TemplateFilterCallable, name: str | None = None
-    ) -> None:
-        """Register a template filter, available in any template rendered by the
-        application. Works like the :meth:`app_template_filter` decorator. Equivalent to
-        :meth:`.Flask.add_template_filter`.
-
-        :param name: the optional name of the filter, otherwise the
-                     function name will be used.
-        """
+        .. code-block:: python
 
-        def register_template(state: BlueprintSetupState) -> None:
-            state.app.jinja_env.filters[name or f.__name__] = f
+            with app.open_resource("schema.sql") as f:
+                conn.executescript(f.read())
 
-        self.record_once(register_template)
+        :param resource: Path to the resource relative to
+            :attr:`root_path`.
+        :param mode: Open the file in this mode. Only reading is
+            supported, valid values are "r" (or "rt") and "rb".
 
-    @setupmethod
-    def app_template_test(
-        self, name: str | None = None
-    ) -> t.Callable[[T_template_test], T_template_test]:
-        """Register a template test, available in any template rendered by the
-        application. Equivalent to :meth:`.Flask.template_test`.
+        Note this is a duplicate of the same method in the Flask
+        class.
 
-        .. versionadded:: 0.10
-
-        :param name: the optional name of the test, otherwise the
-                     function name will be used.
         """
+        if mode not in {"r", "rt", "rb"}:
+            raise ValueError("Resources can only be opened for reading.")
 
-        def decorator(f: T_template_test) -> T_template_test:
-            self.add_app_template_test(f, name=name)
-            return f
-
-        return decorator
-
-    @setupmethod
-    def add_app_template_test(
-        self, f: ft.TemplateTestCallable, name: str | None = None
-    ) -> None:
-        """Register a template test, available in any template rendered by the
-        application. Works like the :meth:`app_template_test` decorator. Equivalent to
-        :meth:`.Flask.add_template_test`.
-
-        .. versionadded:: 0.10
-
-        :param name: the optional name of the test, otherwise the
-                     function name will be used.
-        """
-
-        def register_template(state: BlueprintSetupState) -> None:
-            state.app.jinja_env.tests[name or f.__name__] = f
-
-        self.record_once(register_template)
-
-    @setupmethod
-    def app_template_global(
-        self, name: str | None = None
-    ) -> t.Callable[[T_template_global], T_template_global]:
-        """Register a template global, available in any template rendered by the
-        application. Equivalent to :meth:`.Flask.template_global`.
-
-        .. versionadded:: 0.10
-
-        :param name: the optional name of the global, otherwise the
-                     function name will be used.
-        """
-
-        def decorator(f: T_template_global) -> T_template_global:
-            self.add_app_template_global(f, name=name)
-            return f
-
-        return decorator
-
-    @setupmethod
-    def add_app_template_global(
-        self, f: ft.TemplateGlobalCallable, name: str | None = None
-    ) -> None:
-        """Register a template global, available in any template rendered by the
-        application. Works like the :meth:`app_template_global` decorator. Equivalent to
-        :meth:`.Flask.add_template_global`.
-
-        .. versionadded:: 0.10
-
-        :param name: the optional name of the global, otherwise the
-                     function name will be used.
-        """
-
-        def register_template(state: BlueprintSetupState) -> None:
-            state.app.jinja_env.globals[name or f.__name__] = f
-
-        self.record_once(register_template)
-
-    @setupmethod
-    def before_app_request(self, f: T_before_request) -> T_before_request:
-        """Like :meth:`before_request`, but before every request, not only those handled
-        by the blueprint. Equivalent to :meth:`.Flask.before_request`.
-        """
-        self.record_once(
-            lambda s: s.app.before_request_funcs.setdefault(None, []).append(f)
-        )
-        return f
-
-    @setupmethod
-    def after_app_request(self, f: T_after_request) -> T_after_request:
-        """Like :meth:`after_request`, but after every request, not only those handled
-        by the blueprint. Equivalent to :meth:`.Flask.after_request`.
-        """
-        self.record_once(
-            lambda s: s.app.after_request_funcs.setdefault(None, []).append(f)
-        )
-        return f
-
-    @setupmethod
-    def teardown_app_request(self, f: T_teardown) -> T_teardown:
-        """Like :meth:`teardown_request`, but after every request, not only those
-        handled by the blueprint. Equivalent to :meth:`.Flask.teardown_request`.
-        """
-        self.record_once(
-            lambda s: s.app.teardown_request_funcs.setdefault(None, []).append(f)
-        )
-        return f
-
-    @setupmethod
-    def app_context_processor(
-        self, f: T_template_context_processor
-    ) -> T_template_context_processor:
-        """Like :meth:`context_processor`, but for templates rendered by every view, not
-        only by the blueprint. Equivalent to :meth:`.Flask.context_processor`.
-        """
-        self.record_once(
-            lambda s: s.app.template_context_processors.setdefault(None, []).append(f)
-        )
-        return f
-
-    @setupmethod
-    def app_errorhandler(
-        self, code: type[Exception] | int
-    ) -> t.Callable[[T_error_handler], T_error_handler]:
-        """Like :meth:`errorhandler`, but for every request, not only those handled by
-        the blueprint. Equivalent to :meth:`.Flask.errorhandler`.
-        """
-
-        def decorator(f: T_error_handler) -> T_error_handler:
-            self.record_once(lambda s: s.app.errorhandler(code)(f))
-            return f
-
-        return decorator
-
-    @setupmethod
-    def app_url_value_preprocessor(
-        self, f: T_url_value_preprocessor
-    ) -> T_url_value_preprocessor:
-        """Like :meth:`url_value_preprocessor`, but for every request, not only those
-        handled by the blueprint. Equivalent to :meth:`.Flask.url_value_preprocessor`.
-        """
-        self.record_once(
-            lambda s: s.app.url_value_preprocessors.setdefault(None, []).append(f)
-        )
-        return f
-
-    @setupmethod
-    def app_url_defaults(self, f: T_url_defaults) -> T_url_defaults:
-        """Like :meth:`url_defaults`, but for every request, not only those handled by
-        the blueprint. Equivalent to :meth:`.Flask.url_defaults`.
-        """
-        self.record_once(
-            lambda s: s.app.url_default_functions.setdefault(None, []).append(f)
-        )
-        return f
+        return open(os.path.join(self.root_path, resource), mode)
diff --git a/src/flask/cli.py b/src/flask/cli.py
index f7e1f293..d4df2802 100644
--- a/src/flask/cli.py
+++ b/src/flask/cli.py
@@ -1,6 +1,8 @@
 from __future__ import annotations
 
 import ast
+import collections.abc as cabc
+import importlib.metadata
 import inspect
 import os
 import platform
@@ -10,6 +12,7 @@ import traceback
 import typing as t
 from functools import update_wrapper
 from operator import itemgetter
+from types import ModuleType
 
 import click
 from click.core import ParameterSource
@@ -22,6 +25,12 @@ from .helpers import get_debug_flag
 from .helpers import get_load_dotenv
 
 if t.TYPE_CHECKING:
+    import ssl
+
+    from _typeshed.wsgi import StartResponse
+    from _typeshed.wsgi import WSGIApplication
+    from _typeshed.wsgi import WSGIEnvironment
+
     from .app import Flask
 
 
@@ -29,7 +38,7 @@ class NoAppException(click.UsageError):
     """Raised if an application cannot be found or loaded."""
 
 
-def find_best_app(module):
+def find_best_app(module: ModuleType) -> Flask:
     """Given a module instance this tries to find the best possible
     application in the module or raises an exception.
     """
@@ -82,7 +91,7 @@ def find_best_app(module):
     )
 
 
-def _called_with_wrong_args(f):
+def _called_with_wrong_args(f: t.Callable[..., Flask]) -> bool:
     """Check whether calling a function raised a ``TypeError`` because
     the call failed or because something in the factory raised the
     error.
@@ -108,7 +117,7 @@ def _called_with_wrong_args(f):
         del tb
 
 
-def find_app_by_string(module, app_name):
+def find_app_by_string(module: ModuleType, app_name: str) -> Flask:
     """Check if the given string is a variable name or a function. Call
     a function to get the app instance, or return the variable directly.
     """
@@ -139,7 +148,11 @@ def find_app_by_string(module, app_name):
         # Parse the positional and keyword arguments as literals.
         try:
             args = [ast.literal_eval(arg) for arg in expr.args]
-            kwargs = {kw.arg: ast.literal_eval(kw.value) for kw in expr.keywords}
+            kwargs = {
+                kw.arg: ast.literal_eval(kw.value)
+                for kw in expr.keywords
+                if kw.arg is not None
+            }
         except ValueError:
             # literal_eval gives cryptic error messages, show a generic
             # message with the full expression instead.
@@ -184,7 +197,7 @@ def find_app_by_string(module, app_name):
     )
 
 
-def prepare_import(path):
+def prepare_import(path: str) -> str:
     """Given a filename this will try to calculate the python path, add it
     to the search path and return the actual module name that is expected.
     """
@@ -213,13 +226,29 @@ def prepare_import(path):
     return ".".join(module_name[::-1])
 
 
-def locate_app(module_name, app_name, raise_if_not_found=True):
+@t.overload
+def locate_app(
+    module_name: str, app_name: str | None, raise_if_not_found: t.Literal[True] = True
+) -> Flask:
+    ...
+
+
+@t.overload
+def locate_app(
+    module_name: str, app_name: str | None, raise_if_not_found: t.Literal[False] = ...
+) -> Flask | None:
+    ...
+
+
+def locate_app(
+    module_name: str, app_name: str | None, raise_if_not_found: bool = True
+) -> Flask | None:
     try:
         __import__(module_name)
     except ImportError:
         # Reraise the ImportError if it occurred within the imported module.
         # Determine this by checking whether the trace has a depth > 1.
-        if sys.exc_info()[2].tb_next:
+        if sys.exc_info()[2].tb_next:  # type: ignore[union-attr]
             raise NoAppException(
                 f"While importing {module_name!r}, an ImportError was"
                 f" raised:\n\n{traceback.format_exc()}"
@@ -227,7 +256,7 @@ def locate_app(module_name, app_name, raise_if_not_found=True):
         elif raise_if_not_found:
             raise NoAppException(f"Could not import {module_name!r}.") from None
         else:
-            return
+            return None
 
     module = sys.modules[module_name]
 
@@ -237,17 +266,17 @@ def locate_app(module_name, app_name, raise_if_not_found=True):
         return find_app_by_string(module, app_name)
 
 
-def get_version(ctx, param, value):
+def get_version(ctx: click.Context, param: click.Parameter, value: t.Any) -> None:
     if not value or ctx.resilient_parsing:
         return
 
-    import werkzeug
-    from . import __version__
+    flask_version = importlib.metadata.version("flask")
+    werkzeug_version = importlib.metadata.version("werkzeug")
 
     click.echo(
         f"Python {platform.python_version()}\n"
-        f"Flask {__version__}\n"
-        f"Werkzeug {werkzeug.__version__}",
+        f"Flask {flask_version}\n"
+        f"Werkzeug {werkzeug_version}",
         color=ctx.color,
     )
     ctx.exit()
@@ -298,11 +327,11 @@ class ScriptInfo:
             return self._loaded_app
 
         if self.create_app is not None:
-            app = self.create_app()
+            app: Flask | None = self.create_app()
         else:
             if self.app_import_path:
                 path, name = (
-                    re.split(r":(?![\\/])", self.app_import_path, 1) + [None]
+                    re.split(r":(?![\\/])", self.app_import_path, maxsplit=1) + [None]
                 )[:2]
                 import_name = prepare_import(path)
                 app = locate_app(import_name, name)
@@ -311,10 +340,10 @@ class ScriptInfo:
                     import_name = prepare_import(path)
                     app = locate_app(import_name, None, raise_if_not_found=False)
 
-                    if app:
+                    if app is not None:
                         break
 
-        if not app:
+        if app is None:
             raise NoAppException(
                 "Could not locate a Flask application. Use the"
                 " 'flask --app' option, 'FLASK_APP' environment"
@@ -333,8 +362,10 @@ class ScriptInfo:
 
 pass_script_info = click.make_pass_decorator(ScriptInfo, ensure=True)
 
+F = t.TypeVar("F", bound=t.Callable[..., t.Any])
+
 
-def with_appcontext(f):
+def with_appcontext(f: F) -> F:
     """Wraps a callback so that it's guaranteed to be executed with the
     script's application context.
 
@@ -349,14 +380,14 @@ def with_appcontext(f):
     """
 
     @click.pass_context
-    def decorator(__ctx, *args, **kwargs):
+    def decorator(ctx: click.Context, /, *args: t.Any, **kwargs: t.Any) -> t.Any:
         if not current_app:
-            app = __ctx.ensure_object(ScriptInfo).load_app()
-            __ctx.with_resource(app.app_context())
+            app = ctx.ensure_object(ScriptInfo).load_app()
+            ctx.with_resource(app.app_context())
 
-        return __ctx.invoke(f, *args, **kwargs)
+        return ctx.invoke(f, *args, **kwargs)
 
-    return update_wrapper(decorator, f)
+    return update_wrapper(decorator, f)  # type: ignore[return-value]
 
 
 class AppGroup(click.Group):
@@ -367,27 +398,31 @@ class AppGroup(click.Group):
     Not to be confused with :class:`FlaskGroup`.
     """
 
-    def command(self, *args, **kwargs):
+    def command(  # type: ignore[override]
+        self, *args: t.Any, **kwargs: t.Any
+    ) -> t.Callable[[t.Callable[..., t.Any]], click.Command]:
         """This works exactly like the method of the same name on a regular
         :class:`click.Group` but it wraps callbacks in :func:`with_appcontext`
         unless it's disabled by passing ``with_appcontext=False``.
         """
         wrap_for_ctx = kwargs.pop("with_appcontext", True)
 
-        def decorator(f):
+        def decorator(f: t.Callable[..., t.Any]) -> click.Command:
             if wrap_for_ctx:
                 f = with_appcontext(f)
-            return click.Group.command(self, *args, **kwargs)(f)
+            return super(AppGroup, self).command(*args, **kwargs)(f)  # type: ignore[no-any-return]
 
         return decorator
 
-    def group(self, *args, **kwargs):
+    def group(  # type: ignore[override]
+        self, *args: t.Any, **kwargs: t.Any
+    ) -> t.Callable[[t.Callable[..., t.Any]], click.Group]:
         """This works exactly like the method of the same name on a regular
         :class:`click.Group` but it defaults the group class to
         :class:`AppGroup`.
         """
         kwargs.setdefault("cls", AppGroup)
-        return click.Group.group(self, *args, **kwargs)
+        return super().group(*args, **kwargs)  # type: ignore[no-any-return]
 
 
 def _set_app(ctx: click.Context, param: click.Option, value: str | None) -> str | None:
@@ -544,7 +579,7 @@ class FlaskGroup(AppGroup):
 
         self._loaded_plugin_commands = False
 
-    def _load_plugin_commands(self):
+    def _load_plugin_commands(self) -> None:
         if self._loaded_plugin_commands:
             return
 
@@ -561,7 +596,7 @@ class FlaskGroup(AppGroup):
 
         self._loaded_plugin_commands = True
 
-    def get_command(self, ctx, name):
+    def get_command(self, ctx: click.Context, name: str) -> click.Command | None:
         self._load_plugin_commands()
         # Look up built-in and plugin commands, which should be
         # available even if the app fails to load.
@@ -583,12 +618,12 @@ class FlaskGroup(AppGroup):
         # Push an app context for the loaded app unless it is already
         # active somehow. This makes the context available to parameter
         # and command callbacks without needing @with_appcontext.
-        if not current_app or current_app._get_current_object() is not app:
+        if not current_app or current_app._get_current_object() is not app:  # type: ignore[attr-defined]
             ctx.with_resource(app.app_context())
 
         return app.cli.get_command(ctx, name)
 
-    def list_commands(self, ctx):
+    def list_commands(self, ctx: click.Context) -> list[str]:
         self._load_plugin_commands()
         # Start with the built-in and plugin commands.
         rv = set(super().list_commands(ctx))
@@ -644,14 +679,14 @@ class FlaskGroup(AppGroup):
         return super().parse_args(ctx, args)
 
 
-def _path_is_ancestor(path, other):
+def _path_is_ancestor(path: str, other: str) -> bool:
     """Take ``other`` and remove the length of ``path`` from it. Then join it
     to ``path``. If it is the original value, ``path`` is an ancestor of
     ``other``."""
     return os.path.join(path, other[len(path) :].lstrip(os.sep)) == other
 
 
-def load_dotenv(path: str | os.PathLike | None = None) -> bool:
+def load_dotenv(path: str | os.PathLike[str] | None = None) -> bool:
     """Load "dotenv" files in order of precedence to set environment variables.
 
     If an env var is already set it is not overwritten, so earlier files in the
@@ -712,7 +747,7 @@ def load_dotenv(path: str | os.PathLike | None = None) -> bool:
     return loaded  # True if at least one file was located and loaded.
 
 
-def show_server_banner(debug, app_import_path):
+def show_server_banner(debug: bool, app_import_path: str | None) -> None:
     """Show extra startup messages the first time the server is run,
     ignoring the reloader.
     """
@@ -734,10 +769,12 @@ class CertParamType(click.ParamType):
 
     name = "path"
 
-    def __init__(self):
+    def __init__(self) -> None:
         self.path_type = click.Path(exists=True, dir_okay=False, resolve_path=True)
 
-    def convert(self, value, param, ctx):
+    def convert(
+        self, value: t.Any, param: click.Parameter | None, ctx: click.Context | None
+    ) -> t.Any:
         try:
             import ssl
         except ImportError:
@@ -772,7 +809,7 @@ class CertParamType(click.ParamType):
             raise
 
 
-def _validate_key(ctx, param, value):
+def _validate_key(ctx: click.Context, param: click.Parameter, value: t.Any) -> t.Any:
     """The ``--key`` option must be specified when ``--cert`` is a file.
     Modifies the ``cert`` param to be a ``(cert, key)`` pair if needed.
     """
@@ -794,7 +831,9 @@ def _validate_key(ctx, param, value):
 
         if is_context:
             raise click.BadParameter(
-                'When "--cert" is an SSLContext object, "--key is not used.', ctx, param
+                'When "--cert" is an SSLContext object, "--key" is not used.',
+                ctx,
+                param,
             )
 
         if not cert:
@@ -815,8 +854,11 @@ class SeparatedPathType(click.Path):
     validated as a :class:`click.Path` type.
     """
 
-    def convert(self, value, param, ctx):
+    def convert(
+        self, value: t.Any, param: click.Parameter | None, ctx: click.Context | None
+    ) -> t.Any:
         items = self.split_envvar_value(value)
+        # can't call no-arg super() inside list comprehension until Python 3.12
         super_convert = super().convert
         return [super_convert(item, param, ctx) for item in items]
 
@@ -875,16 +917,16 @@ class SeparatedPathType(click.Path):
 )
 @pass_script_info
 def run_command(
-    info,
-    host,
-    port,
-    reload,
-    debugger,
-    with_threads,
-    cert,
-    extra_files,
-    exclude_patterns,
-):
+    info: ScriptInfo,
+    host: str,
+    port: int,
+    reload: bool,
+    debugger: bool,
+    with_threads: bool,
+    cert: ssl.SSLContext | tuple[str, str | None] | t.Literal["adhoc"] | None,
+    extra_files: list[str] | None,
+    exclude_patterns: list[str] | None,
+) -> None:
     """Run a local development server.
 
     This server is for development purposes only. It does not provide
@@ -894,7 +936,7 @@ def run_command(
     option.
     """
     try:
-        app = info.load_app()
+        app: WSGIApplication = info.load_app()
     except Exception as e:
         if is_running_from_reloader():
             # When reloading, print out the error immediately, but raise
@@ -902,7 +944,9 @@ def run_command(
             traceback.print_exc()
             err = e
 
-            def app(environ, start_response):
+            def app(
+                environ: WSGIEnvironment, start_response: StartResponse
+            ) -> cabc.Iterable[bytes]:
                 raise err from None
 
         else:
@@ -953,7 +997,7 @@ def shell_command() -> None:
         f"App: {current_app.import_name}\n"
         f"Instance: {current_app.instance_path}"
     )
-    ctx: dict = {}
+    ctx: dict[str, t.Any] = {}
 
     # Support the regular Python interpreter startup script if someone
     # is using it.
diff --git a/src/flask/config.py b/src/flask/config.py
index a73dd786..f2f41478 100644
--- a/src/flask/config.py
+++ b/src/flask/config.py
@@ -8,27 +8,48 @@ import typing as t
 
 from werkzeug.utils import import_string
 
+if t.TYPE_CHECKING:
+    import typing_extensions as te
 
-class ConfigAttribute:
+    from .sansio.app import App
+
+
+T = t.TypeVar("T")
+
+
+class ConfigAttribute(t.Generic[T]):
     """Makes an attribute forward to the config"""
 
-    def __init__(self, name: str, get_converter: t.Callable | None = None) -> None:
+    def __init__(
+        self, name: str, get_converter: t.Callable[[t.Any], T] | None = None
+    ) -> None:
         self.__name__ = name
         self.get_converter = get_converter
 
-    def __get__(self, obj: t.Any, owner: t.Any = None) -> t.Any:
+    @t.overload
+    def __get__(self, obj: None, owner: None) -> te.Self:
+        ...
+
+    @t.overload
+    def __get__(self, obj: App, owner: type[App]) -> T:
+        ...
+
+    def __get__(self, obj: App | None, owner: type[App] | None = None) -> T | te.Self:
         if obj is None:
             return self
+
         rv = obj.config[self.__name__]
+
         if self.get_converter is not None:
             rv = self.get_converter(rv)
-        return rv
 
-    def __set__(self, obj: t.Any, value: t.Any) -> None:
+        return rv  # type: ignore[no-any-return]
+
+    def __set__(self, obj: App, value: t.Any) -> None:
         obj.config[self.__name__] = value
 
 
-class Config(dict):
+class Config(dict):  # type: ignore[type-arg]
     """Works exactly like a dict but provides ways to fill it from files
     or special dictionaries.  There are two common patterns to populate the
     config.
@@ -72,7 +93,11 @@ class Config(dict):
     :param defaults: an optional dictionary of default values
     """
 
-    def __init__(self, root_path: str, defaults: dict | None = None) -> None:
+    def __init__(
+        self,
+        root_path: str | os.PathLike[str],
+        defaults: dict[str, t.Any] | None = None,
+    ) -> None:
         super().__init__(defaults or {})
         self.root_path = root_path
 
@@ -164,7 +189,9 @@ class Config(dict):
 
         return True
 
-    def from_pyfile(self, filename: str, silent: bool = False) -> bool:
+    def from_pyfile(
+        self, filename: str | os.PathLike[str], silent: bool = False
+    ) -> bool:
         """Updates the values in the config from a Python file.  This function
         behaves as if the file was imported as module with the
         :meth:`from_object` function.
@@ -233,8 +260,8 @@ class Config(dict):
 
     def from_file(
         self,
-        filename: str,
-        load: t.Callable[[t.IO[t.Any]], t.Mapping],
+        filename: str | os.PathLike[str],
+        load: t.Callable[[t.IO[t.Any]], t.Mapping[str, t.Any]],
         silent: bool = False,
         text: bool = True,
     ) -> bool:
diff --git a/src/flask/ctx.py b/src/flask/ctx.py
index b37e4e04..9b164d39 100644
--- a/src/flask/ctx.py
+++ b/src/flask/ctx.py
@@ -15,6 +15,8 @@ from .signals import appcontext_popped
 from .signals import appcontext_pushed
 
 if t.TYPE_CHECKING:  # pragma: no cover
+    from _typeshed.wsgi import WSGIEnvironment
+
     from .app import Flask
     from .sessions import SessionMixin
     from .wrappers import Request
@@ -112,7 +114,9 @@ class _AppCtxGlobals:
         return object.__repr__(self)
 
 
-def after_this_request(f: ft.AfterRequestCallable) -> ft.AfterRequestCallable:
+def after_this_request(
+    f: ft.AfterRequestCallable[t.Any],
+) -> ft.AfterRequestCallable[t.Any]:
     """Executes a function after this request.  This is useful to modify
     response objects.  The function is passed the response object and has
     to return the same or a new one.
@@ -145,7 +149,10 @@ def after_this_request(f: ft.AfterRequestCallable) -> ft.AfterRequestCallable:
     return f
 
 
-def copy_current_request_context(f: t.Callable) -> t.Callable:
+F = t.TypeVar("F", bound=t.Callable[..., t.Any])
+
+
+def copy_current_request_context(f: F) -> F:
     """A helper function that decorates a function to retain the current
     request context.  This is useful when working with greenlets.  The moment
     the function is decorated a copy of the request context is created and
@@ -179,11 +186,11 @@ def copy_current_request_context(f: t.Callable) -> t.Callable:
 
     ctx = ctx.copy()
 
-    def wrapper(*args, **kwargs):
-        with ctx:
-            return ctx.app.ensure_sync(f)(*args, **kwargs)
+    def wrapper(*args: t.Any, **kwargs: t.Any) -> t.Any:
+        with ctx:  # type: ignore[union-attr]
+            return ctx.app.ensure_sync(f)(*args, **kwargs)  # type: ignore[union-attr]
 
-    return update_wrapper(wrapper, f)
+    return update_wrapper(wrapper, f)  # type: ignore[return-value]
 
 
 def has_request_context() -> bool:
@@ -239,7 +246,7 @@ class AppContext:
         self.app = app
         self.url_adapter = app.create_url_adapter(None)
         self.g: _AppCtxGlobals = app.app_ctx_globals_class()
-        self._cv_tokens: list[contextvars.Token] = []
+        self._cv_tokens: list[contextvars.Token[AppContext]] = []
 
     def push(self) -> None:
         """Binds the app context to the current context."""
@@ -302,7 +309,7 @@ class RequestContext:
     def __init__(
         self,
         app: Flask,
-        environ: dict,
+        environ: WSGIEnvironment,
         request: Request | None = None,
         session: SessionMixin | None = None,
     ) -> None:
@@ -321,9 +328,11 @@ class RequestContext:
         # Functions that should be executed after the request on the response
         # object.  These will be called before the regular "after_request"
         # functions.
-        self._after_request_functions: list[ft.AfterRequestCallable] = []
+        self._after_request_functions: list[ft.AfterRequestCallable[t.Any]] = []
 
-        self._cv_tokens: list[tuple[contextvars.Token, AppContext | None]] = []
+        self._cv_tokens: list[
+            tuple[contextvars.Token[RequestContext], AppContext | None]
+        ] = []
 
     def copy(self) -> RequestContext:
         """Creates a copy of this request context with the same request object.
diff --git a/src/flask/debughelpers.py b/src/flask/debughelpers.py
index 6061441a..2c8c4c48 100644
--- a/src/flask/debughelpers.py
+++ b/src/flask/debughelpers.py
@@ -2,9 +2,16 @@ from __future__ import annotations
 
 import typing as t
 
-from .app import Flask
+from jinja2.loaders import BaseLoader
+from werkzeug.routing import RequestRedirect
+
 from .blueprints import Blueprint
 from .globals import request_ctx
+from .sansio.app import App
+
+if t.TYPE_CHECKING:
+    from .sansio.scaffold import Scaffold
+    from .wrappers import Request
 
 
 class UnexpectedUnicodeError(AssertionError, UnicodeError):
@@ -18,7 +25,7 @@ class DebugFilesKeyError(KeyError, AssertionError):
     provide a better error message than just a generic KeyError/BadRequest.
     """
 
-    def __init__(self, request, key):
+    def __init__(self, request: Request, key: str) -> None:
         form_matches = request.form.getlist(key)
         buf = [
             f"You tried to access the file {key!r} in the request.files"
@@ -36,7 +43,7 @@ class DebugFilesKeyError(KeyError, AssertionError):
             )
         self.msg = "".join(buf)
 
-    def __str__(self):
+    def __str__(self) -> str:
         return self.msg
 
 
@@ -47,8 +54,9 @@ class FormDataRoutingRedirect(AssertionError):
     307 or 308.
     """
 
-    def __init__(self, request):
+    def __init__(self, request: Request) -> None:
         exc = request.routing_exception
+        assert isinstance(exc, RequestRedirect)
         buf = [
             f"A request was sent to '{request.url}', but routing issued"
             f" a redirect to the canonical URL '{exc.new_url}'."
@@ -70,7 +78,7 @@ class FormDataRoutingRedirect(AssertionError):
         super().__init__("".join(buf))
 
 
-def attach_enctype_error_multidict(request):
+def attach_enctype_error_multidict(request: Request) -> None:
     """Patch ``request.files.__getitem__`` to raise a descriptive error
     about ``enctype=multipart/form-data``.
 
@@ -79,8 +87,8 @@ def attach_enctype_error_multidict(request):
     """
     oldcls = request.files.__class__
 
-    class newcls(oldcls):
-        def __getitem__(self, key):
+    class newcls(oldcls):  # type: ignore[valid-type, misc]
+        def __getitem__(self, key: str) -> t.Any:
             try:
                 return super().__getitem__(key)
             except KeyError as e:
@@ -96,7 +104,7 @@ def attach_enctype_error_multidict(request):
     request.files.__class__ = newcls
 
 
-def _dump_loader_info(loader) -> t.Generator:
+def _dump_loader_info(loader: BaseLoader) -> t.Iterator[str]:
     yield f"class: {type(loader).__module__}.{type(loader).__name__}"
     for key, value in sorted(loader.__dict__.items()):
         if key.startswith("_"):
@@ -113,7 +121,17 @@ def _dump_loader_info(loader) -> t.Generator:
         yield f"{key}: {value!r}"
 
 
-def explain_template_loading_attempts(app: Flask, template, attempts) -> None:
+def explain_template_loading_attempts(
+    app: App,
+    template: str,
+    attempts: list[
+        tuple[
+            BaseLoader,
+            Scaffold,
+            tuple[str, str | None, t.Callable[[], bool] | None] | None,
+        ]
+    ],
+) -> None:
     """This should help developers understand what failed"""
     info = [f"Locating template {template!r}:"]
     total_found = 0
@@ -122,7 +140,7 @@ def explain_template_loading_attempts(app: Flask, template, attempts) -> None:
         blueprint = request_ctx.request.blueprint
 
     for idx, (loader, srcobj, triple) in enumerate(attempts):
-        if isinstance(srcobj, Flask):
+        if isinstance(srcobj, App):
             src_info = f"application {srcobj.import_name!r}"
         elif isinstance(srcobj, Blueprint):
             src_info = f"blueprint {srcobj.name!r} ({srcobj.import_name})"
diff --git a/src/flask/globals.py b/src/flask/globals.py
index e9cd4acf..e2c410cc 100644
--- a/src/flask/globals.py
+++ b/src/flask/globals.py
@@ -14,25 +14,6 @@ if t.TYPE_CHECKING:  # pragma: no cover
     from .wrappers import Request
 
 
-class _FakeStack:
-    def __init__(self, name: str, cv: ContextVar[t.Any]) -> None:
-        self.name = name
-        self.cv = cv
-
-    @property
-    def top(self) -> t.Any | None:
-        import warnings
-
-        warnings.warn(
-            f"'_{self.name}_ctx_stack' is deprecated and will be removed in Flask 2.4."
-            f" Use 'g' to store data, or '{self.name}_ctx' to access the current"
-            " context.",
-            DeprecationWarning,
-            stacklevel=2,
-        )
-        return self.cv.get(None)
-
-
 _no_app_msg = """\
 Working outside of application context.
 
@@ -41,7 +22,6 @@ the current application. To solve this, set up an application context
 with app.app_context(). See the documentation for more information.\
 """
 _cv_app: ContextVar[AppContext] = ContextVar("flask.app_ctx")
-__app_ctx_stack = _FakeStack("app", _cv_app)
 app_ctx: AppContext = LocalProxy(  # type: ignore[assignment]
     _cv_app, unbound_message=_no_app_msg
 )
@@ -60,7 +40,6 @@ an active HTTP request. Consult the documentation on testing for
 information about how to avoid this problem.\
 """
 _cv_request: ContextVar[RequestContext] = ContextVar("flask.request_ctx")
-__request_ctx_stack = _FakeStack("request", _cv_request)
 request_ctx: RequestContext = LocalProxy(  # type: ignore[assignment]
     _cv_request, unbound_message=_no_req_msg
 )
@@ -70,27 +49,3 @@ request: Request = LocalProxy(  # type: ignore[assignment]
 session: SessionMixin = LocalProxy(  # type: ignore[assignment]
     _cv_request, "session", unbound_message=_no_req_msg
 )
-
-
-def __getattr__(name: str) -> t.Any:
-    if name == "_app_ctx_stack":
-        import warnings
-
-        warnings.warn(
-            "'_app_ctx_stack' is deprecated and will be removed in Flask 2.4.",
-            DeprecationWarning,
-            stacklevel=2,
-        )
-        return __app_ctx_stack
-
-    if name == "_request_ctx_stack":
-        import warnings
-
-        warnings.warn(
-            "'_request_ctx_stack' is deprecated and will be removed in Flask 2.4.",
-            DeprecationWarning,
-            stacklevel=2,
-        )
-        return __request_ctx_stack
-
-    raise AttributeError(name)
diff --git a/src/flask/helpers.py b/src/flask/helpers.py
index 61a0f818..359a842a 100644
--- a/src/flask/helpers.py
+++ b/src/flask/helpers.py
@@ -1,19 +1,17 @@
 from __future__ import annotations
 
+import importlib.util
 import os
-import pkgutil
-import socket
 import sys
 import typing as t
-import warnings
 from datetime import datetime
 from functools import lru_cache
 from functools import update_wrapper
-from threading import RLock
 
 import werkzeug.utils
 from werkzeug.exceptions import abort as _wz_abort
 from werkzeug.utils import redirect as _wz_redirect
+from werkzeug.wrappers import Response as BaseResponse
 
 from .globals import _cv_request
 from .globals import current_app
@@ -23,7 +21,6 @@ from .globals import session
 from .signals import message_flashed
 
 if t.TYPE_CHECKING:  # pragma: no cover
-    from werkzeug.wrappers import Response as BaseResponse
     from .wrappers import Response
 
 
@@ -51,9 +48,7 @@ def get_load_dotenv(default: bool = True) -> bool:
 
 
 def stream_with_context(
-    generator_or_function: (
-        t.Iterator[t.AnyStr] | t.Callable[..., t.Iterator[t.AnyStr]]
-    )
+    generator_or_function: t.Iterator[t.AnyStr] | t.Callable[..., t.Iterator[t.AnyStr]],
 ) -> t.Iterator[t.AnyStr]:
     """Request contexts disappear when the response is started on the server.
     This is done for efficiency reasons and to make it less likely to encounter
@@ -89,16 +84,16 @@ def stream_with_context(
     .. versionadded:: 0.9
     """
     try:
-        gen = iter(generator_or_function)  # type: ignore
+        gen = iter(generator_or_function)  # type: ignore[arg-type]
     except TypeError:
 
         def decorator(*args: t.Any, **kwargs: t.Any) -> t.Any:
-            gen = generator_or_function(*args, **kwargs)  # type: ignore
+            gen = generator_or_function(*args, **kwargs)  # type: ignore[operator]
             return stream_with_context(gen)
 
-        return update_wrapper(decorator, generator_or_function)  # type: ignore
+        return update_wrapper(decorator, generator_or_function)  # type: ignore[arg-type]
 
-    def generator() -> t.Generator:
+    def generator() -> t.Iterator[t.AnyStr | None]:
         ctx = _cv_request.get(None)
         if ctx is None:
             raise RuntimeError(
@@ -126,7 +121,7 @@ def stream_with_context(
     # real generator is executed.
     wrapped_g = generator()
     next(wrapped_g)
-    return wrapped_g
+    return wrapped_g  # type: ignore[return-value]
 
 
 def make_response(*args: t.Any) -> Response:
@@ -175,7 +170,7 @@ def make_response(*args: t.Any) -> Response:
         return current_app.response_class()
     if len(args) == 1:
         args = args[0]
-    return current_app.make_response(args)  # type: ignore
+    return current_app.make_response(args)
 
 
 def url_for(
@@ -391,7 +386,7 @@ def _prepare_send_file_kwargs(**kwargs: t.Any) -> dict[str, t.Any]:
 
 
 def send_file(
-    path_or_file: os.PathLike | str | t.BinaryIO,
+    path_or_file: os.PathLike[t.AnyStr] | str | t.BinaryIO,
     mimetype: str | None = None,
     as_attachment: bool = False,
     download_name: str | None = None,
@@ -492,7 +487,7 @@ def send_file(
 
     .. versionchanged:: 0.7
         MIME guessing and etag support for file-like objects was
-        deprecated because it was unreliable. Pass a filename if you are
+        removed because it was unreliable. Pass a filename if you are
         able to, otherwise attach an etag yourself.
 
     .. versionchanged:: 0.5
@@ -517,8 +512,8 @@ def send_file(
 
 
 def send_from_directory(
-    directory: os.PathLike | str,
-    path: os.PathLike | str,
+    directory: os.PathLike[str] | str,
+    path: os.PathLike[str] | str,
     **kwargs: t.Any,
 ) -> Response:
     """Send a file from within a directory using :func:`send_file`.
@@ -575,12 +570,20 @@ def get_root_path(import_name: str) -> str:
         return os.path.dirname(os.path.abspath(mod.__file__))
 
     # Next attempt: check the loader.
-    loader = pkgutil.get_loader(import_name)
+    try:
+        spec = importlib.util.find_spec(import_name)
+
+        if spec is None:
+            raise ValueError
+    except (ImportError, ValueError):
+        loader = None
+    else:
+        loader = spec.loader
 
     # Loader does not exist or we're referring to an unloaded main
     # module or a main module without path (interactive sessions), go
     # with the current working directory.
-    if loader is None or import_name == "__main__":
+    if loader is None:
         return os.getcwd()
 
     if hasattr(loader, "get_filename"):
@@ -605,82 +608,7 @@ def get_root_path(import_name: str) -> str:
             )
 
     # filepath is import_name.py for a module, or __init__.py for a package.
-    return os.path.dirname(os.path.abspath(filepath))
-
-
-class locked_cached_property(werkzeug.utils.cached_property):
-    """A :func:`property` that is only evaluated once. Like
-    :class:`werkzeug.utils.cached_property` except access uses a lock
-    for thread safety.
-
-    .. deprecated:: 2.3
-        Will be removed in Flask 2.4. Use a lock inside the decorated function if
-        locking is needed.
-
-    .. versionchanged:: 2.0
-        Inherits from Werkzeug's ``cached_property`` (and ``property``).
-    """
-
-    def __init__(
-        self,
-        fget: t.Callable[[t.Any], t.Any],
-        name: str | None = None,
-        doc: str | None = None,
-    ) -> None:
-        import warnings
-
-        warnings.warn(
-            "'locked_cached_property' is deprecated and will be removed in Flask 2.4."
-            " Use a lock inside the decorated function if locking is needed.",
-            DeprecationWarning,
-            stacklevel=2,
-        )
-        super().__init__(fget, name=name, doc=doc)
-        self.lock = RLock()
-
-    def __get__(self, obj: object, type: type = None) -> t.Any:  # type: ignore
-        if obj is None:
-            return self
-
-        with self.lock:
-            return super().__get__(obj, type=type)
-
-    def __set__(self, obj: object, value: t.Any) -> None:
-        with self.lock:
-            super().__set__(obj, value)
-
-    def __delete__(self, obj: object) -> None:
-        with self.lock:
-            super().__delete__(obj)
-
-
-def is_ip(value: str) -> bool:
-    """Determine if the given string is an IP address.
-
-    :param value: value to check
-    :type value: str
-
-    :return: True if string is an IP address
-    :rtype: bool
-
-    .. deprecated:: 2.3
-        Will be removed in Flask 2.4.
-    """
-    warnings.warn(
-        "The 'is_ip' function is deprecated and will be removed in Flask 2.4.",
-        DeprecationWarning,
-        stacklevel=2,
-    )
-
-    for family in (socket.AF_INET, socket.AF_INET6):
-        try:
-            socket.inet_pton(family, value)
-        except OSError:
-            pass
-        else:
-            return True
-
-    return False
+    return os.path.dirname(os.path.abspath(filepath))  # type: ignore[no-any-return]
 
 
 @lru_cache(maxsize=None)
diff --git a/src/flask/json/__init__.py b/src/flask/json/__init__.py
index f15296fe..c0941d04 100644
--- a/src/flask/json/__init__.py
+++ b/src/flask/json/__init__.py
@@ -167,4 +167,4 @@ def jsonify(*args: t.Any, **kwargs: t.Any) -> Response:
 
     .. versionadded:: 0.2
     """
-    return current_app.json.response(*args, **kwargs)
+    return current_app.json.response(*args, **kwargs)  # type: ignore[return-value]
diff --git a/src/flask/json/provider.py b/src/flask/json/provider.py
index 0edd3d58..f9b2e8ff 100644
--- a/src/flask/json/provider.py
+++ b/src/flask/json/provider.py
@@ -11,8 +11,9 @@ from datetime import date
 from werkzeug.http import http_date
 
 if t.TYPE_CHECKING:  # pragma: no cover
-    from ..app import Flask
-    from ..wrappers import Response
+    from werkzeug.sansio.response import Response
+
+    from ..sansio.app import App
 
 
 class JSONProvider:
@@ -34,8 +35,8 @@ class JSONProvider:
     .. versionadded:: 2.2
     """
 
-    def __init__(self, app: Flask) -> None:
-        self._app = weakref.proxy(app)
+    def __init__(self, app: App) -> None:
+        self._app: App = weakref.proxy(app)
 
     def dumps(self, obj: t.Any, **kwargs: t.Any) -> str:
         """Serialize data as JSON.
@@ -134,9 +135,7 @@ class DefaultJSONProvider(JSONProvider):
         method) will call the ``__html__`` method to get a string.
     """
 
-    default: t.Callable[[t.Any], t.Any] = staticmethod(
-        _default
-    )  # type: ignore[assignment]
+    default: t.Callable[[t.Any], t.Any] = staticmethod(_default)  # type: ignore[assignment]
     """Apply this function to any object that :meth:`json.dumps` does
     not know how to serialize. It should return a valid JSON type or
     raise a ``TypeError``.
diff --git a/src/flask/json/tag.py b/src/flask/json/tag.py
index 91cc4412..2bb986bc 100644
--- a/src/flask/json/tag.py
+++ b/src/flask/json/tag.py
@@ -61,9 +61,9 @@ class JSONTag:
 
     __slots__ = ("serializer",)
 
-    #: The tag to mark the serialized object with. If ``None``, this tag is
+    #: The tag to mark the serialized object with. If empty, this tag is
     #: only used as an intermediate step during tagging.
-    key: str | None = None
+    key: str = ""
 
     def __init__(self, serializer: TaggedJSONSerializer) -> None:
         """Create a tagger for the given serializer."""
@@ -83,7 +83,7 @@ class JSONTag:
         will already be removed."""
         raise NotImplementedError
 
-    def tag(self, value: t.Any) -> t.Any:
+    def tag(self, value: t.Any) -> dict[str, t.Any]:
         """Convert the value to a valid JSON type and add the tag structure
         around it."""
         return {self.key: self.to_json(value)}
@@ -274,7 +274,7 @@ class TaggedJSONSerializer:
         tag = tag_class(self)
         key = tag.key
 
-        if key is not None:
+        if key:
             if not force and key in self.tags:
                 raise KeyError(f"Tag '{key}' is already registered.")
 
@@ -285,7 +285,7 @@ class TaggedJSONSerializer:
         else:
             self.order.insert(index, tag)
 
-    def tag(self, value: t.Any) -> dict[str, t.Any]:
+    def tag(self, value: t.Any) -> t.Any:
         """Convert a value to a tagged representation if necessary."""
         for tag in self.order:
             if tag.check(value):
@@ -305,10 +305,22 @@ class TaggedJSONSerializer:
 
         return self.tags[key].to_python(value[key])
 
+    def _untag_scan(self, value: t.Any) -> t.Any:
+        if isinstance(value, dict):
+            # untag each item recursively
+            value = {k: self._untag_scan(v) for k, v in value.items()}
+            # untag the dict itself
+            value = self.untag(value)
+        elif isinstance(value, list):
+            # untag each item recursively
+            value = [self._untag_scan(item) for item in value]
+
+        return value
+
     def dumps(self, value: t.Any) -> str:
         """Tag the value and dump it to a compact JSON string."""
         return dumps(self.tag(value), separators=(",", ":"))
 
     def loads(self, value: str) -> t.Any:
         """Load data from a JSON string and deserialized any tagged objects."""
-        return loads(value, object_hook=self.untag)
+        return self._untag_scan(loads(value))
diff --git a/src/flask/logging.py b/src/flask/logging.py
index 99f6be85..0cb8f437 100644
--- a/src/flask/logging.py
+++ b/src/flask/logging.py
@@ -9,7 +9,7 @@ from werkzeug.local import LocalProxy
 from .globals import request
 
 if t.TYPE_CHECKING:  # pragma: no cover
-    from .app import Flask
+    from .sansio.app import App
 
 
 @LocalProxy
@@ -22,7 +22,10 @@ def wsgi_errors_stream() -> t.TextIO:
     can't import this directly, you can refer to it as
     ``ext://flask.logging.wsgi_errors_stream``.
     """
-    return request.environ["wsgi.errors"] if request else sys.stderr
+    if request:
+        return request.environ["wsgi.errors"]  # type: ignore[no-any-return]
+
+    return sys.stderr
 
 
 def has_level_handler(logger: logging.Logger) -> bool:
@@ -52,7 +55,7 @@ default_handler.setFormatter(
 )
 
 
-def create_logger(app: Flask) -> logging.Logger:
+def create_logger(app: App) -> logging.Logger:
     """Get the Flask app's logger and configure it if needed.
 
     The logger name will be the same as
diff --git a/src/flask/sansio/README.md b/src/flask/sansio/README.md
new file mode 100644
index 00000000..623ac198
--- /dev/null
+++ b/src/flask/sansio/README.md
@@ -0,0 +1,6 @@
+# Sansio
+
+This folder contains code that can be used by alternative Flask
+implementations, for example Quart. The code therefore cannot do any
+IO, nor be part of a likely IO path. Finally this code cannot use the
+Flask globals.
diff --git a/src/flask/sansio/app.py b/src/flask/sansio/app.py
new file mode 100644
index 00000000..21a79ba4
--- /dev/null
+++ b/src/flask/sansio/app.py
@@ -0,0 +1,968 @@
+from __future__ import annotations
+
+import logging
+import os
+import sys
+import typing as t
+from datetime import timedelta
+from itertools import chain
+
+from werkzeug.exceptions import Aborter
+from werkzeug.exceptions import BadRequest
+from werkzeug.exceptions import BadRequestKeyError
+from werkzeug.routing import BuildError
+from werkzeug.routing import Map
+from werkzeug.routing import Rule
+from werkzeug.sansio.response import Response
+from werkzeug.utils import cached_property
+from werkzeug.utils import redirect as _wz_redirect
+
+from .. import typing as ft
+from ..config import Config
+from ..config import ConfigAttribute
+from ..ctx import _AppCtxGlobals
+from ..helpers import _split_blueprint_path
+from ..helpers import get_debug_flag
+from ..json.provider import DefaultJSONProvider
+from ..json.provider import JSONProvider
+from ..logging import create_logger
+from ..templating import DispatchingJinjaLoader
+from ..templating import Environment
+from .scaffold import _endpoint_from_view_func
+from .scaffold import find_package
+from .scaffold import Scaffold
+from .scaffold import setupmethod
+
+if t.TYPE_CHECKING:  # pragma: no cover
+    from werkzeug.wrappers import Response as BaseResponse
+
+    from ..testing import FlaskClient
+    from ..testing import FlaskCliRunner
+    from .blueprints import Blueprint
+
+T_shell_context_processor = t.TypeVar(
+    "T_shell_context_processor", bound=ft.ShellContextProcessorCallable
+)
+T_teardown = t.TypeVar("T_teardown", bound=ft.TeardownCallable)
+T_template_filter = t.TypeVar("T_template_filter", bound=ft.TemplateFilterCallable)
+T_template_global = t.TypeVar("T_template_global", bound=ft.TemplateGlobalCallable)
+T_template_test = t.TypeVar("T_template_test", bound=ft.TemplateTestCallable)
+
+
+def _make_timedelta(value: timedelta | int | None) -> timedelta | None:
+    if value is None or isinstance(value, timedelta):
+        return value
+
+    return timedelta(seconds=value)
+
+
+class App(Scaffold):
+    """The flask object implements a WSGI application and acts as the central
+    object.  It is passed the name of the module or package of the
+    application.  Once it is created it will act as a central registry for
+    the view functions, the URL rules, template configuration and much more.
+
+    The name of the package is used to resolve resources from inside the
+    package or the folder the module is contained in depending on if the
+    package parameter resolves to an actual python package (a folder with
+    an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).
+
+    For more information about resource loading, see :func:`open_resource`.
+
+    Usually you create a :class:`Flask` instance in your main module or
+    in the :file:`__init__.py` file of your package like this::
+
+        from flask import Flask
+        app = Flask(__name__)
+
+    .. admonition:: About the First Parameter
+
+        The idea of the first parameter is to give Flask an idea of what
+        belongs to your application.  This name is used to find resources
+        on the filesystem, can be used by extensions to improve debugging
+        information and a lot more.
+
+        So it's important what you provide there.  If you are using a single
+        module, `__name__` is always the correct value.  If you however are
+        using a package, it's usually recommended to hardcode the name of
+        your package there.
+
+        For example if your application is defined in :file:`yourapplication/app.py`
+        you should create it with one of the two versions below::
+
+            app = Flask('yourapplication')
+            app = Flask(__name__.split('.')[0])
+
+        Why is that?  The application will work even with `__name__`, thanks
+        to how resources are looked up.  However it will make debugging more
+        painful.  Certain extensions can make assumptions based on the
+        import name of your application.  For example the Flask-SQLAlchemy
+        extension will look for the code in your application that triggered
+        an SQL query in debug mode.  If the import name is not properly set
+        up, that debugging information is lost.  (For example it would only
+        pick up SQL queries in `yourapplication.app` and not
+        `yourapplication.views.frontend`)
+
+    .. versionadded:: 0.7
+       The `static_url_path`, `static_folder`, and `template_folder`
+       parameters were added.
+
+    .. versionadded:: 0.8
+       The `instance_path` and `instance_relative_config` parameters were
+       added.
+
+    .. versionadded:: 0.11
+       The `root_path` parameter was added.
+
+    .. versionadded:: 1.0
+       The ``host_matching`` and ``static_host`` parameters were added.
+
+    .. versionadded:: 1.0
+       The ``subdomain_matching`` parameter was added. Subdomain
+       matching needs to be enabled manually now. Setting
+       :data:`SERVER_NAME` does not implicitly enable it.
+
+    :param import_name: the name of the application package
+    :param static_url_path: can be used to specify a different path for the
+                            static files on the web.  Defaults to the name
+                            of the `static_folder` folder.
+    :param static_folder: The folder with static files that is served at
+        ``static_url_path``. Relative to the application ``root_path``
+        or an absolute path. Defaults to ``'static'``.
+    :param static_host: the host to use when adding the static route.
+        Defaults to None. Required when using ``host_matching=True``
+        with a ``static_folder`` configured.
+    :param host_matching: set ``url_map.host_matching`` attribute.
+        Defaults to False.
+    :param subdomain_matching: consider the subdomain relative to
+        :data:`SERVER_NAME` when matching routes. Defaults to False.
+    :param template_folder: the folder that contains the templates that should
+                            be used by the application.  Defaults to
+                            ``'templates'`` folder in the root path of the
+                            application.
+    :param instance_path: An alternative instance path for the application.
+                          By default the folder ``'instance'`` next to the
+                          package or module is assumed to be the instance
+                          path.
+    :param instance_relative_config: if set to ``True`` relative filenames
+                                     for loading the config are assumed to
+                                     be relative to the instance path instead
+                                     of the application root.
+    :param root_path: The path to the root of the application files.
+        This should only be set manually when it can't be detected
+        automatically, such as for namespace packages.
+    """
+
+    #: The class of the object assigned to :attr:`aborter`, created by
+    #: :meth:`create_aborter`. That object is called by
+    #: :func:`flask.abort` to raise HTTP errors, and can be
+    #: called directly as well.
+    #:
+    #: Defaults to :class:`werkzeug.exceptions.Aborter`.
+    #:
+    #: .. versionadded:: 2.2
+    aborter_class = Aborter
+
+    #: The class that is used for the Jinja environment.
+    #:
+    #: .. versionadded:: 0.11
+    jinja_environment = Environment
+
+    #: The class that is used for the :data:`~flask.g` instance.
+    #:
+    #: Example use cases for a custom class:
+    #:
+    #: 1. Store arbitrary attributes on flask.g.
+    #: 2. Add a property for lazy per-request database connectors.
+    #: 3. Return None instead of AttributeError on unexpected attributes.
+    #: 4. Raise exception if an unexpected attr is set, a "controlled" flask.g.
+    #:
+    #: In Flask 0.9 this property was called `request_globals_class` but it
+    #: was changed in 0.10 to :attr:`app_ctx_globals_class` because the
+    #: flask.g object is now application context scoped.
+    #:
+    #: .. versionadded:: 0.10
+    app_ctx_globals_class = _AppCtxGlobals
+
+    #: The class that is used for the ``config`` attribute of this app.
+    #: Defaults to :class:`~flask.Config`.
+    #:
+    #: Example use cases for a custom class:
+    #:
+    #: 1. Default values for certain config options.
+    #: 2. Access to config values through attributes in addition to keys.
+    #:
+    #: .. versionadded:: 0.11
+    config_class = Config
+
+    #: The testing flag.  Set this to ``True`` to enable the test mode of
+    #: Flask extensions (and in the future probably also Flask itself).
+    #: For example this might activate test helpers that have an
+    #: additional runtime cost which should not be enabled by default.
+    #:
+    #: If this is enabled and PROPAGATE_EXCEPTIONS is not changed from the
+    #: default it's implicitly enabled.
+    #:
+    #: This attribute can also be configured from the config with the
+    #: ``TESTING`` configuration key.  Defaults to ``False``.
+    testing = ConfigAttribute[bool]("TESTING")
+
+    #: If a secret key is set, cryptographic components can use this to
+    #: sign cookies and other things. Set this to a complex random value
+    #: when you want to use the secure cookie for instance.
+    #:
+    #: This attribute can also be configured from the config with the
+    #: :data:`SECRET_KEY` configuration key. Defaults to ``None``.
+    secret_key = ConfigAttribute[t.Union[str, bytes, None]]("SECRET_KEY")
+
+    #: A :class:`~datetime.timedelta` which is used to set the expiration
+    #: date of a permanent session.  The default is 31 days which makes a
+    #: permanent session survive for roughly one month.
+    #:
+    #: This attribute can also be configured from the config with the
+    #: ``PERMANENT_SESSION_LIFETIME`` configuration key.  Defaults to
+    #: ``timedelta(days=31)``
+    permanent_session_lifetime = ConfigAttribute[timedelta](
+        "PERMANENT_SESSION_LIFETIME",
+        get_converter=_make_timedelta,  # type: ignore[arg-type]
+    )
+
+    json_provider_class: type[JSONProvider] = DefaultJSONProvider
+    """A subclass of :class:`~flask.json.provider.JSONProvider`. An
+    instance is created and assigned to :attr:`app.json` when creating
+    the app.
+
+    The default, :class:`~flask.json.provider.DefaultJSONProvider`, uses
+    Python's built-in :mod:`json` library. A different provider can use
+    a different JSON library.
+
+    .. versionadded:: 2.2
+    """
+
+    #: Options that are passed to the Jinja environment in
+    #: :meth:`create_jinja_environment`. Changing these options after
+    #: the environment is created (accessing :attr:`jinja_env`) will
+    #: have no effect.
+    #:
+    #: .. versionchanged:: 1.1.0
+    #:     This is a ``dict`` instead of an ``ImmutableDict`` to allow
+    #:     easier configuration.
+    #:
+    jinja_options: dict[str, t.Any] = {}
+
+    #: The rule object to use for URL rules created.  This is used by
+    #: :meth:`add_url_rule`.  Defaults to :class:`werkzeug.routing.Rule`.
+    #:
+    #: .. versionadded:: 0.7
+    url_rule_class = Rule
+
+    #: The map object to use for storing the URL rules and routing
+    #: configuration parameters. Defaults to :class:`werkzeug.routing.Map`.
+    #:
+    #: .. versionadded:: 1.1.0
+    url_map_class = Map
+
+    #: The :meth:`test_client` method creates an instance of this test
+    #: client class. Defaults to :class:`~flask.testing.FlaskClient`.
+    #:
+    #: .. versionadded:: 0.7
+    test_client_class: type[FlaskClient] | None = None
+
+    #: The :class:`~click.testing.CliRunner` subclass, by default
+    #: :class:`~flask.testing.FlaskCliRunner` that is used by
+    #: :meth:`test_cli_runner`. Its ``__init__`` method should take a
+    #: Flask app object as the first argument.
+    #:
+    #: .. versionadded:: 1.0
+    test_cli_runner_class: type[FlaskCliRunner] | None = None
+
+    default_config: dict[str, t.Any]
+    response_class: type[Response]
+
+    def __init__(
+        self,
+        import_name: str,
+        static_url_path: str | None = None,
+        static_folder: str | os.PathLike[str] | None = "static",
+        static_host: str | None = None,
+        host_matching: bool = False,
+        subdomain_matching: bool = False,
+        template_folder: str | os.PathLike[str] | None = "templates",
+        instance_path: str | None = None,
+        instance_relative_config: bool = False,
+        root_path: str | None = None,
+    ):
+        super().__init__(
+            import_name=import_name,
+            static_folder=static_folder,
+            static_url_path=static_url_path,
+            template_folder=template_folder,
+            root_path=root_path,
+        )
+
+        if instance_path is None:
+            instance_path = self.auto_find_instance_path()
+        elif not os.path.isabs(instance_path):
+            raise ValueError(
+                "If an instance path is provided it must be absolute."
+                " A relative path was given instead."
+            )
+
+        #: Holds the path to the instance folder.
+        #:
+        #: .. versionadded:: 0.8
+        self.instance_path = instance_path
+
+        #: The configuration dictionary as :class:`Config`.  This behaves
+        #: exactly like a regular dictionary but supports additional methods
+        #: to load a config from files.
+        self.config = self.make_config(instance_relative_config)
+
+        #: An instance of :attr:`aborter_class` created by
+        #: :meth:`make_aborter`. This is called by :func:`flask.abort`
+        #: to raise HTTP errors, and can be called directly as well.
+        #:
+        #: .. versionadded:: 2.2
+        #:     Moved from ``flask.abort``, which calls this object.
+        self.aborter = self.make_aborter()
+
+        self.json: JSONProvider = self.json_provider_class(self)
+        """Provides access to JSON methods. Functions in ``flask.json``
+        will call methods on this provider when the application context
+        is active. Used for handling JSON requests and responses.
+
+        An instance of :attr:`json_provider_class`. Can be customized by
+        changing that attribute on a subclass, or by assigning to this
+        attribute afterwards.
+
+        The default, :class:`~flask.json.provider.DefaultJSONProvider`,
+        uses Python's built-in :mod:`json` library. A different provider
+        can use a different JSON library.
+
+        .. versionadded:: 2.2
+        """
+
+        #: A list of functions that are called by
+        #: :meth:`handle_url_build_error` when :meth:`.url_for` raises a
+        #: :exc:`~werkzeug.routing.BuildError`. Each function is called
+        #: with ``error``, ``endpoint`` and ``values``. If a function
+        #: returns ``None`` or raises a ``BuildError``, it is skipped.
+        #: Otherwise, its return value is returned by ``url_for``.
+        #:
+        #: .. versionadded:: 0.9
+        self.url_build_error_handlers: list[
+            t.Callable[[Exception, str, dict[str, t.Any]], str]
+        ] = []
+
+        #: A list of functions that are called when the application context
+        #: is destroyed.  Since the application context is also torn down
+        #: if the request ends this is the place to store code that disconnects
+        #: from databases.
+        #:
+        #: .. versionadded:: 0.9
+        self.teardown_appcontext_funcs: list[ft.TeardownCallable] = []
+
+        #: A list of shell context processor functions that should be run
+        #: when a shell context is created.
+        #:
+        #: .. versionadded:: 0.11
+        self.shell_context_processors: list[ft.ShellContextProcessorCallable] = []
+
+        #: Maps registered blueprint names to blueprint objects. The
+        #: dict retains the order the blueprints were registered in.
+        #: Blueprints can be registered multiple times, this dict does
+        #: not track how often they were attached.
+        #:
+        #: .. versionadded:: 0.7
+        self.blueprints: dict[str, Blueprint] = {}
+
+        #: a place where extensions can store application specific state.  For
+        #: example this is where an extension could store database engines and
+        #: similar things.
+        #:
+        #: The key must match the name of the extension module. For example in
+        #: case of a "Flask-Foo" extension in `flask_foo`, the key would be
+        #: ``'foo'``.
+        #:
+        #: .. versionadded:: 0.7
+        self.extensions: dict[str, t.Any] = {}
+
+        #: The :class:`~werkzeug.routing.Map` for this instance.  You can use
+        #: this to change the routing converters after the class was created
+        #: but before any routes are connected.  Example::
+        #:
+        #:    from werkzeug.routing import BaseConverter
+        #:
+        #:    class ListConverter(BaseConverter):
+        #:        def to_python(self, value):
+        #:            return value.split(',')
+        #:        def to_url(self, values):
+        #:            return ','.join(super(ListConverter, self).to_url(value)
+        #:                            for value in values)
+        #:
+        #:    app = Flask(__name__)
+        #:    app.url_map.converters['list'] = ListConverter
+        self.url_map = self.url_map_class(host_matching=host_matching)
+
+        self.subdomain_matching = subdomain_matching
+
+        # tracks internally if the application already handled at least one
+        # request.
+        self._got_first_request = False
+
+        # Set the name of the Click group in case someone wants to add
+        # the app's commands to another CLI tool.
+        self.cli.name = self.name
+
+    def _check_setup_finished(self, f_name: str) -> None:
+        if self._got_first_request:
+            raise AssertionError(
+                f"The setup method '{f_name}' can no longer be called"
+                " on the application. It has already handled its first"
+                " request, any changes will not be applied"
+                " consistently.\n"
+                "Make sure all imports, decorators, functions, etc."
+                " needed to set up the application are done before"
+                " running it."
+            )
+
+    @cached_property
+    def name(self) -> str:  # type: ignore
+        """The name of the application.  This is usually the import name
+        with the difference that it's guessed from the run file if the
+        import name is main.  This name is used as a display name when
+        Flask needs the name of the application.  It can be set and overridden
+        to change the value.
+
+        .. versionadded:: 0.8
+        """
+        if self.import_name == "__main__":
+            fn: str | None = getattr(sys.modules["__main__"], "__file__", None)
+            if fn is None:
+                return "__main__"
+            return os.path.splitext(os.path.basename(fn))[0]
+        return self.import_name
+
+    @cached_property
+    def logger(self) -> logging.Logger:
+        """A standard Python :class:`~logging.Logger` for the app, with
+        the same name as :attr:`name`.
+
+        In debug mode, the logger's :attr:`~logging.Logger.level` will
+        be set to :data:`~logging.DEBUG`.
+
+        If there are no handlers configured, a default handler will be
+        added. See :doc:`/logging` for more information.
+
+        .. versionchanged:: 1.1.0
+            The logger takes the same name as :attr:`name` rather than
+            hard-coding ``"flask.app"``.
+
+        .. versionchanged:: 1.0.0
+            Behavior was simplified. The logger is always named
+            ``"flask.app"``. The level is only set during configuration,
+            it doesn't check ``app.debug`` each time. Only one format is
+            used, not different ones depending on ``app.debug``. No
+            handlers are removed, and a handler is only added if no
+            handlers are already configured.
+
+        .. versionadded:: 0.3
+        """
+        return create_logger(self)
+
+    @cached_property
+    def jinja_env(self) -> Environment:
+        """The Jinja environment used to load templates.
+
+        The environment is created the first time this property is
+        accessed. Changing :attr:`jinja_options` after that will have no
+        effect.
+        """
+        return self.create_jinja_environment()
+
+    def create_jinja_environment(self) -> Environment:
+        raise NotImplementedError()
+
+    def make_config(self, instance_relative: bool = False) -> Config:
+        """Used to create the config attribute by the Flask constructor.
+        The `instance_relative` parameter is passed in from the constructor
+        of Flask (there named `instance_relative_config`) and indicates if
+        the config should be relative to the instance path or the root path
+        of the application.
+
+        .. versionadded:: 0.8
+        """
+        root_path = self.root_path
+        if instance_relative:
+            root_path = self.instance_path
+        defaults = dict(self.default_config)
+        defaults["DEBUG"] = get_debug_flag()
+        return self.config_class(root_path, defaults)
+
+    def make_aborter(self) -> Aborter:
+        """Create the object to assign to :attr:`aborter`. That object
+        is called by :func:`flask.abort` to raise HTTP errors, and can
+        be called directly as well.
+
+        By default, this creates an instance of :attr:`aborter_class`,
+        which defaults to :class:`werkzeug.exceptions.Aborter`.
+
+        .. versionadded:: 2.2
+        """
+        return self.aborter_class()
+
+    def auto_find_instance_path(self) -> str:
+        """Tries to locate the instance path if it was not provided to the
+        constructor of the application class.  It will basically calculate
+        the path to a folder named ``instance`` next to your main file or
+        the package.
+
+        .. versionadded:: 0.8
+        """
+        prefix, package_path = find_package(self.import_name)
+        if prefix is None:
+            return os.path.join(package_path, "instance")
+        return os.path.join(prefix, "var", f"{self.name}-instance")
+
+    def create_global_jinja_loader(self) -> DispatchingJinjaLoader:
+        """Creates the loader for the Jinja2 environment.  Can be used to
+        override just the loader and keeping the rest unchanged.  It's
+        discouraged to override this function.  Instead one should override
+        the :meth:`jinja_loader` function instead.
+
+        The global loader dispatches between the loaders of the application
+        and the individual blueprints.
+
+        .. versionadded:: 0.7
+        """
+        return DispatchingJinjaLoader(self)
+
+    def select_jinja_autoescape(self, filename: str) -> bool:
+        """Returns ``True`` if autoescaping should be active for the given
+        template name. If no template name is given, returns `True`.
+
+        .. versionchanged:: 2.2
+            Autoescaping is now enabled by default for ``.svg`` files.
+
+        .. versionadded:: 0.5
+        """
+        if filename is None:
+            return True
+        return filename.endswith((".html", ".htm", ".xml", ".xhtml", ".svg"))
+
+    @property
+    def debug(self) -> bool:
+        """Whether debug mode is enabled. When using ``flask run`` to start the
+        development server, an interactive debugger will be shown for unhandled
+        exceptions, and the server will be reloaded when code changes. This maps to the
+        :data:`DEBUG` config key. It may not behave as expected if set late.
+
+        **Do not enable debug mode when deploying in production.**
+
+        Default: ``False``
+        """
+        return self.config["DEBUG"]  # type: ignore[no-any-return]
+
+    @debug.setter
+    def debug(self, value: bool) -> None:
+        self.config["DEBUG"] = value
+
+        if self.config["TEMPLATES_AUTO_RELOAD"] is None:
+            self.jinja_env.auto_reload = value
+
+    @setupmethod
+    def register_blueprint(self, blueprint: Blueprint, **options: t.Any) -> None:
+        """Register a :class:`~flask.Blueprint` on the application. Keyword
+        arguments passed to this method will override the defaults set on the
+        blueprint.
+
+        Calls the blueprint's :meth:`~flask.Blueprint.register` method after
+        recording the blueprint in the application's :attr:`blueprints`.
+
+        :param blueprint: The blueprint to register.
+        :param url_prefix: Blueprint routes will be prefixed with this.
+        :param subdomain: Blueprint routes will match on this subdomain.
+        :param url_defaults: Blueprint routes will use these default values for
+            view arguments.
+        :param options: Additional keyword arguments are passed to
+            :class:`~flask.blueprints.BlueprintSetupState`. They can be
+            accessed in :meth:`~flask.Blueprint.record` callbacks.
+
+        .. versionchanged:: 2.0.1
+            The ``name`` option can be used to change the (pre-dotted)
+            name the blueprint is registered with. This allows the same
+            blueprint to be registered multiple times with unique names
+            for ``url_for``.
+
+        .. versionadded:: 0.7
+        """
+        blueprint.register(self, options)
+
+    def iter_blueprints(self) -> t.ValuesView[Blueprint]:
+        """Iterates over all blueprints by the order they were registered.
+
+        .. versionadded:: 0.11
+        """
+        return self.blueprints.values()
+
+    @setupmethod
+    def add_url_rule(
+        self,
+        rule: str,
+        endpoint: str | None = None,
+        view_func: ft.RouteCallable | None = None,
+        provide_automatic_options: bool | None = None,
+        **options: t.Any,
+    ) -> None:
+        if endpoint is None:
+            endpoint = _endpoint_from_view_func(view_func)  # type: ignore
+        options["endpoint"] = endpoint
+        methods = options.pop("methods", None)
+
+        # if the methods are not given and the view_func object knows its
+        # methods we can use that instead.  If neither exists, we go with
+        # a tuple of only ``GET`` as default.
+        if methods is None:
+            methods = getattr(view_func, "methods", None) or ("GET",)
+        if isinstance(methods, str):
+            raise TypeError(
+                "Allowed methods must be a list of strings, for"
+                ' example: @app.route(..., methods=["POST"])'
+            )
+        methods = {item.upper() for item in methods}
+
+        # Methods that should always be added
+        required_methods = set(getattr(view_func, "required_methods", ()))
+
+        # starting with Flask 0.8 the view_func object can disable and
+        # force-enable the automatic options handling.
+        if provide_automatic_options is None:
+            provide_automatic_options = getattr(
+                view_func, "provide_automatic_options", None
+            )
+
+        if provide_automatic_options is None:
+            if "OPTIONS" not in methods:
+                provide_automatic_options = True
+                required_methods.add("OPTIONS")
+            else:
+                provide_automatic_options = False
+
+        # Add the required methods now.
+        methods |= required_methods
+
+        rule_obj = self.url_rule_class(rule, methods=methods, **options)
+        rule_obj.provide_automatic_options = provide_automatic_options  # type: ignore[attr-defined]
+
+        self.url_map.add(rule_obj)
+        if view_func is not None:
+            old_func = self.view_functions.get(endpoint)
+            if old_func is not None and old_func != view_func:
+                raise AssertionError(
+                    "View function mapping is overwriting an existing"
+                    f" endpoint function: {endpoint}"
+                )
+            self.view_functions[endpoint] = view_func
+
+    @setupmethod
+    def template_filter(
+        self, name: str | None = None
+    ) -> t.Callable[[T_template_filter], T_template_filter]:
+        """A decorator that is used to register custom template filter.
+        You can specify a name for the filter, otherwise the function
+        name will be used. Example::
+
+          @app.template_filter()
+          def reverse(s):
+              return s[::-1]
+
+        :param name: the optional name of the filter, otherwise the
+                     function name will be used.
+        """
+
+        def decorator(f: T_template_filter) -> T_template_filter:
+            self.add_template_filter(f, name=name)
+            return f
+
+        return decorator
+
+    @setupmethod
+    def add_template_filter(
+        self, f: ft.TemplateFilterCallable, name: str | None = None
+    ) -> None:
+        """Register a custom template filter.  Works exactly like the
+        :meth:`template_filter` decorator.
+
+        :param name: the optional name of the filter, otherwise the
+                     function name will be used.
+        """
+        self.jinja_env.filters[name or f.__name__] = f
+
+    @setupmethod
+    def template_test(
+        self, name: str | None = None
+    ) -> t.Callable[[T_template_test], T_template_test]:
+        """A decorator that is used to register custom template test.
+        You can specify a name for the test, otherwise the function
+        name will be used. Example::
+
+          @app.template_test()
+          def is_prime(n):
+              if n == 2:
+                  return True
+              for i in range(2, int(math.ceil(math.sqrt(n))) + 1):
+                  if n % i == 0:
+                      return False
+              return True
+
+        .. versionadded:: 0.10
+
+        :param name: the optional name of the test, otherwise the
+                     function name will be used.
+        """
+
+        def decorator(f: T_template_test) -> T_template_test:
+            self.add_template_test(f, name=name)
+            return f
+
+        return decorator
+
+    @setupmethod
+    def add_template_test(
+        self, f: ft.TemplateTestCallable, name: str | None = None
+    ) -> None:
+        """Register a custom template test.  Works exactly like the
+        :meth:`template_test` decorator.
+
+        .. versionadded:: 0.10
+
+        :param name: the optional name of the test, otherwise the
+                     function name will be used.
+        """
+        self.jinja_env.tests[name or f.__name__] = f
+
+    @setupmethod
+    def template_global(
+        self, name: str | None = None
+    ) -> t.Callable[[T_template_global], T_template_global]:
+        """A decorator that is used to register a custom template global function.
+        You can specify a name for the global function, otherwise the function
+        name will be used. Example::
+
+            @app.template_global()
+            def double(n):
+                return 2 * n
+
+        .. versionadded:: 0.10
+
+        :param name: the optional name of the global function, otherwise the
+                     function name will be used.
+        """
+
+        def decorator(f: T_template_global) -> T_template_global:
+            self.add_template_global(f, name=name)
+            return f
+
+        return decorator
+
+    @setupmethod
+    def add_template_global(
+        self, f: ft.TemplateGlobalCallable, name: str | None = None
+    ) -> None:
+        """Register a custom template global function. Works exactly like the
+        :meth:`template_global` decorator.
+
+        .. versionadded:: 0.10
+
+        :param name: the optional name of the global function, otherwise the
+                     function name will be used.
+        """
+        self.jinja_env.globals[name or f.__name__] = f
+
+    @setupmethod
+    def teardown_appcontext(self, f: T_teardown) -> T_teardown:
+        """Registers a function to be called when the application
+        context is popped. The application context is typically popped
+        after the request context for each request, at the end of CLI
+        commands, or after a manually pushed context ends.
+
+        .. code-block:: python
+
+            with app.app_context():
+                ...
+
+        When the ``with`` block exits (or ``ctx.pop()`` is called), the
+        teardown functions are called just before the app context is
+        made inactive. Since a request context typically also manages an
+        application context it would also be called when you pop a
+        request context.
+
+        When a teardown function was called because of an unhandled
+        exception it will be passed an error object. If an
+        :meth:`errorhandler` is registered, it will handle the exception
+        and the teardown will not receive it.
+
+        Teardown functions must avoid raising exceptions. If they
+        execute code that might fail they must surround that code with a
+        ``try``/``except`` block and log any errors.
+
+        The return values of teardown functions are ignored.
+
+        .. versionadded:: 0.9
+        """
+        self.teardown_appcontext_funcs.append(f)
+        return f
+
+    @setupmethod
+    def shell_context_processor(
+        self, f: T_shell_context_processor
+    ) -> T_shell_context_processor:
+        """Registers a shell context processor function.
+
+        .. versionadded:: 0.11
+        """
+        self.shell_context_processors.append(f)
+        return f
+
+    def _find_error_handler(
+        self, e: Exception, blueprints: list[str]
+    ) -> ft.ErrorHandlerCallable | None:
+        """Return a registered error handler for an exception in this order:
+        blueprint handler for a specific code, app handler for a specific code,
+        blueprint handler for an exception class, app handler for an exception
+        class, or ``None`` if a suitable handler is not found.
+        """
+        exc_class, code = self._get_exc_class_and_code(type(e))
+        names = (*blueprints, None)
+
+        for c in (code, None) if code is not None else (None,):
+            for name in names:
+                handler_map = self.error_handler_spec[name][c]
+
+                if not handler_map:
+                    continue
+
+                for cls in exc_class.__mro__:
+                    handler = handler_map.get(cls)
+
+                    if handler is not None:
+                        return handler
+        return None
+
+    def trap_http_exception(self, e: Exception) -> bool:
+        """Checks if an HTTP exception should be trapped or not.  By default
+        this will return ``False`` for all exceptions except for a bad request
+        key error if ``TRAP_BAD_REQUEST_ERRORS`` is set to ``True``.  It
+        also returns ``True`` if ``TRAP_HTTP_EXCEPTIONS`` is set to ``True``.
+
+        This is called for all HTTP exceptions raised by a view function.
+        If it returns ``True`` for any exception the error handler for this
+        exception is not called and it shows up as regular exception in the
+        traceback.  This is helpful for debugging implicitly raised HTTP
+        exceptions.
+
+        .. versionchanged:: 1.0
+            Bad request errors are not trapped by default in debug mode.
+
+        .. versionadded:: 0.8
+        """
+        if self.config["TRAP_HTTP_EXCEPTIONS"]:
+            return True
+
+        trap_bad_request = self.config["TRAP_BAD_REQUEST_ERRORS"]
+
+        # if unset, trap key errors in debug mode
+        if (
+            trap_bad_request is None
+            and self.debug
+            and isinstance(e, BadRequestKeyError)
+        ):
+            return True
+
+        if trap_bad_request:
+            return isinstance(e, BadRequest)
+
+        return False
+
+    def should_ignore_error(self, error: BaseException | None) -> bool:
+        """This is called to figure out if an error should be ignored
+        or not as far as the teardown system is concerned.  If this
+        function returns ``True`` then the teardown handlers will not be
+        passed the error.
+
+        .. versionadded:: 0.10
+        """
+        return False
+
+    def redirect(self, location: str, code: int = 302) -> BaseResponse:
+        """Create a redirect response object.
+
+        This is called by :func:`flask.redirect`, and can be called
+        directly as well.
+
+        :param location: The URL to redirect to.
+        :param code: The status code for the redirect.
+
+        .. versionadded:: 2.2
+            Moved from ``flask.redirect``, which calls this method.
+        """
+        return _wz_redirect(
+            location,
+            code=code,
+            Response=self.response_class,  # type: ignore[arg-type]
+        )
+
+    def inject_url_defaults(self, endpoint: str, values: dict[str, t.Any]) -> None:
+        """Injects the URL defaults for the given endpoint directly into
+        the values dictionary passed.  This is used internally and
+        automatically called on URL building.
+
+        .. versionadded:: 0.7
+        """
+        names: t.Iterable[str | None] = (None,)
+
+        # url_for may be called outside a request context, parse the
+        # passed endpoint instead of using request.blueprints.
+        if "." in endpoint:
+            names = chain(
+                names, reversed(_split_blueprint_path(endpoint.rpartition(".")[0]))
+            )
+
+        for name in names:
+            if name in self.url_default_functions:
+                for func in self.url_default_functions[name]:
+                    func(endpoint, values)
+
+    def handle_url_build_error(
+        self, error: BuildError, endpoint: str, values: dict[str, t.Any]
+    ) -> str:
+        """Called by :meth:`.url_for` if a
+        :exc:`~werkzeug.routing.BuildError` was raised. If this returns
+        a value, it will be returned by ``url_for``, otherwise the error
+        will be re-raised.
+
+        Each function in :attr:`url_build_error_handlers` is called with
+        ``error``, ``endpoint`` and ``values``. If a function returns
+        ``None`` or raises a ``BuildError``, it is skipped. Otherwise,
+        its return value is returned by ``url_for``.
+
+        :param error: The active ``BuildError`` being handled.
+        :param endpoint: The endpoint being built.
+        :param values: The keyword arguments passed to ``url_for``.
+        """
+        for handler in self.url_build_error_handlers:
+            try:
+                rv = handler(error, endpoint, values)
+            except BuildError as e:
+                # make error available outside except block
+                error = e
+            else:
+                if rv is not None:
+                    return rv
+
+        # Re-raise if called with an active exception, otherwise raise
+        # the passed in exception.
+        if error is sys.exc_info()[1]:
+            raise
+
+        raise error
diff --git a/src/flask/sansio/blueprints.py b/src/flask/sansio/blueprints.py
new file mode 100644
index 00000000..4f912cca
--- /dev/null
+++ b/src/flask/sansio/blueprints.py
@@ -0,0 +1,632 @@
+from __future__ import annotations
+
+import os
+import typing as t
+from collections import defaultdict
+from functools import update_wrapper
+
+from .. import typing as ft
+from .scaffold import _endpoint_from_view_func
+from .scaffold import _sentinel
+from .scaffold import Scaffold
+from .scaffold import setupmethod
+
+if t.TYPE_CHECKING:  # pragma: no cover
+    from .app import App
+
+DeferredSetupFunction = t.Callable[["BlueprintSetupState"], None]
+T_after_request = t.TypeVar("T_after_request", bound=ft.AfterRequestCallable[t.Any])
+T_before_request = t.TypeVar("T_before_request", bound=ft.BeforeRequestCallable)
+T_error_handler = t.TypeVar("T_error_handler", bound=ft.ErrorHandlerCallable)
+T_teardown = t.TypeVar("T_teardown", bound=ft.TeardownCallable)
+T_template_context_processor = t.TypeVar(
+    "T_template_context_processor", bound=ft.TemplateContextProcessorCallable
+)
+T_template_filter = t.TypeVar("T_template_filter", bound=ft.TemplateFilterCallable)
+T_template_global = t.TypeVar("T_template_global", bound=ft.TemplateGlobalCallable)
+T_template_test = t.TypeVar("T_template_test", bound=ft.TemplateTestCallable)
+T_url_defaults = t.TypeVar("T_url_defaults", bound=ft.URLDefaultCallable)
+T_url_value_preprocessor = t.TypeVar(
+    "T_url_value_preprocessor", bound=ft.URLValuePreprocessorCallable
+)
+
+
+class BlueprintSetupState:
+    """Temporary holder object for registering a blueprint with the
+    application.  An instance of this class is created by the
+    :meth:`~flask.Blueprint.make_setup_state` method and later passed
+    to all register callback functions.
+    """
+
+    def __init__(
+        self,
+        blueprint: Blueprint,
+        app: App,
+        options: t.Any,
+        first_registration: bool,
+    ) -> None:
+        #: a reference to the current application
+        self.app = app
+
+        #: a reference to the blueprint that created this setup state.
+        self.blueprint = blueprint
+
+        #: a dictionary with all options that were passed to the
+        #: :meth:`~flask.Flask.register_blueprint` method.
+        self.options = options
+
+        #: as blueprints can be registered multiple times with the
+        #: application and not everything wants to be registered
+        #: multiple times on it, this attribute can be used to figure
+        #: out if the blueprint was registered in the past already.
+        self.first_registration = first_registration
+
+        subdomain = self.options.get("subdomain")
+        if subdomain is None:
+            subdomain = self.blueprint.subdomain
+
+        #: The subdomain that the blueprint should be active for, ``None``
+        #: otherwise.
+        self.subdomain = subdomain
+
+        url_prefix = self.options.get("url_prefix")
+        if url_prefix is None:
+            url_prefix = self.blueprint.url_prefix
+        #: The prefix that should be used for all URLs defined on the
+        #: blueprint.
+        self.url_prefix = url_prefix
+
+        self.name = self.options.get("name", blueprint.name)
+        self.name_prefix = self.options.get("name_prefix", "")
+
+        #: A dictionary with URL defaults that is added to each and every
+        #: URL that was defined with the blueprint.
+        self.url_defaults = dict(self.blueprint.url_values_defaults)
+        self.url_defaults.update(self.options.get("url_defaults", ()))
+
+    def add_url_rule(
+        self,
+        rule: str,
+        endpoint: str | None = None,
+        view_func: ft.RouteCallable | None = None,
+        **options: t.Any,
+    ) -> None:
+        """A helper method to register a rule (and optionally a view function)
+        to the application.  The endpoint is automatically prefixed with the
+        blueprint's name.
+        """
+        if self.url_prefix is not None:
+            if rule:
+                rule = "/".join((self.url_prefix.rstrip("/"), rule.lstrip("/")))
+            else:
+                rule = self.url_prefix
+        options.setdefault("subdomain", self.subdomain)
+        if endpoint is None:
+            endpoint = _endpoint_from_view_func(view_func)  # type: ignore
+        defaults = self.url_defaults
+        if "defaults" in options:
+            defaults = dict(defaults, **options.pop("defaults"))
+
+        self.app.add_url_rule(
+            rule,
+            f"{self.name_prefix}.{self.name}.{endpoint}".lstrip("."),
+            view_func,
+            defaults=defaults,
+            **options,
+        )
+
+
+class Blueprint(Scaffold):
+    """Represents a blueprint, a collection of routes and other
+    app-related functions that can be registered on a real application
+    later.
+
+    A blueprint is an object that allows defining application functions
+    without requiring an application object ahead of time. It uses the
+    same decorators as :class:`~flask.Flask`, but defers the need for an
+    application by recording them for later registration.
+
+    Decorating a function with a blueprint creates a deferred function
+    that is called with :class:`~flask.blueprints.BlueprintSetupState`
+    when the blueprint is registered on an application.
+
+    See :doc:`/blueprints` for more information.
+
+    :param name: The name of the blueprint. Will be prepended to each
+        endpoint name.
+    :param import_name: The name of the blueprint package, usually
+        ``__name__``. This helps locate the ``root_path`` for the
+        blueprint.
+    :param static_folder: A folder with static files that should be
+        served by the blueprint's static route. The path is relative to
+        the blueprint's root path. Blueprint static files are disabled
+        by default.
+    :param static_url_path: The url to serve static files from.
+        Defaults to ``static_folder``. If the blueprint does not have
+        a ``url_prefix``, the app's static route will take precedence,
+        and the blueprint's static files won't be accessible.
+    :param template_folder: A folder with templates that should be added
+        to the app's template search path. The path is relative to the
+        blueprint's root path. Blueprint templates are disabled by
+        default. Blueprint templates have a lower precedence than those
+        in the app's templates folder.
+    :param url_prefix: A path to prepend to all of the blueprint's URLs,
+        to make them distinct from the rest of the app's routes.
+    :param subdomain: A subdomain that blueprint routes will match on by
+        default.
+    :param url_defaults: A dict of default values that blueprint routes
+        will receive by default.
+    :param root_path: By default, the blueprint will automatically set
+        this based on ``import_name``. In certain situations this
+        automatic detection can fail, so the path can be specified
+        manually instead.
+
+    .. versionchanged:: 1.1.0
+        Blueprints have a ``cli`` group to register nested CLI commands.
+        The ``cli_group`` parameter controls the name of the group under
+        the ``flask`` command.
+
+    .. versionadded:: 0.7
+    """
+
+    _got_registered_once = False
+
+    def __init__(
+        self,
+        name: str,
+        import_name: str,
+        static_folder: str | os.PathLike[str] | None = None,
+        static_url_path: str | None = None,
+        template_folder: str | os.PathLike[str] | None = None,
+        url_prefix: str | None = None,
+        subdomain: str | None = None,
+        url_defaults: dict[str, t.Any] | None = None,
+        root_path: str | None = None,
+        cli_group: str | None = _sentinel,  # type: ignore[assignment]
+    ):
+        super().__init__(
+            import_name=import_name,
+            static_folder=static_folder,
+            static_url_path=static_url_path,
+            template_folder=template_folder,
+            root_path=root_path,
+        )
+
+        if not name:
+            raise ValueError("'name' may not be empty.")
+
+        if "." in name:
+            raise ValueError("'name' may not contain a dot '.' character.")
+
+        self.name = name
+        self.url_prefix = url_prefix
+        self.subdomain = subdomain
+        self.deferred_functions: list[DeferredSetupFunction] = []
+
+        if url_defaults is None:
+            url_defaults = {}
+
+        self.url_values_defaults = url_defaults
+        self.cli_group = cli_group
+        self._blueprints: list[tuple[Blueprint, dict[str, t.Any]]] = []
+
+    def _check_setup_finished(self, f_name: str) -> None:
+        if self._got_registered_once:
+            raise AssertionError(
+                f"The setup method '{f_name}' can no longer be called on the blueprint"
+                f" '{self.name}'. It has already been registered at least once, any"
+                " changes will not be applied consistently.\n"
+                "Make sure all imports, decorators, functions, etc. needed to set up"
+                " the blueprint are done before registering it."
+            )
+
+    @setupmethod
+    def record(self, func: DeferredSetupFunction) -> None:
+        """Registers a function that is called when the blueprint is
+        registered on the application.  This function is called with the
+        state as argument as returned by the :meth:`make_setup_state`
+        method.
+        """
+        self.deferred_functions.append(func)
+
+    @setupmethod
+    def record_once(self, func: DeferredSetupFunction) -> None:
+        """Works like :meth:`record` but wraps the function in another
+        function that will ensure the function is only called once.  If the
+        blueprint is registered a second time on the application, the
+        function passed is not called.
+        """
+
+        def wrapper(state: BlueprintSetupState) -> None:
+            if state.first_registration:
+                func(state)
+
+        self.record(update_wrapper(wrapper, func))
+
+    def make_setup_state(
+        self, app: App, options: dict[str, t.Any], first_registration: bool = False
+    ) -> BlueprintSetupState:
+        """Creates an instance of :meth:`~flask.blueprints.BlueprintSetupState`
+        object that is later passed to the register callback functions.
+        Subclasses can override this to return a subclass of the setup state.
+        """
+        return BlueprintSetupState(self, app, options, first_registration)
+
+    @setupmethod
+    def register_blueprint(self, blueprint: Blueprint, **options: t.Any) -> None:
+        """Register a :class:`~flask.Blueprint` on this blueprint. Keyword
+        arguments passed to this method will override the defaults set
+        on the blueprint.
+
+        .. versionchanged:: 2.0.1
+            The ``name`` option can be used to change the (pre-dotted)
+            name the blueprint is registered with. This allows the same
+            blueprint to be registered multiple times with unique names
+            for ``url_for``.
+
+        .. versionadded:: 2.0
+        """
+        if blueprint is self:
+            raise ValueError("Cannot register a blueprint on itself")
+        self._blueprints.append((blueprint, options))
+
+    def register(self, app: App, options: dict[str, t.Any]) -> None:
+        """Called by :meth:`Flask.register_blueprint` to register all
+        views and callbacks registered on the blueprint with the
+        application. Creates a :class:`.BlueprintSetupState` and calls
+        each :meth:`record` callback with it.
+
+        :param app: The application this blueprint is being registered
+            with.
+        :param options: Keyword arguments forwarded from
+            :meth:`~Flask.register_blueprint`.
+
+        .. versionchanged:: 2.3
+            Nested blueprints now correctly apply subdomains.
+
+        .. versionchanged:: 2.1
+            Registering the same blueprint with the same name multiple
+            times is an error.
+
+        .. versionchanged:: 2.0.1
+            Nested blueprints are registered with their dotted name.
+            This allows different blueprints with the same name to be
+            nested at different locations.
+
+        .. versionchanged:: 2.0.1
+            The ``name`` option can be used to change the (pre-dotted)
+            name the blueprint is registered with. This allows the same
+            blueprint to be registered multiple times with unique names
+            for ``url_for``.
+        """
+        name_prefix = options.get("name_prefix", "")
+        self_name = options.get("name", self.name)
+        name = f"{name_prefix}.{self_name}".lstrip(".")
+
+        if name in app.blueprints:
+            bp_desc = "this" if app.blueprints[name] is self else "a different"
+            existing_at = f" '{name}'" if self_name != name else ""
+
+            raise ValueError(
+                f"The name '{self_name}' is already registered for"
+                f" {bp_desc} blueprint{existing_at}. Use 'name=' to"
+                f" provide a unique name."
+            )
+
+        first_bp_registration = not any(bp is self for bp in app.blueprints.values())
+        first_name_registration = name not in app.blueprints
+
+        app.blueprints[name] = self
+        self._got_registered_once = True
+        state = self.make_setup_state(app, options, first_bp_registration)
+
+        if self.has_static_folder:
+            state.add_url_rule(
+                f"{self.static_url_path}/<path:filename>",
+                view_func=self.send_static_file,  # type: ignore[attr-defined]
+                endpoint="static",
+            )
+
+        # Merge blueprint data into parent.
+        if first_bp_registration or first_name_registration:
+            self._merge_blueprint_funcs(app, name)
+
+        for deferred in self.deferred_functions:
+            deferred(state)
+
+        cli_resolved_group = options.get("cli_group", self.cli_group)
+
+        if self.cli.commands:
+            if cli_resolved_group is None:
+                app.cli.commands.update(self.cli.commands)
+            elif cli_resolved_group is _sentinel:
+                self.cli.name = name
+                app.cli.add_command(self.cli)
+            else:
+                self.cli.name = cli_resolved_group
+                app.cli.add_command(self.cli)
+
+        for blueprint, bp_options in self._blueprints:
+            bp_options = bp_options.copy()
+            bp_url_prefix = bp_options.get("url_prefix")
+            bp_subdomain = bp_options.get("subdomain")
+
+            if bp_subdomain is None:
+                bp_subdomain = blueprint.subdomain
+
+            if state.subdomain is not None and bp_subdomain is not None:
+                bp_options["subdomain"] = bp_subdomain + "." + state.subdomain
+            elif bp_subdomain is not None:
+                bp_options["subdomain"] = bp_subdomain
+            elif state.subdomain is not None:
+                bp_options["subdomain"] = state.subdomain
+
+            if bp_url_prefix is None:
+                bp_url_prefix = blueprint.url_prefix
+
+            if state.url_prefix is not None and bp_url_prefix is not None:
+                bp_options["url_prefix"] = (
+                    state.url_prefix.rstrip("/") + "/" + bp_url_prefix.lstrip("/")
+                )
+            elif bp_url_prefix is not None:
+                bp_options["url_prefix"] = bp_url_prefix
+            elif state.url_prefix is not None:
+                bp_options["url_prefix"] = state.url_prefix
+
+            bp_options["name_prefix"] = name
+            blueprint.register(app, bp_options)
+
+    def _merge_blueprint_funcs(self, app: App, name: str) -> None:
+        def extend(
+            bp_dict: dict[ft.AppOrBlueprintKey, list[t.Any]],
+            parent_dict: dict[ft.AppOrBlueprintKey, list[t.Any]],
+        ) -> None:
+            for key, values in bp_dict.items():
+                key = name if key is None else f"{name}.{key}"
+                parent_dict[key].extend(values)
+
+        for key, value in self.error_handler_spec.items():
+            key = name if key is None else f"{name}.{key}"
+            value = defaultdict(
+                dict,
+                {
+                    code: {exc_class: func for exc_class, func in code_values.items()}
+                    for code, code_values in value.items()
+                },
+            )
+            app.error_handler_spec[key] = value
+
+        for endpoint, func in self.view_functions.items():
+            app.view_functions[endpoint] = func
+
+        extend(self.before_request_funcs, app.before_request_funcs)
+        extend(self.after_request_funcs, app.after_request_funcs)
+        extend(
+            self.teardown_request_funcs,
+            app.teardown_request_funcs,
+        )
+        extend(self.url_default_functions, app.url_default_functions)
+        extend(self.url_value_preprocessors, app.url_value_preprocessors)
+        extend(self.template_context_processors, app.template_context_processors)
+
+    @setupmethod
+    def add_url_rule(
+        self,
+        rule: str,
+        endpoint: str | None = None,
+        view_func: ft.RouteCallable | None = None,
+        provide_automatic_options: bool | None = None,
+        **options: t.Any,
+    ) -> None:
+        """Register a URL rule with the blueprint. See :meth:`.Flask.add_url_rule` for
+        full documentation.
+
+        The URL rule is prefixed with the blueprint's URL prefix. The endpoint name,
+        used with :func:`url_for`, is prefixed with the blueprint's name.
+        """
+        if endpoint and "." in endpoint:
+            raise ValueError("'endpoint' may not contain a dot '.' character.")
+
+        if view_func and hasattr(view_func, "__name__") and "." in view_func.__name__:
+            raise ValueError("'view_func' name may not contain a dot '.' character.")
+
+        self.record(
+            lambda s: s.add_url_rule(
+                rule,
+                endpoint,
+                view_func,
+                provide_automatic_options=provide_automatic_options,
+                **options,
+            )
+        )
+
+    @setupmethod
+    def app_template_filter(
+        self, name: str | None = None
+    ) -> t.Callable[[T_template_filter], T_template_filter]:
+        """Register a template filter, available in any template rendered by the
+        application. Equivalent to :meth:`.Flask.template_filter`.
+
+        :param name: the optional name of the filter, otherwise the
+                     function name will be used.
+        """
+
+        def decorator(f: T_template_filter) -> T_template_filter:
+            self.add_app_template_filter(f, name=name)
+            return f
+
+        return decorator
+
+    @setupmethod
+    def add_app_template_filter(
+        self, f: ft.TemplateFilterCallable, name: str | None = None
+    ) -> None:
+        """Register a template filter, available in any template rendered by the
+        application. Works like the :meth:`app_template_filter` decorator. Equivalent to
+        :meth:`.Flask.add_template_filter`.
+
+        :param name: the optional name of the filter, otherwise the
+                     function name will be used.
+        """
+
+        def register_template(state: BlueprintSetupState) -> None:
+            state.app.jinja_env.filters[name or f.__name__] = f
+
+        self.record_once(register_template)
+
+    @setupmethod
+    def app_template_test(
+        self, name: str | None = None
+    ) -> t.Callable[[T_template_test], T_template_test]:
+        """Register a template test, available in any template rendered by the
+        application. Equivalent to :meth:`.Flask.template_test`.
+
+        .. versionadded:: 0.10
+
+        :param name: the optional name of the test, otherwise the
+                     function name will be used.
+        """
+
+        def decorator(f: T_template_test) -> T_template_test:
+            self.add_app_template_test(f, name=name)
+            return f
+
+        return decorator
+
+    @setupmethod
+    def add_app_template_test(
+        self, f: ft.TemplateTestCallable, name: str | None = None
+    ) -> None:
+        """Register a template test, available in any template rendered by the
+        application. Works like the :meth:`app_template_test` decorator. Equivalent to
+        :meth:`.Flask.add_template_test`.
+
+        .. versionadded:: 0.10
+
+        :param name: the optional name of the test, otherwise the
+                     function name will be used.
+        """
+
+        def register_template(state: BlueprintSetupState) -> None:
+            state.app.jinja_env.tests[name or f.__name__] = f
+
+        self.record_once(register_template)
+
+    @setupmethod
+    def app_template_global(
+        self, name: str | None = None
+    ) -> t.Callable[[T_template_global], T_template_global]:
+        """Register a template global, available in any template rendered by the
+        application. Equivalent to :meth:`.Flask.template_global`.
+
+        .. versionadded:: 0.10
+
+        :param name: the optional name of the global, otherwise the
+                     function name will be used.
+        """
+
+        def decorator(f: T_template_global) -> T_template_global:
+            self.add_app_template_global(f, name=name)
+            return f
+
+        return decorator
+
+    @setupmethod
+    def add_app_template_global(
+        self, f: ft.TemplateGlobalCallable, name: str | None = None
+    ) -> None:
+        """Register a template global, available in any template rendered by the
+        application. Works like the :meth:`app_template_global` decorator. Equivalent to
+        :meth:`.Flask.add_template_global`.
+
+        .. versionadded:: 0.10
+
+        :param name: the optional name of the global, otherwise the
+                     function name will be used.
+        """
+
+        def register_template(state: BlueprintSetupState) -> None:
+            state.app.jinja_env.globals[name or f.__name__] = f
+
+        self.record_once(register_template)
+
+    @setupmethod
+    def before_app_request(self, f: T_before_request) -> T_before_request:
+        """Like :meth:`before_request`, but before every request, not only those handled
+        by the blueprint. Equivalent to :meth:`.Flask.before_request`.
+        """
+        self.record_once(
+            lambda s: s.app.before_request_funcs.setdefault(None, []).append(f)
+        )
+        return f
+
+    @setupmethod
+    def after_app_request(self, f: T_after_request) -> T_after_request:
+        """Like :meth:`after_request`, but after every request, not only those handled
+        by the blueprint. Equivalent to :meth:`.Flask.after_request`.
+        """
+        self.record_once(
+            lambda s: s.app.after_request_funcs.setdefault(None, []).append(f)
+        )
+        return f
+
+    @setupmethod
+    def teardown_app_request(self, f: T_teardown) -> T_teardown:
+        """Like :meth:`teardown_request`, but after every request, not only those
+        handled by the blueprint. Equivalent to :meth:`.Flask.teardown_request`.
+        """
+        self.record_once(
+            lambda s: s.app.teardown_request_funcs.setdefault(None, []).append(f)
+        )
+        return f
+
+    @setupmethod
+    def app_context_processor(
+        self, f: T_template_context_processor
+    ) -> T_template_context_processor:
+        """Like :meth:`context_processor`, but for templates rendered by every view, not
+        only by the blueprint. Equivalent to :meth:`.Flask.context_processor`.
+        """
+        self.record_once(
+            lambda s: s.app.template_context_processors.setdefault(None, []).append(f)
+        )
+        return f
+
+    @setupmethod
+    def app_errorhandler(
+        self, code: type[Exception] | int
+    ) -> t.Callable[[T_error_handler], T_error_handler]:
+        """Like :meth:`errorhandler`, but for every request, not only those handled by
+        the blueprint. Equivalent to :meth:`.Flask.errorhandler`.
+        """
+
+        def decorator(f: T_error_handler) -> T_error_handler:
+            def from_blueprint(state: BlueprintSetupState) -> None:
+                state.app.errorhandler(code)(f)
+
+            self.record_once(from_blueprint)
+            return f
+
+        return decorator
+
+    @setupmethod
+    def app_url_value_preprocessor(
+        self, f: T_url_value_preprocessor
+    ) -> T_url_value_preprocessor:
+        """Like :meth:`url_value_preprocessor`, but for every request, not only those
+        handled by the blueprint. Equivalent to :meth:`.Flask.url_value_preprocessor`.
+        """
+        self.record_once(
+            lambda s: s.app.url_value_preprocessors.setdefault(None, []).append(f)
+        )
+        return f
+
+    @setupmethod
+    def app_url_defaults(self, f: T_url_defaults) -> T_url_defaults:
+        """Like :meth:`url_defaults`, but for every request, not only those handled by
+        the blueprint. Equivalent to :meth:`.Flask.url_defaults`.
+        """
+        self.record_once(
+            lambda s: s.app.url_default_functions.setdefault(None, []).append(f)
+        )
+        return f
diff --git a/src/flask/scaffold.py b/src/flask/sansio/scaffold.py
similarity index 83%
rename from src/flask/scaffold.py
rename to src/flask/sansio/scaffold.py
index 6af6906a..53557008 100644
--- a/src/flask/scaffold.py
+++ b/src/flask/sansio/scaffold.py
@@ -3,33 +3,28 @@ from __future__ import annotations
 import importlib.util
 import os
 import pathlib
-import pkgutil
 import sys
 import typing as t
 from collections import defaultdict
-from datetime import timedelta
 from functools import update_wrapper
 
+import click
+from jinja2 import BaseLoader
 from jinja2 import FileSystemLoader
 from werkzeug.exceptions import default_exceptions
 from werkzeug.exceptions import HTTPException
 from werkzeug.utils import cached_property
 
-from . import typing as ft
-from .cli import AppGroup
-from .globals import current_app
-from .helpers import get_root_path
-from .helpers import send_from_directory
-from .templating import _default_template_ctx_processor
-
-if t.TYPE_CHECKING:  # pragma: no cover
-    from .wrappers import Response
+from .. import typing as ft
+from ..cli import AppGroup
+from ..helpers import get_root_path
+from ..templating import _default_template_ctx_processor
 
 # a singleton sentinel value for parameter defaults
 _sentinel = object()
 
 F = t.TypeVar("F", bound=t.Callable[..., t.Any])
-T_after_request = t.TypeVar("T_after_request", bound=ft.AfterRequestCallable)
+T_after_request = t.TypeVar("T_after_request", bound=ft.AfterRequestCallable[t.Any])
 T_before_request = t.TypeVar("T_before_request", bound=ft.BeforeRequestCallable)
 T_error_handler = t.TypeVar("T_error_handler", bound=ft.ErrorHandlerCallable)
 T_teardown = t.TypeVar("T_teardown", bound=ft.TeardownCallable)
@@ -46,7 +41,7 @@ T_route = t.TypeVar("T_route", bound=ft.RouteCallable)
 def setupmethod(f: F) -> F:
     f_name = f.__name__
 
-    def wrapper_func(self, *args: t.Any, **kwargs: t.Any) -> t.Any:
+    def wrapper_func(self: Scaffold, *args: t.Any, **kwargs: t.Any) -> t.Any:
         self._check_setup_finished(f_name)
         return f(self, *args, **kwargs)
 
@@ -78,9 +73,9 @@ class Scaffold:
     def __init__(
         self,
         import_name: str,
-        static_folder: str | os.PathLike | None = None,
+        static_folder: str | os.PathLike[str] | None = None,
         static_url_path: str | None = None,
-        template_folder: str | os.PathLike | None = None,
+        template_folder: str | os.PathLike[str] | None = None,
         root_path: str | None = None,
     ):
         #: The name of the package or module that this object belongs
@@ -106,7 +101,7 @@ class Scaffold:
         #: object. The commands are available from the ``flask`` command
         #: once the application has been discovered and blueprints have
         #: been registered.
-        self.cli = AppGroup()
+        self.cli: click.Group = AppGroup()
 
         #: A dictionary mapping endpoint names to view functions.
         #:
@@ -114,7 +109,7 @@ class Scaffold:
         #:
         #: This data structure is internal. It should not be modified
         #: directly and its format may change at any time.
-        self.view_functions: dict[str, t.Callable] = {}
+        self.view_functions: dict[str, ft.RouteCallable] = {}
 
         #: A data structure of registered error handlers, in the format
         #: ``{scope: {code: {class: handler}}}``. The ``scope`` key is
@@ -159,7 +154,7 @@ class Scaffold:
         #: This data structure is internal. It should not be modified
         #: directly and its format may change at any time.
         self.after_request_funcs: dict[
-            ft.AppOrBlueprintKey, list[ft.AfterRequestCallable]
+            ft.AppOrBlueprintKey, list[ft.AfterRequestCallable[t.Any]]
         ] = defaultdict(list)
 
         #: A data structure of functions to call at the end of each
@@ -240,7 +235,7 @@ class Scaffold:
             return None
 
     @static_folder.setter
-    def static_folder(self, value: str | os.PathLike | None) -> None:
+    def static_folder(self, value: str | os.PathLike[str] | None) -> None:
         if value is not None:
             value = os.fspath(value).rstrip(r"\/")
 
@@ -277,50 +272,8 @@ class Scaffold:
 
         self._static_url_path = value
 
-    def get_send_file_max_age(self, filename: str | None) -> int | None:
-        """Used by :func:`send_file` to determine the ``max_age`` cache
-        value for a given file path if it wasn't passed.
-
-        By default, this returns :data:`SEND_FILE_MAX_AGE_DEFAULT` from
-        the configuration of :data:`~flask.current_app`. This defaults
-        to ``None``, which tells the browser to use conditional requests
-        instead of a timed cache, which is usually preferable.
-
-        .. versionchanged:: 2.0
-            The default configuration is ``None`` instead of 12 hours.
-
-        .. versionadded:: 0.9
-        """
-        value = current_app.config["SEND_FILE_MAX_AGE_DEFAULT"]
-
-        if value is None:
-            return None
-
-        if isinstance(value, timedelta):
-            return int(value.total_seconds())
-
-        return value
-
-    def send_static_file(self, filename: str) -> Response:
-        """The view function used to serve files from
-        :attr:`static_folder`. A route is automatically registered for
-        this view at :attr:`static_url_path` if :attr:`static_folder` is
-        set.
-
-        .. versionadded:: 0.5
-        """
-        if not self.has_static_folder:
-            raise RuntimeError("'static_folder' must be set to serve static_files.")
-
-        # send_file only knows to call get_send_file_max_age on the app,
-        # call it here so it works for blueprints too.
-        max_age = self.get_send_file_max_age(filename)
-        return send_from_directory(
-            t.cast(str, self.static_folder), filename, max_age=max_age
-        )
-
     @cached_property
-    def jinja_loader(self) -> FileSystemLoader | None:
+    def jinja_loader(self) -> BaseLoader | None:
         """The Jinja loader for this object's templates. By default this
         is a class :class:`jinja2.loaders.FileSystemLoader` to
         :attr:`template_folder` if it is set.
@@ -332,34 +285,11 @@ class Scaffold:
         else:
             return None
 
-    def open_resource(self, resource: str, mode: str = "rb") -> t.IO[t.AnyStr]:
-        """Open a resource file relative to :attr:`root_path` for
-        reading.
-
-        For example, if the file ``schema.sql`` is next to the file
-        ``app.py`` where the ``Flask`` app is defined, it can be opened
-        with:
-
-        .. code-block:: python
-
-            with app.open_resource("schema.sql") as f:
-                conn.executescript(f.read())
-
-        :param resource: Path to the resource relative to
-            :attr:`root_path`.
-        :param mode: Open the file in this mode. Only reading is
-            supported, valid values are "r" (or "rt") and "rb".
-        """
-        if mode not in {"r", "rt", "rb"}:
-            raise ValueError("Resources can only be opened for reading.")
-
-        return open(os.path.join(self.root_path, resource), mode)
-
     def _method_route(
         self,
         method: str,
         rule: str,
-        options: dict,
+        options: dict[str, t.Any],
     ) -> t.Callable[[T_route], T_route]:
         if "methods" in options:
             raise TypeError("Use the 'route' decorator to use the 'methods' argument.")
@@ -772,7 +702,7 @@ class Scaffold:
             return exc_class, None
 
 
-def _endpoint_from_view_func(view_func: t.Callable) -> str:
+def _endpoint_from_view_func(view_func: ft.RouteCallable) -> str:
     """Internal helper that returns the default endpoint for a given
     function.  This always is the function name.
     """
@@ -780,31 +710,6 @@ def _endpoint_from_view_func(view_func: t.Callable) -> str:
     return view_func.__name__
 
 
-def _matching_loader_thinks_module_is_package(loader, mod_name):
-    """Attempt to figure out if the given name is a package or a module.
-
-    :param: loader: The loader that handled the name.
-    :param mod_name: The name of the package or module.
-    """
-    # Use loader.is_package if it's available.
-    if hasattr(loader, "is_package"):
-        return loader.is_package(mod_name)
-
-    cls = type(loader)
-
-    # NamespaceLoader doesn't implement is_package, but all names it
-    # loads must be packages.
-    if cls.__module__ == "_frozen_importlib" and cls.__name__ == "NamespaceLoader":
-        return True
-
-    # Otherwise we need to fail with an error that explains what went
-    # wrong.
-    raise AttributeError(
-        f"'{cls.__name__}.is_package()' must be implemented for PEP 302"
-        f" import hooks."
-    )
-
-
 def _path_is_relative_to(path: pathlib.PurePath, base: str) -> bool:
     # Path.is_relative_to doesn't exist until Python 3.9
     try:
@@ -814,7 +719,7 @@ def _path_is_relative_to(path: pathlib.PurePath, base: str) -> bool:
         return False
 
 
-def _find_package_path(import_name):
+def _find_package_path(import_name: str) -> str:
     """Find the path that contains the package or module."""
     root_mod_name, _, _ = import_name.partition(".")
 
@@ -823,66 +728,43 @@ def _find_package_path(import_name):
 
         if root_spec is None:
             raise ValueError("not found")
-    # ImportError: the machinery told us it does not exist
-    # ValueError:
-    #    - the module name was invalid
-    #    - the module name is __main__
-    #    - *we* raised `ValueError` due to `root_spec` being `None`
     except (ImportError, ValueError):
-        pass  # handled below
-    else:
-        # namespace package
-        if root_spec.origin in {"namespace", None}:
+        # ImportError: the machinery told us it does not exist
+        # ValueError:
+        #    - the module name was invalid
+        #    - the module name is __main__
+        #    - we raised `ValueError` due to `root_spec` being `None`
+        return os.getcwd()
+
+    if root_spec.submodule_search_locations:
+        if root_spec.origin is None or root_spec.origin == "namespace":
+            # namespace package
             package_spec = importlib.util.find_spec(import_name)
+
             if package_spec is not None and package_spec.submodule_search_locations:
                 # Pick the path in the namespace that contains the submodule.
                 package_path = pathlib.Path(
                     os.path.commonpath(package_spec.submodule_search_locations)
                 )
-                search_locations = (
+                search_location = next(
                     location
                     for location in root_spec.submodule_search_locations
                     if _path_is_relative_to(package_path, location)
                 )
             else:
                 # Pick the first path.
-                search_locations = iter(root_spec.submodule_search_locations)
-            return os.path.dirname(next(search_locations))
-        # a package (with __init__.py)
-        elif root_spec.submodule_search_locations:
-            return os.path.dirname(os.path.dirname(root_spec.origin))
-        # just a normal module
-        else:
-            return os.path.dirname(root_spec.origin)
-
-    # we were unable to find the `package_path` using PEP 451 loaders
-    loader = pkgutil.get_loader(root_mod_name)
-
-    if loader is None or root_mod_name == "__main__":
-        # import name is not found, or interactive/main module
-        return os.getcwd()
+                search_location = root_spec.submodule_search_locations[0]
 
-    if hasattr(loader, "get_filename"):
-        filename = loader.get_filename(root_mod_name)
-    elif hasattr(loader, "archive"):
-        # zipimporter's loader.archive points to the .egg or .zip file.
-        filename = loader.archive
+            return os.path.dirname(search_location)
+        else:
+            # package with __init__.py
+            return os.path.dirname(os.path.dirname(root_spec.origin))
     else:
-        # At least one loader is missing both get_filename and archive:
-        # Google App Engine's HardenedModulesHook, use __file__.
-        filename = importlib.import_module(root_mod_name).__file__
-
-    package_path = os.path.abspath(os.path.dirname(filename))
-
-    # If the imported name is a package, filename is currently pointing
-    # to the root of the package, need to get the current directory.
-    if _matching_loader_thinks_module_is_package(loader, root_mod_name):
-        package_path = os.path.dirname(package_path)
-
-    return package_path
+        # module
+        return os.path.dirname(root_spec.origin)  # type: ignore[type-var, return-value]
 
 
-def find_package(import_name: str):
+def find_package(import_name: str) -> tuple[str | None, str]:
     """Find the prefix that a package is installed under, and the path
     that it would be imported from.
 
diff --git a/src/flask/sessions.py b/src/flask/sessions.py
index e5650d68..bb753eb8 100644
--- a/src/flask/sessions.py
+++ b/src/flask/sessions.py
@@ -13,11 +13,15 @@ from werkzeug.datastructures import CallbackDict
 from .json.tag import TaggedJSONSerializer
 
 if t.TYPE_CHECKING:  # pragma: no cover
+    import typing_extensions as te
+
     from .app import Flask
-    from .wrappers import Request, Response
+    from .wrappers import Request
+    from .wrappers import Response
 
 
-class SessionMixin(MutableMapping):
+# TODO generic when Python > 3.8
+class SessionMixin(MutableMapping):  # type: ignore[type-arg]
     """Expands a basic dictionary with session attributes."""
 
     @property
@@ -45,7 +49,8 @@ class SessionMixin(MutableMapping):
     accessed = True
 
 
-class SecureCookieSession(CallbackDict, SessionMixin):
+# TODO generic when Python > 3.8
+class SecureCookieSession(CallbackDict, SessionMixin):  # type: ignore[type-arg]
     """Base class for sessions based on signed cookies.
 
     This session backend will set the :attr:`modified` and
@@ -68,7 +73,7 @@ class SecureCookieSession(CallbackDict, SessionMixin):
     accessed = False
 
     def __init__(self, initial: t.Any = None) -> None:
-        def on_update(self) -> None:
+        def on_update(self: te.Self) -> None:
             self.modified = True
             self.accessed = True
 
@@ -177,7 +182,7 @@ class SessionInterface:
 
     def get_cookie_name(self, app: Flask) -> str:
         """The name of the session cookie. Uses``app.config["SESSION_COOKIE_NAME"]``."""
-        return app.config["SESSION_COOKIE_NAME"]
+        return app.config["SESSION_COOKIE_NAME"]  # type: ignore[no-any-return]
 
     def get_cookie_domain(self, app: Flask) -> str | None:
         """The value of the ``Domain`` parameter on the session cookie. If not set,
@@ -189,8 +194,7 @@ class SessionInterface:
         .. versionchanged:: 2.3
             Not set by default, does not fall back to ``SERVER_NAME``.
         """
-        rv = app.config["SESSION_COOKIE_DOMAIN"]
-        return rv if rv else None
+        return app.config["SESSION_COOKIE_DOMAIN"]  # type: ignore[no-any-return]
 
     def get_cookie_path(self, app: Flask) -> str:
         """Returns the path for which the cookie should be valid.  The
@@ -198,27 +202,27 @@ class SessionInterface:
         config var if it's set, and falls back to ``APPLICATION_ROOT`` or
         uses ``/`` if it's ``None``.
         """
-        return app.config["SESSION_COOKIE_PATH"] or app.config["APPLICATION_ROOT"]
+        return app.config["SESSION_COOKIE_PATH"] or app.config["APPLICATION_ROOT"]  # type: ignore[no-any-return]
 
     def get_cookie_httponly(self, app: Flask) -> bool:
         """Returns True if the session cookie should be httponly.  This
         currently just returns the value of the ``SESSION_COOKIE_HTTPONLY``
         config var.
         """
-        return app.config["SESSION_COOKIE_HTTPONLY"]
+        return app.config["SESSION_COOKIE_HTTPONLY"]  # type: ignore[no-any-return]
 
     def get_cookie_secure(self, app: Flask) -> bool:
         """Returns True if the cookie should be secure.  This currently
         just returns the value of the ``SESSION_COOKIE_SECURE`` setting.
         """
-        return app.config["SESSION_COOKIE_SECURE"]
+        return app.config["SESSION_COOKIE_SECURE"]  # type: ignore[no-any-return]
 
-    def get_cookie_samesite(self, app: Flask) -> str:
+    def get_cookie_samesite(self, app: Flask) -> str | None:
         """Return ``'Strict'`` or ``'Lax'`` if the cookie should use the
         ``SameSite`` attribute. This currently just returns the value of
         the :data:`SESSION_COOKIE_SAMESITE` setting.
         """
-        return app.config["SESSION_COOKIE_SAMESITE"]
+        return app.config["SESSION_COOKIE_SAMESITE"]  # type: ignore[no-any-return]
 
     def get_expiration_time(self, app: Flask, session: SessionMixin) -> datetime | None:
         """A helper method that returns an expiration date for the session
diff --git a/src/flask/signals.py b/src/flask/signals.py
index d79f21f9..444fda99 100644
--- a/src/flask/signals.py
+++ b/src/flask/signals.py
@@ -1,8 +1,5 @@
 from __future__ import annotations
 
-import typing as t
-import warnings
-
 from blinker import Namespace
 
 # This namespace is only for signals provided by Flask itself.
@@ -18,16 +15,3 @@ appcontext_tearing_down = _signals.signal("appcontext-tearing-down")
 appcontext_pushed = _signals.signal("appcontext-pushed")
 appcontext_popped = _signals.signal("appcontext-popped")
 message_flashed = _signals.signal("message-flashed")
-
-
-def __getattr__(name: str) -> t.Any:
-    if name == "signals_available":
-        warnings.warn(
-            "The 'signals_available' attribute is deprecated and will be removed in"
-            " Flask 2.4. Signals are always available.",
-            DeprecationWarning,
-            stacklevel=2,
-        )
-        return True
-
-    raise AttributeError(name)
diff --git a/src/flask/templating.py b/src/flask/templating.py
index 769108f7..618a3b35 100644
--- a/src/flask/templating.py
+++ b/src/flask/templating.py
@@ -17,7 +17,8 @@ from .signals import template_rendered
 
 if t.TYPE_CHECKING:  # pragma: no cover
     from .app import Flask
-    from .scaffold import Scaffold
+    from .sansio.app import App
+    from .sansio.scaffold import Scaffold
 
 
 def _default_template_ctx_processor() -> dict[str, t.Any]:
@@ -41,7 +42,7 @@ class Environment(BaseEnvironment):
     name of the blueprint to referenced templates if necessary.
     """
 
-    def __init__(self, app: Flask, **options: t.Any) -> None:
+    def __init__(self, app: App, **options: t.Any) -> None:
         if "loader" not in options:
             options["loader"] = app.create_global_jinja_loader()
         BaseEnvironment.__init__(self, **options)
@@ -53,19 +54,19 @@ class DispatchingJinjaLoader(BaseLoader):
     the blueprint folders.
     """
 
-    def __init__(self, app: Flask) -> None:
+    def __init__(self, app: App) -> None:
         self.app = app
 
-    def get_source(  # type: ignore
-        self, environment: Environment, template: str
-    ) -> tuple[str, str | None, t.Callable | None]:
+    def get_source(
+        self, environment: BaseEnvironment, template: str
+    ) -> tuple[str, str | None, t.Callable[[], bool] | None]:
         if self.app.config["EXPLAIN_TEMPLATE_LOADING"]:
             return self._get_source_explained(environment, template)
         return self._get_source_fast(environment, template)
 
     def _get_source_explained(
-        self, environment: Environment, template: str
-    ) -> tuple[str, str | None, t.Callable | None]:
+        self, environment: BaseEnvironment, template: str
+    ) -> tuple[str, str | None, t.Callable[[], bool] | None]:
         attempts = []
         rv: tuple[str, str | None, t.Callable[[], bool] | None] | None
         trv: None | (tuple[str, str | None, t.Callable[[], bool] | None]) = None
@@ -88,8 +89,8 @@ class DispatchingJinjaLoader(BaseLoader):
         raise TemplateNotFound(template)
 
     def _get_source_fast(
-        self, environment: Environment, template: str
-    ) -> tuple[str, str | None, t.Callable | None]:
+        self, environment: BaseEnvironment, template: str
+    ) -> tuple[str, str | None, t.Callable[[], bool] | None]:
         for _srcobj, loader in self._iter_loaders(template):
             try:
                 return loader.get_source(environment, template)
@@ -97,9 +98,7 @@ class DispatchingJinjaLoader(BaseLoader):
                 continue
         raise TemplateNotFound(template)
 
-    def _iter_loaders(
-        self, template: str
-    ) -> t.Generator[tuple[Scaffold, BaseLoader], None, None]:
+    def _iter_loaders(self, template: str) -> t.Iterator[tuple[Scaffold, BaseLoader]]:
         loader = self.app.jinja_loader
         if loader is not None:
             yield self.app, loader
diff --git a/src/flask/testing.py b/src/flask/testing.py
index 773f1525..a27b7c8f 100644
--- a/src/flask/testing.py
+++ b/src/flask/testing.py
@@ -1,5 +1,6 @@
 from __future__ import annotations
 
+import importlib.metadata
 import typing as t
 from contextlib import contextmanager
 from contextlib import ExitStack
@@ -16,6 +17,7 @@ from .cli import ScriptInfo
 from .sessions import SessionMixin
 
 if t.TYPE_CHECKING:  # pragma: no cover
+    from _typeshed.wsgi import WSGIEnvironment
     from werkzeug.test import TestResponse
 
     from .app import Flask
@@ -92,6 +94,18 @@ class EnvironBuilder(werkzeug.test.EnvironBuilder):
         return self.app.json.dumps(obj, **kwargs)
 
 
+_werkzeug_version = ""
+
+
+def _get_werkzeug_version() -> str:
+    global _werkzeug_version
+
+    if not _werkzeug_version:
+        _werkzeug_version = importlib.metadata.version("werkzeug")
+
+    return _werkzeug_version
+
+
 class FlaskClient(Client):
     """Works like a regular Werkzeug test client but has knowledge about
     Flask's contexts to defer the cleanup of the request context until
@@ -115,13 +129,13 @@ class FlaskClient(Client):
         self._context_stack = ExitStack()
         self.environ_base = {
             "REMOTE_ADDR": "127.0.0.1",
-            "HTTP_USER_AGENT": f"werkzeug/{werkzeug.__version__}",
+            "HTTP_USER_AGENT": f"Werkzeug/{_get_werkzeug_version()}",
         }
 
     @contextmanager
     def session_transaction(
         self, *args: t.Any, **kwargs: t.Any
-    ) -> t.Generator[SessionMixin, None, None]:
+    ) -> t.Iterator[SessionMixin]:
         """When used in combination with a ``with`` statement this opens a
         session transaction.  This can be used to modify the session that
         the test client uses.  Once the ``with`` block is left the session is
@@ -168,7 +182,7 @@ class FlaskClient(Client):
             resp.headers.getlist("Set-Cookie"),
         )
 
-    def _copy_environ(self, other):
+    def _copy_environ(self, other: WSGIEnvironment) -> WSGIEnvironment:
         out = {**self.environ_base, **other}
 
         if self.preserve_context:
@@ -176,7 +190,9 @@ class FlaskClient(Client):
 
         return out
 
-    def _request_from_builder_args(self, args, kwargs):
+    def _request_from_builder_args(
+        self, args: tuple[t.Any, ...], kwargs: dict[str, t.Any]
+    ) -> BaseRequest:
         kwargs["environ_base"] = self._copy_environ(kwargs.get("environ_base", {}))
         builder = EnvironBuilder(self.application, *args, **kwargs)
 
@@ -197,7 +213,7 @@ class FlaskClient(Client):
         ):
             if isinstance(args[0], werkzeug.test.EnvironBuilder):
                 builder = copy(args[0])
-                builder.environ_base = self._copy_environ(builder.environ_base or {})
+                builder.environ_base = self._copy_environ(builder.environ_base or {})  # type: ignore[arg-type]
                 request = builder.get_request()
             elif isinstance(args[0], dict):
                 request = EnvironBuilder.from_environ(
@@ -274,7 +290,7 @@ class FlaskCliRunner(CliRunner):
         :return: a :class:`~click.testing.Result` object.
         """
         if cli is None:
-            cli = self.app.cli  # type: ignore
+            cli = self.app.cli
 
         if "obj" not in kwargs:
             kwargs["obj"] = ScriptInfo(create_app=lambda: self.app)
diff --git a/src/flask/typing.py b/src/flask/typing.py
index 50aef7f4..cf6d4ae6 100644
--- a/src/flask/typing.py
+++ b/src/flask/typing.py
@@ -5,7 +5,7 @@ import typing as t
 if t.TYPE_CHECKING:  # pragma: no cover
     from _typeshed.wsgi import WSGIApplication  # noqa: F401
     from werkzeug.datastructures import Headers  # noqa: F401
-    from werkzeug.wrappers import Response  # noqa: F401
+    from werkzeug.sansio.response import Response  # noqa: F401
 
 # The possible types that are directly convertible or are a Response object.
 ResponseValue = t.Union[
@@ -61,12 +61,17 @@ TeardownCallable = t.Union[
     t.Callable[[t.Optional[BaseException]], None],
     t.Callable[[t.Optional[BaseException]], t.Awaitable[None]],
 ]
-TemplateContextProcessorCallable = t.Callable[[], t.Dict[str, t.Any]]
+TemplateContextProcessorCallable = t.Union[
+    t.Callable[[], t.Dict[str, t.Any]],
+    t.Callable[[], t.Awaitable[t.Dict[str, t.Any]]],
+]
 TemplateFilterCallable = t.Callable[..., t.Any]
 TemplateGlobalCallable = t.Callable[..., t.Any]
 TemplateTestCallable = t.Callable[..., bool]
-URLDefaultCallable = t.Callable[[str, dict], None]
-URLValuePreprocessorCallable = t.Callable[[t.Optional[str], t.Optional[dict]], None]
+URLDefaultCallable = t.Callable[[str, t.Dict[str, t.Any]], None]
+URLValuePreprocessorCallable = t.Callable[
+    [t.Optional[str], t.Optional[t.Dict[str, t.Any]]], None
+]
 
 # This should take Exception, but that either breaks typing the argument
 # with a specific exception, or decorating multiple times with different
@@ -74,7 +79,10 @@ URLValuePreprocessorCallable = t.Callable[[t.Optional[str], t.Optional[dict]], N
 # https://github.com/pallets/flask/issues/4095
 # https://github.com/pallets/flask/issues/4295
 # https://github.com/pallets/flask/issues/4297
-ErrorHandlerCallable = t.Callable[[t.Any], ResponseReturnValue]
+ErrorHandlerCallable = t.Union[
+    t.Callable[[t.Any], ResponseReturnValue],
+    t.Callable[[t.Any], t.Awaitable[ResponseReturnValue]],
+]
 
 RouteCallable = t.Union[
     t.Callable[..., ResponseReturnValue],
diff --git a/src/flask/views.py b/src/flask/views.py
index c7a2b621..794fdc06 100644
--- a/src/flask/views.py
+++ b/src/flask/views.py
@@ -6,6 +6,7 @@ from . import typing as ft
 from .globals import current_app
 from .globals import request
 
+F = t.TypeVar("F", bound=t.Callable[..., t.Any])
 
 http_method_funcs = frozenset(
     ["get", "post", "head", "options", "delete", "put", "trace", "patch"]
@@ -60,7 +61,7 @@ class View:
     #: decorator.
     #:
     #: .. versionadded:: 0.8
-    decorators: t.ClassVar[list[t.Callable]] = []
+    decorators: t.ClassVar[list[t.Callable[[F], F]]] = []
 
     #: Create a new instance of this view class for every request by
     #: default. If a view subclass sets this to ``False``, the same
@@ -106,13 +107,13 @@ class View:
                 self = view.view_class(  # type: ignore[attr-defined]
                     *class_args, **class_kwargs
                 )
-                return current_app.ensure_sync(self.dispatch_request)(**kwargs)
+                return current_app.ensure_sync(self.dispatch_request)(**kwargs)  # type: ignore[no-any-return]
 
         else:
             self = cls(*class_args, **class_kwargs)
 
             def view(**kwargs: t.Any) -> ft.ResponseReturnValue:
-                return current_app.ensure_sync(self.dispatch_request)(**kwargs)
+                return current_app.ensure_sync(self.dispatch_request)(**kwargs)  # type: ignore[no-any-return]
 
         if cls.decorators:
             view.__name__ = name
@@ -187,4 +188,4 @@ class MethodView(View):
             meth = getattr(self, "get", None)
 
         assert meth is not None, f"Unimplemented method {request.method!r}"
-        return current_app.ensure_sync(meth)(**kwargs)
+        return current_app.ensure_sync(meth)(**kwargs)  # type: ignore[no-any-return]
diff --git a/src/flask/wrappers.py b/src/flask/wrappers.py
index ef7aa38c..c1eca807 100644
--- a/src/flask/wrappers.py
+++ b/src/flask/wrappers.py
@@ -3,6 +3,7 @@ from __future__ import annotations
 import typing as t
 
 from werkzeug.exceptions import BadRequest
+from werkzeug.exceptions import HTTPException
 from werkzeug.wrappers import Request as RequestBase
 from werkzeug.wrappers import Response as ResponseBase
 
@@ -49,13 +50,13 @@ class Request(RequestBase):
     #: raised / was raised as part of the request handling.  This is
     #: usually a :exc:`~werkzeug.exceptions.NotFound` exception or
     #: something similar.
-    routing_exception: Exception | None = None
+    routing_exception: HTTPException | None = None
 
     @property
-    def max_content_length(self) -> int | None:  # type: ignore
+    def max_content_length(self) -> int | None:  # type: ignore[override]
         """Read-only view of the ``MAX_CONTENT_LENGTH`` config key."""
         if current_app:
-            return current_app.config["MAX_CONTENT_LENGTH"]
+            return current_app.config["MAX_CONTENT_LENGTH"]  # type: ignore[no-any-return]
         else:
             return None
 
@@ -167,7 +168,7 @@ class Response(ResponseBase):
         Werkzeug's docs.
         """
         if current_app:
-            return current_app.config["MAX_COOKIE_SIZE"]
+            return current_app.config["MAX_COOKIE_SIZE"]  # type: ignore[no-any-return]
 
         # return Werkzeug's default when not in an app context
         return super().max_cookie_size
diff --git a/tests/conftest.py b/tests/conftest.py
index a4168f2e..58cf85d8 100644
--- a/tests/conftest.py
+++ b/tests/conftest.py
@@ -1,7 +1,6 @@
 import os
 import pkgutil
 import sys
-import textwrap
 
 import pytest
 from _pytest import monkeypatch
@@ -129,67 +128,30 @@ def limit_loader(request, monkeypatch):
 
 
 @pytest.fixture
-def modules_tmpdir(tmpdir, monkeypatch):
-    """A tmpdir added to sys.path."""
-    rv = tmpdir.mkdir("modules_tmpdir")
-    monkeypatch.syspath_prepend(str(rv))
+def modules_tmp_path(tmp_path, monkeypatch):
+    """A temporary directory added to sys.path."""
+    rv = tmp_path / "modules_tmp"
+    rv.mkdir()
+    monkeypatch.syspath_prepend(os.fspath(rv))
     return rv
 
 
 @pytest.fixture
-def modules_tmpdir_prefix(modules_tmpdir, monkeypatch):
-    monkeypatch.setattr(sys, "prefix", str(modules_tmpdir))
-    return modules_tmpdir
+def modules_tmp_path_prefix(modules_tmp_path, monkeypatch):
+    monkeypatch.setattr(sys, "prefix", os.fspath(modules_tmp_path))
+    return modules_tmp_path
 
 
 @pytest.fixture
-def site_packages(modules_tmpdir, monkeypatch):
+def site_packages(modules_tmp_path, monkeypatch):
     """Create a fake site-packages."""
-    rv = (
-        modules_tmpdir.mkdir("lib")
-        .mkdir(f"python{sys.version_info.major}.{sys.version_info.minor}")
-        .mkdir("site-packages")
-    )
-    monkeypatch.syspath_prepend(str(rv))
+    py_dir = f"python{sys.version_info.major}.{sys.version_info.minor}"
+    rv = modules_tmp_path / "lib" / py_dir / "site-packages"
+    rv.mkdir(parents=True)
+    monkeypatch.syspath_prepend(os.fspath(rv))
     return rv
 
 
-@pytest.fixture
-def install_egg(modules_tmpdir, monkeypatch):
-    """Generate egg from package name inside base and put the egg into
-    sys.path."""
-
-    def inner(name, base=modules_tmpdir):
-        base.join(name).ensure_dir()
-        base.join(name).join("__init__.py").ensure()
-
-        egg_setup = base.join("setup.py")
-        egg_setup.write(
-            textwrap.dedent(
-                f"""
-                from setuptools import setup
-                setup(
-                    name="{name}",
-                    version="1.0",
-                    packages=["site_egg"],
-                    zip_safe=True,
-                )
-                """
-            )
-        )
-
-        import subprocess
-
-        subprocess.check_call(
-            [sys.executable, "setup.py", "bdist_egg"], cwd=str(modules_tmpdir)
-        )
-        (egg_path,) = modules_tmpdir.join("dist/").listdir()
-        monkeypatch.syspath_prepend(str(egg_path))
-        return egg_path
-
-    return inner
-
-
 @pytest.fixture
 def purge_module(request):
     def inner(name):
diff --git a/tests/test_appctx.py b/tests/test_appctx.py
index aa3a8b4e..ca9e079e 100644
--- a/tests/test_appctx.py
+++ b/tests/test_appctx.py
@@ -196,17 +196,14 @@ def test_clean_pop(app):
 
     @app.teardown_request
     def teardown_req(error=None):
-        1 / 0
+        raise ZeroDivisionError
 
     @app.teardown_appcontext
     def teardown_app(error=None):
         called.append("TEARDOWN")
 
-    try:
-        with app.test_request_context():
-            called.append(flask.current_app.name)
-    except ZeroDivisionError:
-        pass
+    with app.app_context():
+        called.append(flask.current_app.name)
 
     assert called == ["flask_test", "TEARDOWN"]
     assert not flask.current_app
diff --git a/tests/test_apps/subdomaintestmodule/__init__.py b/tests/test_apps/subdomaintestmodule/__init__.py
index 9b83c0d7..b4ce4b16 100644
--- a/tests/test_apps/subdomaintestmodule/__init__.py
+++ b/tests/test_apps/subdomaintestmodule/__init__.py
@@ -1,4 +1,3 @@
 from flask import Module
 
-
 mod = Module(__name__, "foo", subdomain="foo")
diff --git a/tests/test_basic.py b/tests/test_basic.py
index ca373dca..214cfee0 100644
--- a/tests/test_basic.py
+++ b/tests/test_basic.py
@@ -19,7 +19,6 @@ from werkzeug.routing import RequestRedirect
 
 import flask
 
-
 require_cpython_gc = pytest.mark.skipif(
     python_implementation() != "CPython",
     reason="Requires CPython GC behavior",
@@ -190,7 +189,8 @@ def test_url_mapping(app, client):
 
 
 def test_werkzeug_routing(app, client):
-    from werkzeug.routing import Submount, Rule
+    from werkzeug.routing import Rule
+    from werkzeug.routing import Submount
 
     app.url_map.add(
         Submount("/foo", [Rule("/bar", endpoint="bar"), Rule("/", endpoint="index")])
@@ -210,7 +210,8 @@ def test_werkzeug_routing(app, client):
 
 
 def test_endpoint_decorator(app, client):
-    from werkzeug.routing import Submount, Rule
+    from werkzeug.routing import Rule
+    from werkzeug.routing import Submount
 
     app.url_map.add(
         Submount("/foo", [Rule("/bar", endpoint="bar"), Rule("/", endpoint="index")])
@@ -431,9 +432,9 @@ def test_session_special_types(app, client):
         client.get("/")
         s = flask.session
         assert s["t"] == (1, 2, 3)
-        assert type(s["b"]) == bytes
+        assert type(s["b"]) is bytes  # noqa: E721
         assert s["b"] == b"\xff"
-        assert type(s["m"]) == Markup
+        assert type(s["m"]) is Markup  # noqa: E721
         assert s["m"] == Markup("<html>")
         assert s["u"] == the_uuid
         assert s["d"] == now
@@ -760,7 +761,7 @@ def test_teardown_request_handler_error(app, client):
 
     @app.teardown_request
     def teardown_request1(exc):
-        assert type(exc) == ZeroDivisionError
+        assert type(exc) is ZeroDivisionError
         called.append(True)
         # This raises a new error and blows away sys.exc_info(), so we can
         # test that all teardown_requests get passed the same original
@@ -772,7 +773,7 @@ def test_teardown_request_handler_error(app, client):
 
     @app.teardown_request
     def teardown_request2(exc):
-        assert type(exc) == ZeroDivisionError
+        assert type(exc) is ZeroDivisionError
         called.append(True)
         # This raises a new error and blows away sys.exc_info(), so we can
         # test that all teardown_requests get passed the same original
@@ -784,7 +785,7 @@ def test_teardown_request_handler_error(app, client):
 
     @app.route("/")
     def fails():
-        1 // 0
+        raise ZeroDivisionError
 
     rv = client.get("/")
     assert rv.status_code == 500
@@ -851,7 +852,7 @@ def test_error_handling(app, client):
 
     @app.route("/error")
     def error():
-        1 // 0
+        raise ZeroDivisionError
 
     @app.route("/forbidden")
     def error2():
@@ -877,7 +878,7 @@ def test_error_handling_processing(app, client):
 
     @app.route("/")
     def broken_func():
-        1 // 0
+        raise ZeroDivisionError
 
     @app.after_request
     def after_request(resp):
@@ -1047,12 +1048,13 @@ def test_error_handler_after_processor_error(app, client):
     @app.before_request
     def before_request():
         if _trigger == "before":
-            1 // 0
+            raise ZeroDivisionError
 
     @app.after_request
     def after_request(response):
         if _trigger == "after":
-            1 // 0
+            raise ZeroDivisionError
+
         return response
 
     @app.route("/")
@@ -1507,7 +1509,7 @@ def test_exception_propagation(app, client, key):
 
     @app.route("/")
     def index():
-        1 // 0
+        raise ZeroDivisionError
 
     if key is not None:
         app.config[key] = True
diff --git a/tests/test_blueprints.py b/tests/test_blueprints.py
index 76cee660..69bc71ad 100644
--- a/tests/test_blueprints.py
+++ b/tests/test_blueprints.py
@@ -634,10 +634,11 @@ def test_add_template_test_with_name_and_template(app, client):
 def test_context_processing(app, client):
     answer_bp = flask.Blueprint("answer_bp", __name__)
 
-    template_string = lambda: flask.render_template_string(  # noqa: E731
-        "{% if notanswer %}{{ notanswer }} is not the answer. {% endif %}"
-        "{% if answer %}{{ answer }} is the answer.{% endif %}"
-    )
+    def template_string():
+        return flask.render_template_string(
+            "{% if notanswer %}{{ notanswer }} is not the answer. {% endif %}"
+            "{% if answer %}{{ answer }} is the answer.{% endif %}"
+        )
 
     # App global context processor
     @answer_bp.app_context_processor
diff --git a/tests/test_cli.py b/tests/test_cli.py
index 4b6995fe..09995488 100644
--- a/tests/test_cli.py
+++ b/tests/test_cli.py
@@ -1,6 +1,8 @@
 # This file was part of Flask-CLI and was modified under the terms of
 # its Revised BSD License. Copyright © 2015 CERN.
+import importlib.metadata
 import os
+import platform
 import ssl
 import sys
 import types
@@ -227,10 +229,6 @@ def test_locate_app_suppress_raise(test_apps):
 
 
 def test_get_version(test_apps, capsys):
-    from flask import __version__ as flask_version
-    from werkzeug import __version__ as werkzeug_version
-    from platform import python_version
-
     class MockCtx:
         resilient_parsing = False
         color = None
@@ -241,9 +239,9 @@ def test_get_version(test_apps, capsys):
     ctx = MockCtx()
     get_version(ctx, None, "test")
     out, err = capsys.readouterr()
-    assert f"Python {python_version()}" in out
-    assert f"Flask {flask_version}" in out
-    assert f"Werkzeug {werkzeug_version}" in out
+    assert f"Python {platform.python_version()}" in out
+    assert f"Flask {importlib.metadata.version('flask')}" in out
+    assert f"Werkzeug {importlib.metadata.version('werkzeug')}" in out
 
 
 def test_scriptinfo(test_apps, monkeypatch):
@@ -681,3 +679,8 @@ def test_cli_empty(app):
 
     result = app.test_cli_runner().invoke(args=["blue", "--help"])
     assert result.exit_code == 2, f"Unexpected success:\n\n{result.output}"
+
+
+def test_run_exclude_patterns():
+    ctx = run_command.make_context("run", ["--exclude-patterns", __file__])
+    assert ctx.params["exclude_patterns"] == [__file__]
diff --git a/tests/test_config.py b/tests/test_config.py
index 580ae864..e5b1906e 100644
--- a/tests/test_config.py
+++ b/tests/test_config.py
@@ -1,6 +1,5 @@
 import json
 import os
-import textwrap
 
 import pytest
 
@@ -242,17 +241,10 @@ def test_get_namespace():
 
 
 @pytest.mark.parametrize("encoding", ["utf-8", "iso-8859-15", "latin-1"])
-def test_from_pyfile_weird_encoding(tmpdir, encoding):
-    f = tmpdir.join("my_config.py")
-    f.write_binary(
-        textwrap.dedent(
-            f"""
-            # -*- coding: {encoding} -*-
-            TEST_VALUE = "föö"
-            """
-        ).encode(encoding)
-    )
+def test_from_pyfile_weird_encoding(tmp_path, encoding):
+    f = tmp_path / "my_config.py"
+    f.write_text(f'# -*- coding: {encoding} -*-\nTEST_VALUE = "föö"\n', encoding)
     app = flask.Flask(__name__)
-    app.config.from_pyfile(str(f))
+    app.config.from_pyfile(os.fspath(f))
     value = app.config["TEST_VALUE"]
     assert value == "föö"
diff --git a/tests/test_helpers.py b/tests/test_helpers.py
index 7e742b16..3566385c 100644
--- a/tests/test_helpers.py
+++ b/tests/test_helpers.py
@@ -161,6 +161,13 @@ class TestUrlFor:
         assert flask.url_for("myview", id=42, _method="GET") == "/myview/42"
         assert flask.url_for("myview", _method="POST") == "/myview/create"
 
+    def test_url_for_with_self(self, app, req_ctx):
+        @app.route("/<self>")
+        def index(self):
+            return "42"
+
+        assert flask.url_for("index", self="2") == "/2"
+
 
 def test_redirect_no_app():
     response = flask.redirect("https://localhost", 307)
@@ -218,8 +225,8 @@ class TestNoImports:
     imp modules in the Python standard library.
     """
 
-    def test_name_with_import_error(self, modules_tmpdir):
-        modules_tmpdir.join("importerror.py").write("raise NotImplementedError()")
+    def test_name_with_import_error(self, modules_tmp_path):
+        (modules_tmp_path / "importerror.py").write_text("raise NotImplementedError()")
         try:
             flask.Flask("importerror")
         except NotImplementedError:
diff --git a/tests/test_instance_config.py b/tests/test_instance_config.py
index c8cf0bf7..1918bd99 100644
--- a/tests/test_instance_config.py
+++ b/tests/test_instance_config.py
@@ -1,21 +1,20 @@
-import sys
+import os
 
 import pytest
 
 import flask
 
 
-def test_explicit_instance_paths(modules_tmpdir):
-    with pytest.raises(ValueError) as excinfo:
+def test_explicit_instance_paths(modules_tmp_path):
+    with pytest.raises(ValueError, match=".*must be absolute"):
         flask.Flask(__name__, instance_path="instance")
-    assert "must be absolute" in str(excinfo.value)
 
-    app = flask.Flask(__name__, instance_path=str(modules_tmpdir))
-    assert app.instance_path == str(modules_tmpdir)
+    app = flask.Flask(__name__, instance_path=os.fspath(modules_tmp_path))
+    assert app.instance_path == os.fspath(modules_tmp_path)
 
 
-def test_uninstalled_module_paths(modules_tmpdir, purge_module):
-    app = modules_tmpdir.join("config_module_app.py").write(
+def test_uninstalled_module_paths(modules_tmp_path, purge_module):
+    (modules_tmp_path / "config_module_app.py").write_text(
         "import os\n"
         "import flask\n"
         "here = os.path.abspath(os.path.dirname(__file__))\n"
@@ -25,13 +24,13 @@ def test_uninstalled_module_paths(modules_tmpdir, purge_module):
 
     from config_module_app import app
 
-    assert app.instance_path == str(modules_tmpdir.join("instance"))
+    assert app.instance_path == os.fspath(modules_tmp_path / "instance")
 
 
-def test_uninstalled_package_paths(modules_tmpdir, purge_module):
-    app = modules_tmpdir.mkdir("config_package_app")
-    init = app.join("__init__.py")
-    init.write(
+def test_uninstalled_package_paths(modules_tmp_path, purge_module):
+    app = modules_tmp_path / "config_package_app"
+    app.mkdir()
+    (app / "__init__.py").write_text(
         "import os\n"
         "import flask\n"
         "here = os.path.abspath(os.path.dirname(__file__))\n"
@@ -41,16 +40,16 @@ def test_uninstalled_package_paths(modules_tmpdir, purge_module):
 
     from config_package_app import app
 
-    assert app.instance_path == str(modules_tmpdir.join("instance"))
+    assert app.instance_path == os.fspath(modules_tmp_path / "instance")
 
 
-def test_uninstalled_namespace_paths(tmpdir, monkeypatch, purge_module):
+def test_uninstalled_namespace_paths(tmp_path, monkeypatch, purge_module):
     def create_namespace(package):
-        project = tmpdir.join(f"project-{package}")
-        monkeypatch.syspath_prepend(str(project))
-        project.join("namespace").join(package).join("__init__.py").write(
-            "import flask\napp = flask.Flask(__name__)\n", ensure=True
-        )
+        project = tmp_path / f"project-{package}"
+        monkeypatch.syspath_prepend(os.fspath(project))
+        ns = project / "namespace" / package
+        ns.mkdir(parents=True)
+        (ns / "__init__.py").write_text("import flask\napp = flask.Flask(__name__)\n")
         return project
 
     _ = create_namespace("package1")
@@ -60,66 +59,53 @@ def test_uninstalled_namespace_paths(tmpdir, monkeypatch, purge_module):
 
     from namespace.package2 import app
 
-    assert app.instance_path == str(project2.join("instance"))
+    assert app.instance_path == os.fspath(project2 / "instance")
 
 
 def test_installed_module_paths(
-    modules_tmpdir, modules_tmpdir_prefix, purge_module, site_packages, limit_loader
+    modules_tmp_path, modules_tmp_path_prefix, purge_module, site_packages, limit_loader
 ):
-    site_packages.join("site_app.py").write(
+    (site_packages / "site_app.py").write_text(
         "import flask\napp = flask.Flask(__name__)\n"
     )
     purge_module("site_app")
 
     from site_app import app
 
-    assert app.instance_path == modules_tmpdir.join("var").join("site_app-instance")
+    assert app.instance_path == os.fspath(
+        modules_tmp_path / "var" / "site_app-instance"
+    )
 
 
 def test_installed_package_paths(
-    limit_loader, modules_tmpdir, modules_tmpdir_prefix, purge_module, monkeypatch
+    limit_loader, modules_tmp_path, modules_tmp_path_prefix, purge_module, monkeypatch
 ):
-    installed_path = modules_tmpdir.mkdir("path")
+    installed_path = modules_tmp_path / "path"
+    installed_path.mkdir()
     monkeypatch.syspath_prepend(installed_path)
 
-    app = installed_path.mkdir("installed_package")
-    init = app.join("__init__.py")
-    init.write("import flask\napp = flask.Flask(__name__)")
+    app = installed_path / "installed_package"
+    app.mkdir()
+    (app / "__init__.py").write_text("import flask\napp = flask.Flask(__name__)\n")
     purge_module("installed_package")
 
     from installed_package import app
 
-    assert app.instance_path == modules_tmpdir.join("var").join(
-        "installed_package-instance"
+    assert app.instance_path == os.fspath(
+        modules_tmp_path / "var" / "installed_package-instance"
     )
 
 
 def test_prefix_package_paths(
-    limit_loader, modules_tmpdir, modules_tmpdir_prefix, purge_module, site_packages
+    limit_loader, modules_tmp_path, modules_tmp_path_prefix, purge_module, site_packages
 ):
-    app = site_packages.mkdir("site_package")
-    init = app.join("__init__.py")
-    init.write("import flask\napp = flask.Flask(__name__)")
+    app = site_packages / "site_package"
+    app.mkdir()
+    (app / "__init__.py").write_text("import flask\napp = flask.Flask(__name__)\n")
     purge_module("site_package")
 
     import site_package
 
-    assert site_package.app.instance_path == modules_tmpdir.join("var").join(
-        "site_package-instance"
-    )
-
-
-def test_egg_installed_paths(install_egg, modules_tmpdir, modules_tmpdir_prefix):
-    modules_tmpdir.mkdir("site_egg").join("__init__.py").write(
-        "import flask\n\napp = flask.Flask(__name__)"
+    assert site_package.app.instance_path == os.fspath(
+        modules_tmp_path / "var" / "site_package-instance"
     )
-    install_egg("site_egg")
-    try:
-        import site_egg
-
-        assert site_egg.app.instance_path == str(
-            modules_tmpdir.join("var/").join("site_egg-instance")
-        )
-    finally:
-        if "site_egg" in sys.modules:
-            del sys.modules["site_egg"]
diff --git a/tests/test_signals.py b/tests/test_signals.py
index 6174fe83..32ab333e 100644
--- a/tests/test_signals.py
+++ b/tests/test_signals.py
@@ -98,7 +98,7 @@ def test_request_exception_signal():
 
     @app.route("/")
     def index():
-        1 // 0
+        raise ZeroDivisionError
 
     def record(sender, exception):
         recorded.append(exception)
@@ -169,7 +169,7 @@ def test_appcontext_tearing_down_signal(app, client):
 
     @app.route("/")
     def index():
-        1 // 0
+        raise ZeroDivisionError
 
     flask.appcontext_tearing_down.connect(record_teardown, app)
     try:
diff --git a/tests/test_testing.py b/tests/test_testing.py
index 8703e047..de052152 100644
--- a/tests/test_testing.py
+++ b/tests/test_testing.py
@@ -1,6 +1,7 @@
+import importlib.metadata
+
 import click
 import pytest
-import werkzeug
 
 import flask
 from flask import appcontext_popped
@@ -38,34 +39,35 @@ def test_environ_defaults(app, client, app_ctx, req_ctx):
         assert rv.data == b"http://localhost/"
 
 
-def test_environ_base_default(app, client, app_ctx):
+def test_environ_base_default(app, client):
     @app.route("/")
     def index():
-        flask.g.user_agent = flask.request.headers["User-Agent"]
-        return flask.request.remote_addr
+        flask.g.remote_addr = flask.request.remote_addr
+        flask.g.user_agent = flask.request.user_agent.string
+        return ""
 
-    rv = client.get("/")
-    assert rv.data == b"127.0.0.1"
-    assert flask.g.user_agent == f"werkzeug/{werkzeug.__version__}"
+    with client:
+        client.get("/")
+        assert flask.g.remote_addr == "127.0.0.1"
+        assert flask.g.user_agent == (
+            f"Werkzeug/{importlib.metadata.version('werkzeug')}"
+        )
 
 
-def test_environ_base_modified(app, client, app_ctx):
+def test_environ_base_modified(app, client):
     @app.route("/")
     def index():
-        flask.g.user_agent = flask.request.headers["User-Agent"]
-        return flask.request.remote_addr
+        flask.g.remote_addr = flask.request.remote_addr
+        flask.g.user_agent = flask.request.user_agent.string
+        return ""
 
-    client.environ_base["REMOTE_ADDR"] = "0.0.0.0"
+    client.environ_base["REMOTE_ADDR"] = "192.168.0.22"
     client.environ_base["HTTP_USER_AGENT"] = "Foo"
-    rv = client.get("/")
-    assert rv.data == b"0.0.0.0"
-    assert flask.g.user_agent == "Foo"
 
-    client.environ_base["REMOTE_ADDR"] = "0.0.0.1"
-    client.environ_base["HTTP_USER_AGENT"] = "Bar"
-    rv = client.get("/")
-    assert rv.data == b"0.0.0.1"
-    assert flask.g.user_agent == "Bar"
+    with client:
+        client.get("/")
+        assert flask.g.remote_addr == "192.168.0.22"
+        assert flask.g.user_agent == "Foo"
 
 
 def test_client_open_environ(app, client, request):
@@ -217,7 +219,7 @@ def test_test_client_context_binding(app, client):
 
     @app.route("/other")
     def other():
-        1 // 0
+        raise ZeroDivisionError
 
     with client:
         resp = client.get("/")
@@ -225,18 +227,15 @@ def test_test_client_context_binding(app, client):
         assert resp.data == b"Hello World!"
         assert resp.status_code == 200
 
+    with client:
         resp = client.get("/other")
         assert not hasattr(flask.g, "value")
         assert b"Internal Server Error" in resp.data
         assert resp.status_code == 500
         flask.g.value = 23
 
-    try:
-        flask.g.value
-    except (AttributeError, RuntimeError):
-        pass
-    else:
-        raise AssertionError("some kind of exception expected")
+    with pytest.raises(RuntimeError):
+        flask.g.value  # noqa: B018
 
 
 def test_reuse_client(client):
diff --git a/tests/test_views.py b/tests/test_views.py
index 8d870def..eab5eda2 100644
--- a/tests/test_views.py
+++ b/tests/test_views.py
@@ -41,10 +41,10 @@ def test_method_based_view(app):
 def test_view_patching(app):
     class Index(flask.views.MethodView):
         def get(self):
-            1 // 0
+            raise ZeroDivisionError
 
         def post(self):
-            1 // 0
+            raise ZeroDivisionError
 
     class Other(Index):
         def get(self):
diff --git a/tests/typing/typing_app_decorators.py b/tests/typing/typing_app_decorators.py
index 6b2188aa..c8d01113 100644
--- a/tests/typing/typing_app_decorators.py
+++ b/tests/typing/typing_app_decorators.py
@@ -1,7 +1,5 @@
 from __future__ import annotations
 
-import typing as t
-
 from flask import Flask
 from flask import Response
 
@@ -29,10 +27,10 @@ async def before_async() -> None:
 
 
 @app.teardown_appcontext
-def teardown_sync(exc: t.Optional[BaseException]) -> None:
+def teardown_sync(exc: BaseException | None) -> None:
     ...
 
 
 @app.teardown_appcontext
-async def teardown_async(exc: t.Optional[BaseException]) -> None:
+async def teardown_async(exc: BaseException | None) -> None:
     ...
diff --git a/tests/typing/typing_route.py b/tests/typing/typing_route.py
index bbd044ae..8bc271b2 100644
--- a/tests/typing/typing_route.py
+++ b/tests/typing/typing_route.py
@@ -29,12 +29,12 @@ def hello_json() -> Response:
 
 
 @app.route("/json/dict")
-def hello_json_dict() -> t.Dict[str, t.Any]:
+def hello_json_dict() -> dict[str, t.Any]:
     return {"response": "Hello, World!"}
 
 
 @app.route("/json/dict")
-def hello_json_list() -> t.List[t.Any]:
+def hello_json_list() -> list[t.Any]:
     return [{"message": "Hello"}, {"message": "World"}]
 
 
diff --git a/tox.ini b/tox.ini
index 6ade371c..1ba06631 100644
--- a/tox.ini
+++ b/tox.ini
@@ -1,7 +1,7 @@
 [tox]
 envlist =
     py3{12,11,10,9,8}
-    pypy39
+    pypy310
     py311-min
     py38-dev
     style
@@ -17,15 +17,8 @@ constrain_package_deps = true
 use_frozen_constraints = true
 deps =
     -r requirements/tests.txt
-    min: -r requirements/tests-pallets-min.txt
-    dev: https://github.com/pallets/werkzeug/archive/refs/heads/main.tar.gz
-    dev: https://github.com/pallets/jinja/archive/refs/heads/main.tar.gz
-    dev: https://github.com/pallets/markupsafe/archive/refs/heads/main.tar.gz
-    dev: https://github.com/pallets/itsdangerous/archive/refs/heads/main.tar.gz
-    dev: https://github.com/pallets/click/archive/refs/heads/main.tar.gz
-#    examples/tutorial[test]
-#    examples/javascript[test]
-# commands = pytest -v --tb=short --basetemp={envtmpdir} {posargs:tests examples}
+    min: -r requirements-skip/tests-min.txt
+    dev: -r requirements-skip/tests-dev.txt
 commands = pytest -v --tb=short --basetemp={envtmpdir} {posargs:tests}
 
 [testenv:style]
@@ -34,17 +27,9 @@ skip_install = true
 commands = pre-commit run --all-files
 
 [testenv:typing]
-package = wheel
-wheel_build_env = .pkg
-constrain_package_deps = true
-use_frozen_constraints = true
 deps = -r requirements/typing.txt
 commands = mypy
 
 [testenv:docs]
-package = wheel
-wheel_build_env = .pkg
-constrain_package_deps = true
-use_frozen_constraints = true
 deps = -r requirements/docs.txt
 commands = sphinx-build -W -b html -d {envtmpdir}/doctrees docs {envtmpdir}/html
