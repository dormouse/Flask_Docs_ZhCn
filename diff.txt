diff --git a/.flake8 b/.flake8
new file mode 100644
index 00000000..8f3b4fd4
--- /dev/null
+++ b/.flake8
@@ -0,0 +1,25 @@
+[flake8]
+extend-select =
+    # bugbear
+    B
+    # bugbear opinions
+    B9
+    # implicit str concat
+    ISC
+extend-ignore =
+    # slice notation whitespace, invalid
+    E203
+    # line length, handled by bugbear B950
+    E501
+    # bare except, handled by bugbear B001
+    E722
+    # zip with strict=, requires python >= 3.10
+    B905
+    # string formatting opinion, B028 renamed to B907
+    B028
+    B907
+# up to 88 allowed by bugbear B950
+max-line-length = 80
+per-file-ignores =
+    # __init__ exports names
+    src/flask/__init__.py: F401
diff --git a/.github/workflows/lock.yaml b/.github/workflows/lock.yaml
index b4f76338..c790fae5 100644
--- a/.github/workflows/lock.yaml
+++ b/.github/workflows/lock.yaml
@@ -1,15 +1,25 @@
 name: 'Lock threads'
+# Lock closed issues that have not received any further activity for
+# two weeks. This does not close open issues, only humans may do that.
+# We find that it is easier to respond to new issues with fresh examples
+# rather than continuing discussions on old issues.
 
 on:
   schedule:
     - cron: '0 0 * * *'
 
+permissions:
+  issues: write
+  pull-requests: write
+
+concurrency:
+  group: lock
+
 jobs:
   lock:
     runs-on: ubuntu-latest
     steps:
-      - uses: dessant/lock-threads@v3
+      - uses: dessant/lock-threads@c1b35aecc5cdb1a34539d14196df55838bb2f836
         with:
-          github-token: ${{ github.token }}
           issue-inactive-days: 14
           pr-inactive-days: 14
diff --git a/.github/workflows/publish.yaml b/.github/workflows/publish.yaml
new file mode 100644
index 00000000..0ed49559
--- /dev/null
+++ b/.github/workflows/publish.yaml
@@ -0,0 +1,72 @@
+name: Publish
+on:
+  push:
+    tags:
+      - '*'
+jobs:
+  build:
+    runs-on: ubuntu-latest
+    outputs:
+      hash: ${{ steps.hash.outputs.hash }}
+    steps:
+      - uses: actions/checkout@ac593985615ec2ede58e132d2e21d2b1cbd6127c
+      - uses: actions/setup-python@5ccb29d8773c3f3f653e1705f474dfaa8a06a912
+        with:
+          python-version: '3.x'
+          cache: 'pip'
+          cache-dependency-path: 'requirements/*.txt'
+      - run: pip install -r requirements/build.txt
+      # Use the commit date instead of the current date during the build.
+      - run: echo "SOURCE_DATE_EPOCH=$(git log -1 --pretty=%ct)" >> $GITHUB_ENV
+      - run: python -m build
+      # Generate hashes used for provenance.
+      - name: generate hash
+        id: hash
+        run: cd dist && echo "hash=$(sha256sum * | base64 -w0)" >> $GITHUB_OUTPUT
+      - uses: actions/upload-artifact@0b7f8abb1508181956e8e162db84b466c27e18ce
+        with:
+          path: ./dist
+  provenance:
+    needs: ['build']
+    permissions:
+      actions: read
+      id-token: write
+      contents: write
+    # Can't pin with hash due to how this workflow works.
+    uses: slsa-framework/slsa-github-generator/.github/workflows/generator_generic_slsa3.yml@v1.4.0
+    with:
+      base64-subjects: ${{ needs.build.outputs.hash }}
+  create-release:
+    # Upload the sdist, wheels, and provenance to a GitHub release. They remain
+    # available as build artifacts for a while as well.
+    needs: ['provenance']
+    runs-on: ubuntu-latest
+    permissions:
+      contents: write
+    steps:
+      - uses: actions/download-artifact@9bc31d5ccc31df68ecc42ccf4149144866c47d8a
+      - name: create release
+        run: >
+          gh release create --draft --repo ${{ github.repository }}
+          ${{ github.ref_name }}
+          *.intoto.jsonl/* artifact/*
+        env:
+          GH_TOKEN: ${{ github.token }}
+  publish-pypi:
+    needs: ['provenance']
+    # Wait for approval before attempting to upload to PyPI. This allows reviewing the
+    # files in the draft release.
+    environment: 'publish'
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/download-artifact@9bc31d5ccc31df68ecc42ccf4149144866c47d8a
+      # Try uploading to Test PyPI first, in case something fails.
+      - uses: pypa/gh-action-pypi-publish@c7f29f7adef1a245bd91520e94867e5c6eedddcc
+        with:
+          password: ${{ secrets.TEST_PYPI_TOKEN }}
+          repository_url: https://test.pypi.org/legacy/
+          packages_dir: artifact/
+      - uses: pypa/gh-action-pypi-publish@c7f29f7adef1a245bd91520e94867e5c6eedddcc
+        with:
+          password: ${{ secrets.PYPI_TOKEN }}
+          packages_dir: artifact/
diff --git a/.github/workflows/tests.yaml b/.github/workflows/tests.yaml
index 733676b4..79a56fca 100644
--- a/.github/workflows/tests.yaml
+++ b/.github/workflows/tests.yaml
@@ -24,20 +24,21 @@ jobs:
       fail-fast: false
       matrix:
         include:
-          - {name: Linux, python: '3.10', os: ubuntu-latest, tox: py310}
-          - {name: Windows, python: '3.10', os: windows-latest, tox: py310}
-          - {name: Mac, python: '3.10', os: macos-latest, tox: py310}
-          - {name: '3.11-dev', python: '3.11-dev', os: ubuntu-latest, tox: py311}
+          - {name: Linux, python: '3.11', os: ubuntu-latest, tox: py311}
+          - {name: Windows, python: '3.11', os: windows-latest, tox: py311}
+          - {name: Mac, python: '3.11', os: macos-latest, tox: py311}
+          - {name: '3.12-dev', python: '3.12-dev', os: ubuntu-latest, tox: py312}
+          - {name: '3.10', python: '3.10', os: ubuntu-latest, tox: py310}
           - {name: '3.9', python: '3.9', os: ubuntu-latest, tox: py39}
           - {name: '3.8', python: '3.8', os: ubuntu-latest, tox: py38}
           - {name: '3.7', python: '3.7', os: ubuntu-latest, tox: py37}
-          - {name: 'PyPy', python: 'pypy-3.7', os: ubuntu-latest, tox: pypy37}
-          - {name: 'Pallets Minimum Versions', python: '3.10', os: ubuntu-latest, tox: py-min}
-          - {name: 'Pallets Development Versions', python: '3.7', os: ubuntu-latest, tox: py-dev}
-          - {name: Typing, python: '3.10', os: ubuntu-latest, tox: typing}
+          - {name: 'PyPy', python: 'pypy-3.9', os: ubuntu-latest, tox: pypy39}
+          - {name: 'Pallets Minimum Versions', python: '3.11', os: ubuntu-latest, tox: py311-min}
+          - {name: 'Pallets Development Versions', python: '3.7', os: ubuntu-latest, tox: py37-dev}
+          - {name: Typing, python: '3.11', os: ubuntu-latest, tox: typing}
     steps:
-      - uses: actions/checkout@v2
-      - uses: actions/setup-python@v3
+      - uses: actions/checkout@ac593985615ec2ede58e132d2e21d2b1cbd6127c
+      - uses: actions/setup-python@5ccb29d8773c3f3f653e1705f474dfaa8a06a912
         with:
           python-version: ${{ matrix.python }}
           cache: 'pip'
@@ -47,5 +48,11 @@ jobs:
           pip install -U wheel
           pip install -U setuptools
           python -m pip install -U pip
+      - name: cache mypy
+        uses: actions/cache@58c146cc91c5b9e778e71775dfe9bf1442ad9a12
+        with:
+          path: ./.mypy_cache
+          key: mypy|${{ matrix.python }}|${{ hashFiles('setup.cfg') }}
+        if: matrix.tox == 'typing'
       - run: pip install tox
-      - run: tox -e ${{ matrix.tox }}
+      - run: tox run -e ${{ matrix.tox }}
diff --git a/.gitignore b/.gitignore
index e50a290e..e6713351 100644
--- a/.gitignore
+++ b/.gitignore
@@ -11,7 +11,6 @@ dist/
 build/
 *.egg
 *.egg-info/
-_mailinglist
 .tox/
 .cache/
 .pytest_cache/
diff --git a/.pre-commit-config.yaml b/.pre-commit-config.yaml
index fa395c57..d5e7a9c8 100644
--- a/.pre-commit-config.yaml
+++ b/.pre-commit-config.yaml
@@ -3,35 +3,34 @@ ci:
   autoupdate_schedule: monthly
 repos:
   - repo: https://github.com/asottile/pyupgrade
-    rev: v2.32.0
+    rev: v3.3.1
     hooks:
       - id: pyupgrade
-        args: ["--py36-plus"]
+        args: ["--py37-plus"]
   - repo: https://github.com/asottile/reorder_python_imports
-    rev: v3.1.0
+    rev: v3.9.0
     hooks:
       - id: reorder-python-imports
         name: Reorder Python imports (src, tests)
         files: "^(?!examples/)"
         args: ["--application-directories", "src"]
-        additional_dependencies: ["setuptools>60.9"]
   - repo: https://github.com/psf/black
-    rev: 22.3.0
+    rev: 23.1.0
     hooks:
       - id: black
   - repo: https://github.com/PyCQA/flake8
-    rev: 4.0.1
+    rev: 6.0.0
     hooks:
       - id: flake8
         additional_dependencies:
           - flake8-bugbear
           - flake8-implicit-str-concat
   - repo: https://github.com/peterdemin/pip-compile-multi
-    rev: v2.4.5
+    rev: v2.6.1
     hooks:
       - id: pip-compile-multi-verify
   - repo: https://github.com/pre-commit/pre-commit-hooks
-    rev: v4.2.0
+    rev: v4.4.0
     hooks:
       - id: fix-byte-order-marker
       - id: trailing-whitespace
diff --git a/CHANGES.rst b/CHANGES.rst
index 0e4bebfa..cd1a04c4 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -1,4 +1,159 @@
-.. currentmodule:: flask
+Version 2.2.3
+-------------
+
+Released 2023-02-15
+
+-   Autoescape is enabled by default for ``.svg`` template files. :issue:`4831`
+-   Fix the type of ``template_folder`` to accept ``pathlib.Path``. :issue:`4892`
+-   Add ``--debug`` option to the ``flask run`` command. :issue:`4777`
+
+
+Version 2.2.2
+-------------
+
+Released 2022-08-08
+
+-   Update Werkzeug dependency to >= 2.2.2. This includes fixes related
+    to the new faster router, header parsing, and the development
+    server. :pr:`4754`
+-   Fix the default value for ``app.env`` to be ``"production"``. This
+    attribute remains deprecated. :issue:`4740`
+
+
+Version 2.2.1
+-------------
+
+Released 2022-08-03
+
+-   Setting or accessing ``json_encoder`` or ``json_decoder`` raises a
+    deprecation warning. :issue:`4732`
+
+
+Version 2.2.0
+-------------
+
+Released 2022-08-01
+
+-   Remove previously deprecated code. :pr:`4667`
+
+    -   Old names for some ``send_file`` parameters have been removed.
+        ``download_name`` replaces ``attachment_filename``, ``max_age``
+        replaces ``cache_timeout``, and ``etag`` replaces ``add_etags``.
+        Additionally, ``path`` replaces ``filename`` in
+        ``send_from_directory``.
+    -   The ``RequestContext.g`` property returning ``AppContext.g`` is
+        removed.
+
+-   Update Werkzeug dependency to >= 2.2.
+-   The app and request contexts are managed using Python context vars
+    directly rather than Werkzeug's ``LocalStack``. This should result
+    in better performance and memory use. :pr:`4682`
+
+    -   Extension maintainers, be aware that ``_app_ctx_stack.top``
+        and ``_request_ctx_stack.top`` are deprecated. Store data on
+        ``g`` instead using a unique prefix, like
+        ``g._extension_name_attr``.
+
+-   The ``FLASK_ENV`` environment variable and ``app.env`` attribute are
+    deprecated, removing the distinction between development and debug
+    mode. Debug mode should be controlled directly using the ``--debug``
+    option or ``app.run(debug=True)``. :issue:`4714`
+-   Some attributes that proxied config keys on ``app`` are deprecated:
+    ``session_cookie_name``, ``send_file_max_age_default``,
+    ``use_x_sendfile``, ``propagate_exceptions``, and
+    ``templates_auto_reload``. Use the relevant config keys instead.
+    :issue:`4716`
+-   Add new customization points to the ``Flask`` app object for many
+    previously global behaviors.
+
+    -   ``flask.url_for`` will call ``app.url_for``. :issue:`4568`
+    -   ``flask.abort`` will call ``app.aborter``.
+        ``Flask.aborter_class`` and ``Flask.make_aborter`` can be used
+        to customize this aborter. :issue:`4567`
+    -   ``flask.redirect`` will call ``app.redirect``. :issue:`4569`
+    -   ``flask.json`` is an instance of ``JSONProvider``. A different
+        provider can be set to use a different JSON library.
+        ``flask.jsonify`` will call ``app.json.response``, other
+        functions in ``flask.json`` will call corresponding functions in
+        ``app.json``. :pr:`4692`
+
+-   JSON configuration is moved to attributes on the default
+    ``app.json`` provider. ``JSON_AS_ASCII``, ``JSON_SORT_KEYS``,
+    ``JSONIFY_MIMETYPE``, and ``JSONIFY_PRETTYPRINT_REGULAR`` are
+    deprecated. :pr:`4692`
+-   Setting custom ``json_encoder`` and ``json_decoder`` classes on the
+    app or a blueprint, and the corresponding ``json.JSONEncoder`` and
+    ``JSONDecoder`` classes, are deprecated. JSON behavior can now be
+    overridden using the ``app.json`` provider interface. :pr:`4692`
+-   ``json.htmlsafe_dumps`` and ``json.htmlsafe_dump`` are deprecated,
+    the function is built-in to Jinja now. :pr:`4692`
+-   Refactor ``register_error_handler`` to consolidate error checking.
+    Rewrite some error messages to be more consistent. :issue:`4559`
+-   Use Blueprint decorators and functions intended for setup after
+    registering the blueprint will show a warning. In the next version,
+    this will become an error just like the application setup methods.
+    :issue:`4571`
+-   ``before_first_request`` is deprecated. Run setup code when creating
+    the application instead. :issue:`4605`
+-   Added the ``View.init_every_request`` class attribute. If a view
+    subclass sets this to ``False``, the view will not create a new
+    instance on every request. :issue:`2520`.
+-   A ``flask.cli.FlaskGroup`` Click group can be nested as a
+    sub-command in a custom CLI. :issue:`3263`
+-   Add ``--app`` and ``--debug`` options to the ``flask`` CLI, instead
+    of requiring that they are set through environment variables.
+    :issue:`2836`
+-   Add ``--env-file`` option to the ``flask`` CLI. This allows
+    specifying a dotenv file to load in addition to ``.env`` and
+    ``.flaskenv``. :issue:`3108`
+-   It is no longer required to decorate custom CLI commands on
+    ``app.cli`` or ``blueprint.cli`` with ``@with_appcontext``, an app
+    context will already be active at that point. :issue:`2410`
+-   ``SessionInterface.get_expiration_time`` uses a timezone-aware
+    value. :pr:`4645`
+-   View functions can return generators directly instead of wrapping
+    them in a ``Response``. :pr:`4629`
+-   Add ``stream_template`` and ``stream_template_string`` functions to
+    render a template as a stream of pieces. :pr:`4629`
+-   A new implementation of context preservation during debugging and
+    testing. :pr:`4666`
+
+    -   ``request``, ``g``, and other context-locals point to the
+        correct data when running code in the interactive debugger
+        console. :issue:`2836`
+    -   Teardown functions are always run at the end of the request,
+        even if the context is preserved. They are also run after the
+        preserved context is popped.
+    -   ``stream_with_context`` preserves context separately from a
+        ``with client`` block. It will be cleaned up when
+        ``response.get_data()`` or ``response.close()`` is called.
+
+-   Allow returning a list from a view function, to convert it to a
+    JSON response like a dict is. :issue:`4672`
+-   When type checking, allow ``TypedDict`` to be returned from view
+    functions. :pr:`4695`
+-   Remove the ``--eager-loading/--lazy-loading`` options from the
+    ``flask run`` command. The app is always eager loaded the first
+    time, then lazily loaded in the reloader. The reloader always prints
+    errors immediately but continues serving. Remove the internal
+    ``DispatchingApp`` middleware used by the previous implementation.
+    :issue:`4715`
+
+
+Version 2.1.3
+-------------
+
+Released 2022-07-13
+
+-   Inline some optional imports that are only used for certain CLI
+    commands. :pr:`4606`
+-   Relax type annotation for ``after_request`` functions. :issue:`4600`
+-   ``instance_path`` for namespace packages uses the path closest to
+    the imported submodule. :issue:`4610`
+-   Clearer error message when ``render_template`` and
+    ``render_template_string`` are used outside an application context.
+    :pr:`4693`
+
 
 Version 2.1.2
 -------------
@@ -146,7 +301,7 @@ Released 2021-05-21
     the endpoint name. :issue:`4041`
 -   Combine URL prefixes when nesting blueprints that were created with
     a ``url_prefix`` value. :issue:`4037`
--   Roll back a change to the order that URL matching was done. The
+-   Revert a change to the order that URL matching was done. The
     URL is again matched after the session is loaded, so the session is
     available in custom URL converters. :issue:`4053`
 -   Re-add deprecated ``Config.from_json``, which was accidentally
@@ -184,17 +339,17 @@ Released 2021-05-11
     ``click.get_current_context().obj`` if it's needed. :issue:`3552`
 -   The CLI shows better error messages when the app failed to load
     when looking up commands. :issue:`2741`
--   Add :meth:`sessions.SessionInterface.get_cookie_name` to allow
-    setting the session cookie name dynamically. :pr:`3369`
--   Add :meth:`Config.from_file` to load config using arbitrary file
+-   Add ``SessionInterface.get_cookie_name`` to allow setting the
+    session cookie name dynamically. :pr:`3369`
+-   Add ``Config.from_file`` to load config using arbitrary file
     loaders, such as ``toml.load`` or ``json.load``.
-    :meth:`Config.from_json` is deprecated in favor of this. :pr:`3398`
+    ``Config.from_json`` is deprecated in favor of this. :pr:`3398`
 -   The ``flask run`` command will only defer errors on reload. Errors
     present during the initial call will cause the server to exit with
     the traceback immediately. :issue:`3431`
--   :func:`send_file` raises a :exc:`ValueError` when passed an
-    :mod:`io` object in text mode. Previously, it would respond with
-    200 OK and an empty file. :issue:`3358`
+-   ``send_file`` raises a ``ValueError`` when passed an ``io`` object
+    in text mode. Previously, it would respond with 200 OK and an empty
+    file. :issue:`3358`
 -   When using ad-hoc certificates, check for the cryptography library
     instead of PyOpenSSL. :pr:`3492`
 -   When specifying a factory function with ``FLASK_APP``, keyword
@@ -305,31 +460,29 @@ Released 2019-07-04
     base ``HTTPException``. This makes error handler behavior more
     consistent. :pr:`3266`
 
-    -   :meth:`Flask.finalize_request` is called for all unhandled
+    -   ``Flask.finalize_request`` is called for all unhandled
         exceptions even if there is no ``500`` error handler.
 
--   :attr:`Flask.logger` takes the same name as
-    :attr:`Flask.name` (the value passed as
-    ``Flask(import_name)``. This reverts 1.0's behavior of always
-    logging to ``"flask.app"``, in order to support multiple apps in the
-    same process. A warning will be shown if old configuration is
+-   ``Flask.logger`` takes the same name as ``Flask.name`` (the value
+    passed as ``Flask(import_name)``. This reverts 1.0's behavior of
+    always logging to ``"flask.app"``, in order to support multiple apps
+    in the same process. A warning will be shown if old configuration is
     detected that needs to be moved. :issue:`2866`
--   :meth:`flask.RequestContext.copy` includes the current session
-    object in the request context copy. This prevents ``session``
-    pointing to an out-of-date object. :issue:`2935`
+-   ``RequestContext.copy`` includes the current session object in the
+    request context copy. This prevents ``session`` pointing to an
+    out-of-date object. :issue:`2935`
 -   Using built-in RequestContext, unprintable Unicode characters in
     Host header will result in a HTTP 400 response and not HTTP 500 as
     previously. :pr:`2994`
--   :func:`send_file` supports :class:`~os.PathLike` objects as
-    described in PEP 0519, to support :mod:`pathlib` in Python 3.
-    :pr:`3059`
--   :func:`send_file` supports :class:`~io.BytesIO` partial content.
+-   ``send_file`` supports ``PathLike`` objects as described in
+    :pep:`519`, to support ``pathlib`` in Python 3. :pr:`3059`
+-   ``send_file`` supports ``BytesIO`` partial content.
     :issue:`2957`
--   :func:`open_resource` accepts the "rt" file mode. This still does
-    the same thing as "r". :issue:`3163`
--   The :attr:`MethodView.methods` attribute set in a base class is used
-    by subclasses. :issue:`3138`
--   :attr:`Flask.jinja_options` is a ``dict`` instead of an
+-   ``open_resource`` accepts the "rt" file mode. This still does the
+    same thing as "r". :issue:`3163`
+-   The ``MethodView.methods`` attribute set in a base class is used by
+    subclasses. :issue:`3138`
+-   ``Flask.jinja_options`` is a ``dict`` instead of an
     ``ImmutableDict`` to allow easier configuration. Changes must still
     be made before creating the environment. :pr:`3190`
 -   Flask's ``JSONMixin`` for the request and response wrappers was
@@ -343,15 +496,14 @@ Released 2019-07-04
     :issue:`3134`
 -   Support empty ``static_folder`` without requiring setting an empty
     ``static_url_path`` as well. :pr:`3124`
--   :meth:`jsonify` supports :class:`dataclasses.dataclass` objects.
-    :pr:`3195`
--   Allow customizing the :attr:`Flask.url_map_class` used for routing.
+-   ``jsonify`` supports ``dataclass`` objects. :pr:`3195`
+-   Allow customizing the ``Flask.url_map_class`` used for routing.
     :pr:`3069`
 -   The development server port can be set to 0, which tells the OS to
     pick an available port. :issue:`2926`
--   The return value from :meth:`cli.load_dotenv` is more consistent
-    with the documentation. It will return ``False`` if python-dotenv is
-    not installed, or if the given path isn't a file. :issue:`2937`
+-   The return value from ``cli.load_dotenv`` is more consistent with
+    the documentation. It will return ``False`` if python-dotenv is not
+    installed, or if the given path isn't a file. :issue:`2937`
 -   Signaling support has a stub for the ``connect_via`` method when
     the Blinker library is not installed. :pr:`3208`
 -   Add an ``--extra-files`` option to the ``flask run`` CLI command to
@@ -390,7 +542,7 @@ Released 2019-07-04
     requires upgrading to Werkzeug 0.15.5. :issue:`3249`
 -   ``send_file`` url quotes the ":" and "/" characters for more
     compatible UTF-8 filename support in some browsers. :issue:`3074`
--   Fixes for PEP451 import loaders and pytest 5.x. :issue:`3275`
+-   Fixes for :pep:`451` import loaders and pytest 5.x. :issue:`3275`
 -   Show message about dotenv on stderr instead of stdout. :issue:`3285`
 
 
@@ -399,16 +551,16 @@ Version 1.0.3
 
 Released 2019-05-17
 
--   :func:`send_file` encodes filenames as ASCII instead of Latin-1
+-   ``send_file`` encodes filenames as ASCII instead of Latin-1
     (ISO-8859-1). This fixes compatibility with Gunicorn, which is
-    stricter about header encodings than PEP 3333. :issue:`2766`
+    stricter about header encodings than :pep:`3333`. :issue:`2766`
 -   Allow custom CLIs using ``FlaskGroup`` to set the debug flag without
     it always being overwritten based on environment variables.
     :pr:`2765`
 -   ``flask --version`` outputs Werkzeug's version and simplifies the
     Python version. :pr:`2825`
--   :func:`send_file` handles an ``attachment_filename`` that is a
-    native Python 2 string (bytes) with UTF-8 coded bytes. :issue:`2933`
+-   ``send_file`` handles an ``attachment_filename`` that is a native
+    Python 2 string (bytes) with UTF-8 coded bytes. :issue:`2933`
 -   A catch-all error handler registered for ``HTTPException`` will not
     handle ``RoutingException``, which is used internally during
     routing. This fixes the unexpected behavior that had been introduced
@@ -456,32 +608,30 @@ Released 2018-04-26
 -   Bump minimum dependency versions to the latest stable versions:
     Werkzeug >= 0.14, Jinja >= 2.10, itsdangerous >= 0.24, Click >= 5.1.
     :issue:`2586`
--   Skip :meth:`app.run <Flask.run>` when a Flask application is run
-    from the command line. This avoids some behavior that was confusing
-    to debug.
--   Change the default for :data:`JSONIFY_PRETTYPRINT_REGULAR` to
-    ``False``. :func:`~json.jsonify` returns a compact format by
-    default, and an indented format in debug mode. :pr:`2193`
--   :meth:`Flask.__init__ <Flask>` accepts the ``host_matching``
-    argument and sets it on :attr:`~Flask.url_map`. :issue:`1559`
--   :meth:`Flask.__init__ <Flask>` accepts the ``static_host`` argument
-    and passes it as the ``host`` argument when defining the static
-    route. :issue:`1559`
--   :func:`send_file` supports Unicode in ``attachment_filename``.
+-   Skip ``app.run`` when a Flask application is run from the command
+    line. This avoids some behavior that was confusing to debug.
+-   Change the default for ``JSONIFY_PRETTYPRINT_REGULAR`` to
+    ``False``. ``~json.jsonify`` returns a compact format by default,
+    and an indented format in debug mode. :pr:`2193`
+-   ``Flask.__init__`` accepts the ``host_matching`` argument and sets
+    it on ``Flask.url_map``. :issue:`1559`
+-   ``Flask.__init__`` accepts the ``static_host`` argument and passes
+    it as the ``host`` argument when defining the static route.
+    :issue:`1559`
+-   ``send_file`` supports Unicode in ``attachment_filename``.
     :pr:`2223`
--   Pass ``_scheme`` argument from :func:`url_for` to
-    :meth:`~Flask.handle_url_build_error`. :pr:`2017`
--   :meth:`~Flask.add_url_rule` accepts the
-    ``provide_automatic_options`` argument to disable adding the
-    ``OPTIONS`` method. :pr:`1489`
--   :class:`~views.MethodView` subclasses inherit method handlers from
-    base classes. :pr:`1936`
+-   Pass ``_scheme`` argument from ``url_for`` to
+    ``Flask.handle_url_build_error``. :pr:`2017`
+-   ``Flask.add_url_rule`` accepts the ``provide_automatic_options``
+    argument to disable adding the ``OPTIONS`` method. :pr:`1489`
+-   ``MethodView`` subclasses inherit method handlers from base classes.
+    :pr:`1936`
 -   Errors caused while opening the session at the beginning of the
     request are handled by the app's error handlers. :pr:`2254`
--   Blueprints gained :attr:`~Blueprint.json_encoder` and
-    :attr:`~Blueprint.json_decoder` attributes to override the app's
+-   Blueprints gained ``Blueprint.json_encoder`` and
+    ``Blueprint.json_decoder`` attributes to override the app's
     encoder and decoder. :pr:`1898`
--   :meth:`Flask.make_response` raises ``TypeError`` instead of
+-   ``Flask.make_response`` raises ``TypeError`` instead of
     ``ValueError`` for bad response types. The error messages have been
     improved to describe why the type is invalid. :pr:`2256`
 -   Add ``routes`` CLI command to output routes registered on the
@@ -496,52 +646,49 @@ Released 2018-04-26
     ``make_app`` from ``FLASK_APP``. :pr:`2297`
 -   Factory functions are not required to take a ``script_info``
     parameter to work with the ``flask`` command. If they take a single
-    parameter or a parameter named ``script_info``, the
-    :class:`~cli.ScriptInfo` object will be passed. :pr:`2319`
+    parameter or a parameter named ``script_info``, the ``ScriptInfo``
+    object will be passed. :pr:`2319`
 -   ``FLASK_APP`` can be set to an app factory, with arguments if
     needed, for example ``FLASK_APP=myproject.app:create_app('dev')``.
     :pr:`2326`
 -   ``FLASK_APP`` can point to local packages that are not installed in
     editable mode, although ``pip install -e`` is still preferred.
     :pr:`2414`
--   The :class:`~views.View` class attribute
-    :attr:`~views.View.provide_automatic_options` is set in
-    :meth:`~views.View.as_view`, to be detected by
-    :meth:`~Flask.add_url_rule`. :pr:`2316`
+-   The ``View`` class attribute
+    ``View.provide_automatic_options`` is set in ``View.as_view``, to be
+    detected by ``Flask.add_url_rule``. :pr:`2316`
 -   Error handling will try handlers registered for ``blueprint, code``,
     ``app, code``, ``blueprint, exception``, ``app, exception``.
     :pr:`2314`
 -   ``Cookie`` is added to the response's ``Vary`` header if the session
     is accessed at all during the request (and not deleted). :pr:`2288`
--   :meth:`~Flask.test_request_context` accepts ``subdomain`` and
+-   ``Flask.test_request_context`` accepts ``subdomain`` and
     ``url_scheme`` arguments for use when building the base URL.
     :pr:`1621`
--   Set :data:`APPLICATION_ROOT` to ``'/'`` by default. This was already
-    the implicit default when it was set to ``None``.
--   :data:`TRAP_BAD_REQUEST_ERRORS` is enabled by default in debug mode.
+-   Set ``APPLICATION_ROOT`` to ``'/'`` by default. This was already the
+    implicit default when it was set to ``None``.
+-   ``TRAP_BAD_REQUEST_ERRORS`` is enabled by default in debug mode.
     ``BadRequestKeyError`` has a message with the bad key in debug mode
     instead of the generic bad request message. :pr:`2348`
--   Allow registering new tags with
-    :class:`~json.tag.TaggedJSONSerializer` to support storing other
-    types in the session cookie. :pr:`2352`
+-   Allow registering new tags with ``TaggedJSONSerializer`` to support
+    storing other types in the session cookie. :pr:`2352`
 -   Only open the session if the request has not been pushed onto the
-    context stack yet. This allows :func:`~stream_with_context`
-    generators to access the same session that the containing view uses.
-    :pr:`2354`
+    context stack yet. This allows ``stream_with_context`` generators to
+    access the same session that the containing view uses. :pr:`2354`
 -   Add ``json`` keyword argument for the test client request methods.
     This will dump the given object as JSON and set the appropriate
     content type. :pr:`2358`
--   Extract JSON handling to a mixin applied to both the
-    :class:`Request` and :class:`Response` classes. This adds the
-    :meth:`~Response.is_json` and :meth:`~Response.get_json` methods to
-    the response to make testing JSON response much easier. :pr:`2358`
+-   Extract JSON handling to a mixin applied to both the ``Request`` and
+    ``Response`` classes. This adds the ``Response.is_json`` and
+    ``Response.get_json`` methods to the response to make testing JSON
+    response much easier. :pr:`2358`
 -   Removed error handler caching because it caused unexpected results
     for some exception inheritance hierarchies. Register handlers
     explicitly for each exception if you want to avoid traversing the
     MRO. :pr:`2362`
 -   Fix incorrect JSON encoding of aware, non-UTC datetimes. :pr:`2374`
 -   Template auto reloading will honor debug mode even even if
-    :attr:`~Flask.jinja_env` was already accessed. :pr:`2373`
+    ``Flask.jinja_env`` was already accessed. :pr:`2373`
 -   The following old deprecated code was removed. :issue:`2385`
 
     -   ``flask.ext`` - import extensions directly by their name instead
@@ -549,57 +696,55 @@ Released 2018-04-26
         ``import flask.ext.sqlalchemy`` becomes
         ``import flask_sqlalchemy``.
     -   ``Flask.init_jinja_globals`` - extend
-        :meth:`Flask.create_jinja_environment` instead.
+        ``Flask.create_jinja_environment`` instead.
     -   ``Flask.error_handlers`` - tracked by
-        :attr:`Flask.error_handler_spec`, use :meth:`Flask.errorhandler`
+        ``Flask.error_handler_spec``, use ``Flask.errorhandler``
         to register handlers.
     -   ``Flask.request_globals_class`` - use
-        :attr:`Flask.app_ctx_globals_class` instead.
-    -   ``Flask.static_path`` - use :attr:`Flask.static_url_path`
-        instead.
-    -   ``Request.module`` - use :attr:`Request.blueprint` instead.
-
--   The :attr:`Request.json` property is no longer deprecated.
-    :issue:`1421`
--   Support passing a :class:`~werkzeug.test.EnvironBuilder` or ``dict``
-    to :meth:`test_client.open <werkzeug.test.Client.open>`. :pr:`2412`
--   The ``flask`` command and :meth:`Flask.run` will load environment
+        ``Flask.app_ctx_globals_class`` instead.
+    -   ``Flask.static_path`` - use ``Flask.static_url_path`` instead.
+    -   ``Request.module`` - use ``Request.blueprint`` instead.
+
+-   The ``Request.json`` property is no longer deprecated. :issue:`1421`
+-   Support passing a ``EnvironBuilder`` or ``dict`` to
+    ``test_client.open``. :pr:`2412`
+-   The ``flask`` command and ``Flask.run`` will load environment
     variables from ``.env`` and ``.flaskenv`` files if python-dotenv is
     installed. :pr:`2416`
 -   When passing a full URL to the test client, the scheme in the URL is
-    used instead of :data:`PREFERRED_URL_SCHEME`. :pr:`2430`
--   :attr:`Flask.logger` has been simplified. ``LOGGER_NAME`` and
+    used instead of ``PREFERRED_URL_SCHEME``. :pr:`2430`
+-   ``Flask.logger`` has been simplified. ``LOGGER_NAME`` and
     ``LOGGER_HANDLER_POLICY`` config was removed. The logger is always
     named ``flask.app``. The level is only set on first access, it
-    doesn't check :attr:`Flask.debug` each time. Only one format is
-    used, not different ones depending on :attr:`Flask.debug`. No
-    handlers are removed, and a handler is only added if no handlers are
-    already configured. :pr:`2436`
+    doesn't check ``Flask.debug`` each time. Only one format is used,
+    not different ones depending on ``Flask.debug``. No handlers are
+    removed, and a handler is only added if no handlers are already
+    configured. :pr:`2436`
 -   Blueprint view function names may not contain dots. :pr:`2450`
 -   Fix a ``ValueError`` caused by invalid ``Range`` requests in some
     cases. :issue:`2526`
 -   The development server uses threads by default. :pr:`2529`
--   Loading config files with ``silent=True`` will ignore
-    :data:`~errno.ENOTDIR` errors. :pr:`2581`
+-   Loading config files with ``silent=True`` will ignore ``ENOTDIR``
+    errors. :pr:`2581`
 -   Pass ``--cert`` and ``--key`` options to ``flask run`` to run the
     development server over HTTPS. :pr:`2606`
--   Added :data:`SESSION_COOKIE_SAMESITE` to control the ``SameSite``
+-   Added ``SESSION_COOKIE_SAMESITE`` to control the ``SameSite``
     attribute on the session cookie. :pr:`2607`
--   Added :meth:`~flask.Flask.test_cli_runner` to create a Click runner
-    that can invoke Flask CLI commands for testing. :pr:`2636`
+-   Added ``Flask.test_cli_runner`` to create a Click runner that can
+    invoke Flask CLI commands for testing. :pr:`2636`
 -   Subdomain matching is disabled by default and setting
-    :data:`SERVER_NAME` does not implicitly enable it. It can be enabled
-    by passing ``subdomain_matching=True`` to the ``Flask`` constructor.
+    ``SERVER_NAME`` does not implicitly enable it. It can be enabled by
+    passing ``subdomain_matching=True`` to the ``Flask`` constructor.
     :pr:`2635`
 -   A single trailing slash is stripped from the blueprint
     ``url_prefix`` when it is registered with the app. :pr:`2629`
--   :meth:`Request.get_json` doesn't cache the result if parsing fails
-    when ``silent`` is true. :issue:`2651`
--   :func:`Request.get_json` no longer accepts arbitrary encodings.
-    Incoming JSON should be encoded using UTF-8 per :rfc:`8259`, but
-    Flask will autodetect UTF-8, -16, or -32. :pr:`2691`
--   Added :data:`MAX_COOKIE_SIZE` and :attr:`Response.max_cookie_size`
-    to control when Werkzeug warns about large cookies that browsers may
+-   ``Request.get_json`` doesn't cache the result if parsing fails when
+    ``silent`` is true. :issue:`2651`
+-   ``Request.get_json`` no longer accepts arbitrary encodings. Incoming
+    JSON should be encoded using UTF-8 per :rfc:`8259`, but Flask will
+    autodetect UTF-8, -16, or -32. :pr:`2691`
+-   Added ``MAX_COOKIE_SIZE`` and ``Response.max_cookie_size`` to
+    control when Werkzeug warns about large cookies that browsers may
     ignore. :pr:`2693`
 -   Updated documentation theme to make docs look better in small
     windows. :pr:`2709`
@@ -629,7 +774,7 @@ Version 0.12.3
 
 Released 2018-04-26
 
--   :func:`Request.get_json` no longer accepts arbitrary encodings.
+-   ``Request.get_json`` no longer accepts arbitrary encodings.
     Incoming JSON should be encoded using UTF-8 per :rfc:`8259`, but
     Flask will autodetect UTF-8, -16, or -32. :issue:`2692`
 -   Fix a Python warning about imports when using ``python -m flask``.
@@ -699,13 +844,12 @@ Version 0.11
 
 Released 2016-05-29, codename Absinthe
 
--   Added support to serializing top-level arrays to
-    :func:`flask.jsonify`. This introduces a security risk in ancient
-    browsers.
+-   Added support to serializing top-level arrays to ``jsonify``. This
+    introduces a security risk in ancient browsers.
 -   Added before_render_template signal.
--   Added ``**kwargs`` to :meth:`flask.Test.test_client` to support
-    passing additional keyword arguments to the constructor of
-    :attr:`flask.Flask.test_client_class`.
+-   Added ``**kwargs`` to ``Flask.test_client`` to support passing
+    additional keyword arguments to the constructor of
+    ``Flask.test_client_class``.
 -   Added ``SESSION_REFRESH_EACH_REQUEST`` config key that controls the
     set-cookie behavior. If set to ``True`` a permanent session will be
     refreshed each request and get their lifetime extended, if set to
@@ -715,9 +859,9 @@ Released 2016-05-29, codename Absinthe
 -   Made Flask support custom JSON mimetypes for incoming data.
 -   Added support for returning tuples in the form ``(response,
     headers)`` from a view function.
--   Added :meth:`flask.Config.from_json`.
--   Added :attr:`flask.Flask.config_class`.
--   Added :meth:`flask.Config.get_namespace`.
+-   Added ``Config.from_json``.
+-   Added ``Flask.config_class``.
+-   Added ``Config.get_namespace``.
 -   Templates are no longer automatically reloaded outside of debug
     mode. This can be configured with the new ``TEMPLATES_AUTO_RELOAD``
     config key.
@@ -725,7 +869,7 @@ Released 2016-05-29, codename Absinthe
     loader.
 -   Added support for explicit root paths when using Python 3.3's
     namespace packages.
--   Added :command:`flask` and the ``flask.cli`` module to start the
+-   Added ``flask`` and the ``flask.cli`` module to start the
     local debug server through the click CLI system. This is recommended
     over the old ``flask.run()`` method as it works faster and more
     reliable due to a different design and also replaces
@@ -736,7 +880,7 @@ Released 2016-05-29, codename Absinthe
     an extension author to create exceptions that will by default result
     in the HTTP error of their choosing, but may be caught with a custom
     error handler if desired.
--   Added :meth:`flask.Config.from_mapping`.
+-   Added ``Config.from_mapping``.
 -   Flask will now log by default even if debug is disabled. The log
     format is now hardcoded but the default log handling can be disabled
     through the ``LOGGER_HANDLER_POLICY`` configuration key.
@@ -754,9 +898,7 @@ Released 2016-05-29, codename Absinthe
     space included by default after separators.
 -   JSON responses are now terminated with a newline character, because
     it is a convention that UNIX text files end with a newline and some
-    clients don't deal well when this newline is missing. This came up
-    originally as a part of
-    https://github.com/postmanlabs/httpbin/issues/168. :pr:`1262`
+    clients don't deal well when this newline is missing. :pr:`1262`
 -   The automatically provided ``OPTIONS`` method is now correctly
     disabled if the user registered an overriding rule with the
     lowercase-version ``options``. :issue:`1288`
@@ -776,9 +918,9 @@ Released 2016-05-29, codename Absinthe
 -   Exceptions during teardown handling will no longer leave bad
     application contexts lingering around.
 -   Fixed broken ``test_appcontext_signals()`` test case.
--   Raise an :exc:`AttributeError` in :func:`flask.helpers.find_package`
-    with a useful message explaining why it is raised when a PEP 302
-    import hook is used without an ``is_package()`` method.
+-   Raise an ``AttributeError`` in ``helpers.find_package`` with a
+    useful message explaining why it is raised when a :pep:`302` import
+    hook is used without an ``is_package()`` method.
 -   Fixed an issue causing exceptions raised before entering a request
     or app context to be passed to teardown handlers.
 -   Fixed an issue with query parameters getting removed from requests
@@ -824,7 +966,7 @@ Released 2013-06-13, codename Limoncello
 -   Set the content-length header for x-sendfile.
 -   ``tojson`` filter now does not escape script blocks in HTML5
     parsers.
--   ``tojson`` used in templates is now safe by default due. This was
+-   ``tojson`` used in templates is now safe by default. This was
     allowed due to the different escaping behavior.
 -   Flask will now raise an error if you attempt to register a new
     function on an already used endpoint.
@@ -894,12 +1036,12 @@ Version 0.9
 
 Released 2012-07-01, codename Campari
 
--   The :func:`flask.Request.on_json_loading_failed` now returns a JSON
-    formatted response by default.
--   The :func:`flask.url_for` function now can generate anchors to the
-    generated links.
--   The :func:`flask.url_for` function now can also explicitly generate
-    URL rules specific to a given HTTP method.
+-   The ``Request.on_json_loading_failed`` now returns a JSON formatted
+    response by default.
+-   The ``url_for`` function now can generate anchors to the generated
+    links.
+-   The ``url_for`` function now can also explicitly generate URL rules
+    specific to a given HTTP method.
 -   Logger now only returns the debug log setting if it was not set
     explicitly.
 -   Unregister a circular dependency between the WSGI environment and
@@ -911,42 +1053,41 @@ Released 2012-07-01, codename Campari
 -   Session is now stored after callbacks so that if the session payload
     is stored in the session you can still modify it in an after request
     callback.
--   The :class:`flask.Flask` class will avoid importing the provided
-    import name if it can (the required first parameter), to benefit
-    tools which build Flask instances programmatically. The Flask class
-    will fall back to using import on systems with custom module hooks,
-    e.g. Google App Engine, or when the import name is inside a zip
-    archive (usually a .egg) prior to Python 2.7.
+-   The ``Flask`` class will avoid importing the provided import name if
+    it can (the required first parameter), to benefit tools which build
+    Flask instances programmatically. The Flask class will fall back to
+    using import on systems with custom module hooks, e.g. Google App
+    Engine, or when the import name is inside a zip archive (usually an
+    egg) prior to Python 2.7.
 -   Blueprints now have a decorator to add custom template filters
-    application wide, :meth:`flask.Blueprint.app_template_filter`.
+    application wide, ``Blueprint.app_template_filter``.
 -   The Flask and Blueprint classes now have a non-decorator method for
     adding custom template filters application wide,
-    :meth:`flask.Flask.add_template_filter` and
-    :meth:`flask.Blueprint.add_app_template_filter`.
--   The :func:`flask.get_flashed_messages` function now allows rendering
-    flashed message categories in separate blocks, through a
-    ``category_filter`` argument.
--   The :meth:`flask.Flask.run` method now accepts ``None`` for ``host``
-    and ``port`` arguments, using default values when ``None``. This
-    allows for calling run using configuration values, e.g.
+    ``Flask.add_template_filter`` and
+    ``Blueprint.add_app_template_filter``.
+-   The ``get_flashed_messages`` function now allows rendering flashed
+    message categories in separate blocks, through a ``category_filter``
+    argument.
+-   The ``Flask.run`` method now accepts ``None`` for ``host`` and
+    ``port`` arguments, using default values when ``None``. This allows
+    for calling run using configuration values, e.g.
     ``app.run(app.config.get('MYHOST'), app.config.get('MYPORT'))``,
     with proper behavior whether or not a config file is provided.
--   The :meth:`flask.render_template` method now accepts a either an
-    iterable of template names or a single template name. Previously, it
-    only accepted a single template name. On an iterable, the first
-    template found is rendered.
--   Added :meth:`flask.Flask.app_context` which works very similar to
-    the request context but only provides access to the current
-    application. This also adds support for URL generation without an
-    active request context.
+-   The ``render_template`` method now accepts a either an iterable of
+    template names or a single template name. Previously, it only
+    accepted a single template name. On an iterable, the first template
+    found is rendered.
+-   Added ``Flask.app_context`` which works very similar to the request
+    context but only provides access to the current application. This
+    also adds support for URL generation without an active request
+    context.
 -   View functions can now return a tuple with the first instance being
-    an instance of :class:`flask.Response`. This allows for returning
+    an instance of ``Response``. This allows for returning
     ``jsonify(error="error msg"), 400`` from a view function.
--   :class:`~flask.Flask` and :class:`~flask.Blueprint` now provide a
-    :meth:`~flask.Flask.get_send_file_max_age` hook for subclasses to
-    override behavior of serving static files from Flask when using
-    :meth:`flask.Flask.send_static_file` (used for the default static
-    file handler) and :func:`~flask.helpers.send_file`. This hook is
+-   ``Flask`` and ``Blueprint`` now provide a ``get_send_file_max_age``
+    hook for subclasses to override behavior of serving static files
+    from Flask when using ``Flask.send_static_file`` (used for the
+    default static file handler) and ``helpers.send_file``. This hook is
     provided a filename, which for example allows changing cache
     controls by file extension. The default max-age for ``send_file``
     and static files can be configured through a new
@@ -958,14 +1099,13 @@ Released 2012-07-01, codename Campari
 -   Changed the behavior of tuple return values from functions. They are
     no longer arguments to the response object, they now have a defined
     meaning.
--   Added :attr:`flask.Flask.request_globals_class` to allow a specific
-    class to be used on creation of the :data:`~flask.g` instance of
-    each request.
+-   Added ``Flask.request_globals_class`` to allow a specific class to
+    be used on creation of the ``g`` instance of each request.
 -   Added ``required_methods`` attribute to view functions to force-add
     methods on registration.
--   Added :func:`flask.after_this_request`.
--   Added :func:`flask.stream_with_context` and the ability to push
-    contexts multiple times without producing unexpected behavior.
+-   Added ``flask.after_this_request``.
+-   Added ``flask.stream_with_context`` and the ability to push contexts
+    multiple times without producing unexpected behavior.
 
 
 Version 0.8.1
@@ -998,8 +1138,8 @@ Released 2011-09-29, codename Rakija
     earlier feedback when users forget to import view code ahead of
     time.
 -   Added the ability to register callbacks that are only triggered once
-    at the beginning of the first request.
-    (:meth:`Flask.before_first_request`)
+    at the beginning of the first request with
+    ``Flask.before_first_request``.
 -   Malformed JSON data will now trigger a bad request HTTP exception
     instead of a value error which usually would result in a 500
     internal server error if not handled. This is a backwards
@@ -1011,20 +1151,20 @@ Released 2011-09-29, codename Rakija
     version control so it's the perfect place to put configuration files
     etc.
 -   Added the ``APPLICATION_ROOT`` configuration variable.
--   Implemented :meth:`~flask.testing.TestClient.session_transaction` to
-    easily modify sessions from the test environment.
+-   Implemented ``TestClient.session_transaction`` to easily modify
+    sessions from the test environment.
 -   Refactored test client internally. The ``APPLICATION_ROOT``
     configuration variable as well as ``SERVER_NAME`` are now properly
     used by the test client as defaults.
--   Added :attr:`flask.views.View.decorators` to support simpler
-    decorating of pluggable (class-based) views.
+-   Added ``View.decorators`` to support simpler decorating of pluggable
+    (class-based) views.
 -   Fixed an issue where the test client if used with the "with"
     statement did not trigger the execution of the teardown handlers.
 -   Added finer control over the session cookie parameters.
 -   HEAD requests to a method view now automatically dispatch to the
     ``get`` method if no handler was implemented.
--   Implemented the virtual :mod:`flask.ext` package to import
-    extensions from.
+-   Implemented the virtual ``flask.ext`` package to import extensions
+    from.
 -   The context preservation on exceptions is now an integral component
     of Flask itself and no longer of the test client. This cleaned up
     some internal logic and lowers the odds of runaway request contexts
@@ -1057,14 +1197,13 @@ Version 0.7
 
 Released 2011-06-28, codename Grappa
 
--   Added :meth:`~flask.Flask.make_default_options_response` which can
-    be used by subclasses to alter the default behavior for ``OPTIONS``
-    responses.
--   Unbound locals now raise a proper :exc:`RuntimeError` instead of an
-    :exc:`AttributeError`.
+-   Added ``Flask.make_default_options_response`` which can be used by
+    subclasses to alter the default behavior for ``OPTIONS`` responses.
+-   Unbound locals now raise a proper ``RuntimeError`` instead of an
+    ``AttributeError``.
 -   Mimetype guessing and etag support based on file objects is now
-    deprecated for :func:`flask.send_file` because it was unreliable.
-    Pass filenames instead or attach your own etags and provide a proper
+    deprecated for ``send_file`` because it was unreliable. Pass
+    filenames instead or attach your own etags and provide a proper
     mimetype by hand.
 -   Static file handling for modules now requires the name of the static
     folder to be supplied explicitly. The previous autodetection was not
@@ -1090,15 +1229,15 @@ Released 2011-06-28, codename Grappa
     at the end of a request regardless of whether an exception occurred.
     Also the behavior for ``after_request`` was changed. It's now no
     longer executed when an exception is raised.
--   Implemented :func:`flask.has_request_context`
+-   Implemented ``has_request_context``.
 -   Deprecated ``init_jinja_globals``. Override the
-    :meth:`~flask.Flask.create_jinja_environment` method instead to
-    achieve the same functionality.
--   Added :func:`flask.safe_join`
+    ``Flask.create_jinja_environment`` method instead to achieve the
+    same functionality.
+-   Added ``safe_join``.
 -   The automatic JSON request data unpacking now looks at the charset
     mimetype parameter.
--   Don't modify the session on :func:`flask.get_flashed_messages` if
-    there are no messages in the session.
+-   Don't modify the session on ``get_flashed_messages`` if there are no
+    messages in the session.
 -   ``before_request`` handlers are now able to abort requests with
     errors.
 -   It is not possible to define user exception handlers. That way you
@@ -1140,29 +1279,25 @@ Released 2010-07-27, codename Whisky
 -   Static rules are now even in place if there is no static folder for
     the module. This was implemented to aid GAE which will remove the
     static folder if it's part of a mapping in the .yml file.
--   The :attr:`~flask.Flask.config` is now available in the templates as
-    ``config``.
+-   ``Flask.config`` is now available in the templates as ``config``.
 -   Context processors will no longer override values passed directly to
     the render function.
 -   Added the ability to limit the incoming request data with the new
     ``MAX_CONTENT_LENGTH`` configuration value.
--   The endpoint for the :meth:`flask.Module.add_url_rule` method is now
-    optional to be consistent with the function of the same name on the
+-   The endpoint for the ``Module.add_url_rule`` method is now optional
+    to be consistent with the function of the same name on the
     application object.
--   Added a :func:`flask.make_response` function that simplifies
-    creating response object instances in views.
+-   Added a ``make_response`` function that simplifies creating response
+    object instances in views.
 -   Added signalling support based on blinker. This feature is currently
     optional and supposed to be used by extensions and applications. If
-    you want to use it, make sure to have `blinker`_ installed.
+    you want to use it, make sure to have ``blinker`` installed.
 -   Refactored the way URL adapters are created. This process is now
-    fully customizable with the :meth:`~flask.Flask.create_url_adapter`
-    method.
+    fully customizable with the ``Flask.create_url_adapter`` method.
 -   Modules can now register for a subdomain instead of just an URL
     prefix. This makes it possible to bind a whole module to a
     configurable subdomain.
 
-.. _blinker: https://pypi.org/project/blinker/
-
 
 Version 0.5.2
 -------------
@@ -1196,8 +1331,8 @@ Released 2010-07-06, codename Calvados
     templates this behavior can be changed with the ``autoescape`` tag.
 -   Refactored Flask internally. It now consists of more than a single
     file.
--   :func:`flask.send_file` now emits etags and has the ability to do
-    conditional responses builtin.
+-   ``send_file`` now emits etags and has the ability to do conditional
+    responses builtin.
 -   (temporarily) dropped support for zipped applications. This was a
     rarely used feature and led to some confusing behavior.
 -   Added support for per-package template and static-file directories.
@@ -1213,9 +1348,8 @@ Released 2010-06-18, codename Rakia
 
 -   Added the ability to register application wide error handlers from
     modules.
--   :meth:`~flask.Flask.after_request` handlers are now also invoked if
-    the request dies with an exception and an error handling page kicks
-    in.
+-   ``Flask.after_request`` handlers are now also invoked if the request
+    dies with an exception and an error handling page kicks in.
 -   Test client has not the ability to preserve the request context for
     a little longer. This can also be used to trigger custom requests
     that do not pop the request stack for testing.
@@ -1230,8 +1364,8 @@ Version 0.3.1
 
 Released 2010-05-28
 
--   Fixed a error reporting bug with :meth:`flask.Config.from_envvar`
--   Removed some unused code from flask
+-   Fixed a error reporting bug with ``Config.from_envvar``.
+-   Removed some unused code.
 -   Release does no longer include development leftover files (.git
     folder for themes, built documentation in zip and pdf file and some
     .pyc files)
@@ -1243,9 +1377,9 @@ Version 0.3
 Released 2010-05-28, codename Schnaps
 
 -   Added support for categories for flashed messages.
--   The application now configures a :class:`logging.Handler` and will
-    log request handling exceptions to that logger when not in debug
-    mode. This makes it possible to receive mails on server errors for
+-   The application now configures a ``logging.Handler`` and will log
+    request handling exceptions to that logger when not in debug mode.
+    This makes it possible to receive mails on server errors for
     example.
 -   Added support for context binding that does not require the use of
     the with statement for playing in the console.
@@ -1261,14 +1395,13 @@ Released 2010-05-12, codename J?germeister
 
 -   Various bugfixes
 -   Integrated JSON support
--   Added :func:`~flask.get_template_attribute` helper function.
--   :meth:`~flask.Flask.add_url_rule` can now also register a view
-    function.
+-   Added ``get_template_attribute`` helper function.
+-   ``Flask.add_url_rule`` can now also register a view function.
 -   Refactored internal request dispatching.
 -   Server listens on 127.0.0.1 by default now to fix issues with
     chrome.
 -   Added external URL support.
--   Added support for :func:`~flask.send_file`
+-   Added support for ``send_file``.
 -   Module support and internal request handling refactoring to better
     support pluggable applications.
 -   Sessions can be set to be permanent now on a per-session basis.
diff --git a/CONTRIBUTING.rst b/CONTRIBUTING.rst
index a3c8b851..8d209048 100644
--- a/CONTRIBUTING.rst
+++ b/CONTRIBUTING.rst
@@ -14,11 +14,10 @@ own code:
 
 -   The ``#questions`` channel on our Discord chat:
     https://discord.gg/pallets
--   The mailing list flask@python.org for long term discussion or larger
-    issues.
 -   Ask on `Stack Overflow`_. Search with Google first using:
     ``site:stackoverflow.com flask {search term, exception message, etc.}``
--   Ask on our `GitHub Discussions`_.
+-   Ask on our `GitHub Discussions`_ for long term discussion or larger
+    questions.
 
 .. _Stack Overflow: https://stackoverflow.com/questions/tagged/flask?tab=Frequent
 .. _GitHub Discussions: https://github.com/pallets/flask/discussions
@@ -98,21 +97,20 @@ First time setup
 
 -   Create a virtualenv.
 
-    .. tabs::
 
-       .. group-tab:: Linux/macOS
+    - Linux/macOS
 
-          .. code-block:: text
+      .. code-block:: text
 
-             $ python3 -m venv env
-             $ . env/bin/activate
+         $ python3 -m venv env
+         $ . env/bin/activate
 
-       .. group-tab:: Windows
+    - Windows
 
-          .. code-block:: text
+      .. code-block:: text
 
-             > py -3 -m venv env
-             > env\Scripts\activate
+         > py -3 -m venv env
+         > env\Scripts\activate
 
 -   Upgrade pip and setuptools.
 
@@ -173,7 +171,7 @@ Start coding
 
         $ git push --set-upstream fork your-branch-name
 
-.. _committing as you go: https://dont-be-afraid-to-commit.readthedocs.io/en/latest/git/commandlinegit.html#commit-your-changes
+.. _committing as you go: https://afraid-to-commit.readthedocs.io/en/latest/git/commandlinegit.html#commit-your-changes
 .. _create a pull request: https://docs.github.com/en/github/collaborating-with-issues-and-pull-requests/creating-a-pull-request
 
 
diff --git a/docs/_static/pycharm-run-config.png b/docs/_static/pycharm-run-config.png
new file mode 100644
index 00000000..ad025545
Binary files /dev/null and b/docs/_static/pycharm-run-config.png differ
diff --git a/docs/_static/pycharm-runconfig.png b/docs/_static/pycharm-runconfig.png
deleted file mode 100644
index dff21fa0..00000000
Binary files a/docs/_static/pycharm-runconfig.png and /dev/null differ
diff --git a/docs/advanced_foreword.rst b/docs/advanced_foreword.rst
deleted file mode 100644
index 9c36158a..00000000
--- a/docs/advanced_foreword.rst
+++ /dev/null
@@ -1,46 +0,0 @@
-Foreword for Experienced Programmers
-====================================
-
-Thread-Locals in Flask
-----------------------
-
-One of the design decisions in Flask was that simple tasks should be simple;
-they should not take a lot of code and yet they should not limit you. Because
-of that, Flask has a few design choices that some people might find
-surprising or unorthodox. For example, Flask uses thread-local objects
-internally so that you dont have to pass objects around from
-function to function within a request in order to stay threadsafe.
-This approach is convenient, but requires a valid
-request context for dependency injection or when attempting to reuse code which
-uses a value pegged to the request.  The Flask project is honest about
-thread-locals, does not hide them, and calls out in the code and documentation
-where they are used.
-
-Develop for the Web with Caution
---------------------------------
-
-Always keep security in mind when building web applications.
-
-If you write a web application, you are probably allowing users to register
-and leave their data on your server.  The users are entrusting you with data.
-And even if you are the only user that might leave data in your application,
-you still want that data to be stored securely.
-
-Unfortunately, there are many ways the security of a web application can be
-compromised.  Flask protects you against one of the most common security
-problems of modern web applications: cross-site scripting (XSS).  Unless you
-deliberately mark insecure HTML as secure, Flask and the underlying Jinja2
-template engine have you covered.  But there are many more ways to cause
-security problems.
-
-The documentation will warn you about aspects of web development that require
-attention to security.  Some of these security concerns are far more complex
-than one might think, and we all sometimes underestimate the likelihood that a
-vulnerability will be exploited - until a clever attacker figures out a way to
-exploit our applications.  And don't think that your application is not
-important enough to attract an attacker.  Depending on the kind of attack,
-chances are that automated bots are probing for ways to fill your database with
-spam, links to malicious software, and the like.
-
-Flask is no different from any other framework in that you the developer must
-build with caution, watching for exploits when building to your requirements.
diff --git a/docs/api.rst b/docs/api.rst
index b3cffde2..afbe0b79 100644
--- a/docs/api.rst
+++ b/docs/api.rst
@@ -3,7 +3,7 @@ API
 
 .. module:: flask
 
-This part of the documentation covers all the interfaces of Flask.  For
+This part of the documentation covers all the interfaces of Flask. For
 parts where Flask depends on external libraries, we document the most
 important right here and provide links to the canonical documentation.
 
@@ -34,12 +34,12 @@ Incoming Request Data
 .. attribute:: request
 
    To access incoming request data, you can use the global `request`
-   object.  Flask parses incoming request data for you and gives you
-   access to it through that global object.  Internally Flask makes
+   object. Flask parses incoming request data for you and gives you
+   access to it through that global object. Internally Flask makes
    sure that you always get the correct data for the active thread if you
    are in a multithreaded environment.
 
-   This is a proxy.  See :ref:`notes-on-proxies` for more information.
+   This is a proxy. See :ref:`notes-on-proxies` for more information.
 
    The request object is an instance of a :class:`~flask.Request`.
 
@@ -69,7 +69,7 @@ To access the current session you can use the :class:`session` object:
    The session object works pretty much like an ordinary dict, with the
    difference that it keeps track of modifications.
 
-   This is a proxy.  See :ref:`notes-on-proxies` for more information.
+   This is a proxy. See :ref:`notes-on-proxies` for more information.
 
    The following attributes are interesting:
 
@@ -79,10 +79,10 @@ To access the current session you can use the :class:`session` object:
 
    .. attribute:: modified
 
-      ``True`` if the session object detected a modification.  Be advised
+      ``True`` if the session object detected a modification. Be advised
       that modifications on mutable structures are not picked up
       automatically, in that situation you have to explicitly set the
-      attribute to ``True`` yourself.  Here an example::
+      attribute to ``True`` yourself. Here an example::
 
           # this change is not picked up because a mutable object (here
           # a list) is changed.
@@ -93,8 +93,8 @@ To access the current session you can use the :class:`session` object:
    .. attribute:: permanent
 
       If set to ``True`` the session lives for
-      :attr:`~flask.Flask.permanent_session_lifetime` seconds.  The
-      default is 31 days.  If set to ``False`` (which is the default) the
+      :attr:`~flask.Flask.permanent_session_lifetime` seconds. The
+      default is 31 days. If set to ``False`` (which is the default) the
       session will be deleted when the user closes the browser.
 
 
@@ -125,10 +125,9 @@ implementation that Flask is using.
 
 .. admonition:: Notice
 
-   The ``PERMANENT_SESSION_LIFETIME`` config key can also be an integer
-   starting with Flask 0.8.  Either catch this down yourself or use
-   the :attr:`~flask.Flask.permanent_session_lifetime` attribute on the
-   app which converts the result to an integer automatically.
+    The :data:`PERMANENT_SESSION_LIFETIME` config can be an integer or ``timedelta``.
+    The :attr:`~flask.Flask.permanent_session_lifetime` attribute is always a
+    ``timedelta``.
 
 
 Test Client
@@ -156,9 +155,9 @@ Application Globals
 
 To share data that is valid for one request only from one function to
 another, a global variable is not good enough because it would break in
-threaded environments.  Flask provides you with a special object that
+threaded environments. Flask provides you with a special object that
 ensures it is only valid for the active request and that will return
-different values for each request.  In a nutshell: it does the right
+different values for each request. In a nutshell: it does the right
 thing, like it does for :class:`request` and :class:`session`.
 
 .. data:: g
@@ -236,26 +235,20 @@ JSON Support
 
 .. module:: flask.json
 
-Flask uses the built-in :mod:`json` module for handling JSON. It will
-use the current blueprint's or application's JSON encoder and decoder
-for easier customization. By default it handles some extra data types:
+Flask uses Python's built-in :mod:`json` module for handling JSON by
+default. The JSON implementation can be changed by assigning a different
+provider to :attr:`flask.Flask.json_provider_class` or
+:attr:`flask.Flask.json`. The functions provided by ``flask.json`` will
+use methods on ``app.json`` if an app context is active.
 
--   :class:`datetime.datetime` and :class:`datetime.date` are serialized
-    to :rfc:`822` strings. This is the same as the HTTP date format.
--   :class:`uuid.UUID` is serialized to a string.
--   :class:`dataclasses.dataclass` is passed to
-    :func:`dataclasses.asdict`.
--   :class:`~markupsafe.Markup` (or any object with a ``__html__``
-    method) will call the ``__html__`` method to get a string.
-
-Jinja's ``|tojson`` filter is configured to use Flask's :func:`dumps`
-function. The filter marks the output with ``|safe`` automatically. Use
-the filter to render data inside ``<script>`` tags.
+Jinja's ``|tojson`` filter is configured to use the app's JSON provider.
+The filter marks the output with ``|safe``. Use it to render data inside
+HTML ``<script>`` tags.
 
 .. sourcecode:: html+jinja
 
     <script>
-        const names = {{ names|tosjon }};
+        const names = {{ names|tojson }};
         renderChart(names, {{ axis_data|tojson }});
     </script>
 
@@ -269,6 +262,14 @@ the filter to render data inside ``<script>`` tags.
 
 .. autofunction:: load
 
+.. autoclass:: flask.json.provider.JSONProvider
+    :members:
+    :member-order: bysource
+
+.. autoclass:: flask.json.provider.DefaultJSONProvider
+    :members:
+    :member-order: bysource
+
 .. autoclass:: JSONEncoder
    :members:
 
@@ -287,6 +288,10 @@ Template Rendering
 
 .. autofunction:: render_template_string
 
+.. autofunction:: stream_template
+
+.. autofunction:: stream_template_string
+
 .. autofunction:: get_template_attribute
 
 Configuration
@@ -307,56 +312,28 @@ Useful Internals
 .. autoclass:: flask.ctx.RequestContext
    :members:
 
-.. data:: _request_ctx_stack
-
-    The internal :class:`~werkzeug.local.LocalStack` that holds
-    :class:`~flask.ctx.RequestContext` instances. Typically, the
-    :data:`request` and :data:`session` proxies should be accessed
-    instead of the stack. It may be useful to access the stack in
-    extension code.
-
-    The following attributes are always present on each layer of the
-    stack:
-
-    `app`
-      the active Flask application.
-
-    `url_adapter`
-      the URL adapter that was used to match the request.
-
-    `request`
-      the current request object.
-
-    `session`
-      the active session object.
-
-    `g`
-      an object with all the attributes of the :data:`flask.g` object.
-
-    `flashes`
-      an internal cache for the flashed messages.
-
-    Example usage::
+.. data:: flask.globals.request_ctx
 
-        from flask import _request_ctx_stack
+    The current :class:`~flask.ctx.RequestContext`. If a request context
+    is not active, accessing attributes on this proxy will raise a
+    ``RuntimeError``.
 
-        def get_session():
-            ctx = _request_ctx_stack.top
-            if ctx is not None:
-                return ctx.session
+    This is an internal object that is essential to how Flask handles
+    requests. Accessing this should not be needed in most cases. Most
+    likely you want :data:`request` and :data:`session` instead.
 
 .. autoclass:: flask.ctx.AppContext
    :members:
 
-.. data:: _app_ctx_stack
+.. data:: flask.globals.app_ctx
 
-    The internal :class:`~werkzeug.local.LocalStack` that holds
-    :class:`~flask.ctx.AppContext` instances. Typically, the
-    :data:`current_app` and :data:`g` proxies should be accessed instead
-    of the stack. Extensions can access the contexts on the stack as a
-    namespace to store data.
+    The current :class:`~flask.ctx.AppContext`. If an app context is not
+    active, accessing attributes on this proxy will raise a
+    ``RuntimeError``.
 
-    .. versionadded:: 0.9
+    This is an internal object that is essential to how Flask handles
+    requests. Accessing this should not be needed in most cases. Most
+    likely you want :data:`current_app` and :data:`g` instead.
 
 .. autoclass:: flask.blueprints.BlueprintSetupState
    :members:
@@ -370,14 +347,14 @@ Signals
 
 .. data:: signals.signals_available
 
-   ``True`` if the signaling system is available.  This is the case
+   ``True`` if the signaling system is available. This is the case
    when `blinker`_ is installed.
 
 The following signals exist in Flask:
 
 .. data:: template_rendered
 
-   This signal is sent when a template was successfully rendered.  The
+   This signal is sent when a template was successfully rendered. The
    signal is invoked with the instance of the template as `template`
    and the context as dictionary (named `context`).
 
@@ -411,7 +388,7 @@ The following signals exist in Flask:
 .. data:: request_started
 
    This signal is sent when the request context is set up, before
-   any request processing happens.  Because the request context is already
+   any request processing happens. Because the request context is already
    bound, the subscriber can access the request with the standard global
    proxies such as :class:`~flask.request`.
 
@@ -431,7 +408,7 @@ The following signals exist in Flask:
    Example subscriber::
 
         def log_response(sender, response, **extra):
-            sender.logger.debug('Request context is about to close down.  '
+            sender.logger.debug('Request context is about to close down. '
                                 'Response: %s', response)
 
         from flask import request_finished
@@ -468,8 +445,8 @@ The following signals exist in Flask:
 
 .. data:: request_tearing_down
 
-   This signal is sent when the request is tearing down.  This is always
-   called, even if an exception is caused.  Currently functions listening
+   This signal is sent when the request is tearing down. This is always
+   called, even if an exception is caused. Currently functions listening
    to this signal are called after the regular teardown handlers, but this
    is not something you can rely on.
 
@@ -487,8 +464,8 @@ The following signals exist in Flask:
 
 .. data:: appcontext_tearing_down
 
-   This signal is sent when the app context is tearing down.  This is always
-   called, even if an exception is caused.  Currently functions listening
+   This signal is sent when the app context is tearing down. This is always
+   called, even if an exception is caused. Currently functions listening
    to this signal are called after the regular teardown handlers, but this
    is not something you can rely on.
 
@@ -505,9 +482,9 @@ The following signals exist in Flask:
 
 .. data:: appcontext_pushed
 
-   This signal is sent when an application context is pushed.  The sender
-   is the application.  This is usually useful for unittests in order to
-   temporarily hook in information.  For instance it can be used to
+   This signal is sent when an application context is pushed. The sender
+   is the application. This is usually useful for unittests in order to
+   temporarily hook in information. For instance it can be used to
    set a resource early onto the `g` object.
 
    Example usage::
@@ -534,8 +511,8 @@ The following signals exist in Flask:
 
 .. data:: appcontext_popped
 
-   This signal is sent when an application context is popped.  The sender
-   is the application.  This usually falls in line with the
+   This signal is sent when an application context is popped. The sender
+   is the application. This usually falls in line with the
    :data:`appcontext_tearing_down` signal.
 
    .. versionadded:: 0.10
@@ -543,7 +520,7 @@ The following signals exist in Flask:
 
 .. data:: message_flashed
 
-   This signal is sent when the application is flashing a message.  The
+   This signal is sent when the application is flashing a message. The
    messages is sent as `message` keyword argument and the category as
    `category`.
 
@@ -561,7 +538,7 @@ The following signals exist in Flask:
 .. class:: signals.Namespace
 
    An alias for :class:`blinker.base.Namespace` if blinker is available,
-   otherwise a dummy class that creates fake signals.  This class is
+   otherwise a dummy class that creates fake signals. This class is
    available for Flask extensions that want to provide the same fallback
    system as Flask itself.
 
@@ -602,7 +579,7 @@ Generally there are three ways to define rules for the routing system:
     which is exposed as :attr:`flask.Flask.url_map`.
 
 Variable parts in the route can be specified with angular brackets
-(``/user/<username>``).  By default a variable part in the URL accepts any
+(``/user/<username>``). By default a variable part in the URL accepts any
 string without a slash however a different converter can be specified as
 well by using ``<converter:name>``.
 
@@ -636,7 +613,7 @@ Here are some examples::
         pass
 
 An important detail to keep in mind is how Flask deals with trailing
-slashes.  The idea is to keep each URL unique so the following rules
+slashes. The idea is to keep each URL unique so the following rules
 apply:
 
 1. If a rule ends with a slash and is requested without a slash by the
@@ -645,11 +622,11 @@ apply:
 2. If a rule does not end with a trailing slash and the user requests the
    page with a trailing slash, a 404 not found is raised.
 
-This is consistent with how web servers deal with static files.  This
+This is consistent with how web servers deal with static files. This
 also makes it possible to use relative link targets safely.
 
-You can also define multiple rules for the same function.  They have to be
-unique however.  Defaults can also be specified.  Here for example is a
+You can also define multiple rules for the same function. They have to be
+unique however. Defaults can also be specified. Here for example is a
 definition for a URL that accepts an optional page::
 
     @app.route('/users/', defaults={'page': 1})
@@ -672,33 +649,33 @@ can't preserve form data. ::
       pass
 
 Here are the parameters that :meth:`~flask.Flask.route` and
-:meth:`~flask.Flask.add_url_rule` accept.  The only difference is that
+:meth:`~flask.Flask.add_url_rule` accept. The only difference is that
 with the route parameter the view function is defined with the decorator
 instead of the `view_func` parameter.
 
 =============== ==========================================================
 `rule`          the URL rule as string
-`endpoint`      the endpoint for the registered URL rule.  Flask itself
+`endpoint`      the endpoint for the registered URL rule. Flask itself
                 assumes that the name of the view function is the name
                 of the endpoint if not explicitly stated.
 `view_func`     the function to call when serving a request to the
-                provided endpoint.  If this is not provided one can
+                provided endpoint. If this is not provided one can
                 specify the function later by storing it in the
                 :attr:`~flask.Flask.view_functions` dictionary with the
                 endpoint as key.
-`defaults`      A dictionary with defaults for this rule.  See the
+`defaults`      A dictionary with defaults for this rule. See the
                 example above for how defaults work.
 `subdomain`     specifies the rule for the subdomain in case subdomain
-                matching is in use.  If not specified the default
+                matching is in use. If not specified the default
                 subdomain is assumed.
 `**options`     the options to be forwarded to the underlying
-                :class:`~werkzeug.routing.Rule` object.  A change to
-                Werkzeug is handling of method options.  methods is a list
+                :class:`~werkzeug.routing.Rule` object. A change to
+                Werkzeug is handling of method options. methods is a list
                 of methods this rule should be limited to (``GET``, ``POST``
-                etc.).  By default a rule just listens for ``GET`` (and
-                implicitly ``HEAD``).  Starting with Flask 0.6, ``OPTIONS`` is
+                etc.). By default a rule just listens for ``GET`` (and
+                implicitly ``HEAD``). Starting with Flask 0.6, ``OPTIONS`` is
                 implicitly added and handled by the standard request
-                handling.  They have to be specified as keyword arguments.
+                handling. They have to be specified as keyword arguments.
 =============== ==========================================================
 
 
@@ -710,19 +687,19 @@ customize behavior the view function would normally not have control over.
 The following attributes can be provided optionally to either override
 some defaults to :meth:`~flask.Flask.add_url_rule` or general behavior:
 
--   `__name__`: The name of a function is by default used as endpoint.  If
-    endpoint is provided explicitly this value is used.  Additionally this
+-   `__name__`: The name of a function is by default used as endpoint. If
+    endpoint is provided explicitly this value is used. Additionally this
     will be prefixed with the name of the blueprint by default which
     cannot be customized from the function itself.
 
 -   `methods`: If methods are not provided when the URL rule is added,
     Flask will look on the view function object itself if a `methods`
-    attribute exists.  If it does, it will pull the information for the
+    attribute exists. If it does, it will pull the information for the
     methods from there.
 
 -   `provide_automatic_options`: if this attribute is set Flask will
     either force enable or disable the automatic implementation of the
-    HTTP ``OPTIONS`` response.  This can be useful when working with
+    HTTP ``OPTIONS`` response. This can be useful when working with
     decorators that want to customize the ``OPTIONS`` response on a per-view
     basis.
 
diff --git a/docs/appcontext.rst b/docs/appcontext.rst
index b214f254..a4ae3861 100644
--- a/docs/appcontext.rst
+++ b/docs/appcontext.rst
@@ -136,14 +136,6 @@ local from ``get_db()``::
 Accessing ``db`` will call ``get_db`` internally, in the same way that
 :data:`current_app` works.
 
-----
-
-If you're writing an extension, :data:`g` should be reserved for user
-code. You may store internal data on the context itself, but be sure to
-use a sufficiently unique name. The current context is accessed with
-:data:`_app_ctx_stack.top <_app_ctx_stack>`. For more information see
-:doc:`/extensiondev`.
-
 
 Events and Signals
 ------------------
diff --git a/docs/async-await.rst b/docs/async-await.rst
index 4c70f961..06a29fcc 100644
--- a/docs/async-await.rst
+++ b/docs/async-await.rst
@@ -70,8 +70,8 @@ If you wish to use background tasks it is best to use a task queue to
 trigger background work, rather than spawn tasks in a view
 function. With that in mind you can spawn asyncio tasks by serving
 Flask with an ASGI server and utilising the asgiref WsgiToAsgi adapter
-as described in :ref:`asgi`. This works as the adapter creates an
-event loop that runs continually.
+as described in :doc:`deploying/asgi`. This works as the adapter creates
+an event loop that runs continually.
 
 
 When to use Quart instead
@@ -91,7 +91,7 @@ patch low-level Python functions to accomplish this, whereas ``async``/
 whether you should use Flask, Quart, or something else is ultimately up
 to understanding the specific needs of your project.
 
-.. _Quart: https://gitlab.com/pgjones/quart
+.. _Quart: https://github.com/pallets/quart
 .. _ASGI: https://asgi.readthedocs.io/en/latest/
 
 
diff --git a/docs/becomingbig.rst b/docs/becomingbig.rst
deleted file mode 100644
index 5e7a88e0..00000000
--- a/docs/becomingbig.rst
+++ /dev/null
@@ -1,100 +0,0 @@
-Becoming Big
-============
-
-Here are your options when growing your codebase or scaling your application.
-
-Read the Source.
-----------------
-
-Flask started in part to demonstrate how to build your own framework on top of
-existing well-used tools Werkzeug (WSGI) and Jinja (templating), and as it
-developed, it became useful to a wide audience.  As you grow your codebase,
-don't just use Flask -- understand it.  Read the source.  Flask's code is
-written to be read; its documentation is published so you can use its internal
-APIs.  Flask sticks to documented APIs in upstream libraries, and documents its
-internal utilities so that you can find the hook points needed for your
-project.
-
-Hook. Extend.
--------------
-
-The :doc:`/api` docs are full of available overrides, hook points, and
-:doc:`/signals`. You can provide custom classes for things like the
-request and response objects. Dig deeper on the APIs you use, and look
-for the customizations which are available out of the box in a Flask
-release. Look for ways in which your project can be refactored into a
-collection of utilities and Flask extensions. Explore the many
-:doc:`/extensions` in the community, and look for patterns to build your
-own extensions if you do not find the tools you need.
-
-Subclass.
----------
-
-The :class:`~flask.Flask` class has many methods designed for subclassing. You
-can quickly add or customize behavior by subclassing :class:`~flask.Flask` (see
-the linked method docs) and using that subclass wherever you instantiate an
-application class. This works well with :doc:`/patterns/appfactories`.
-See :doc:`/patterns/subclassing` for an example.
-
-Wrap with middleware.
----------------------
-
-The :doc:`/patterns/appdispatch` pattern shows in detail how to apply middleware. You
-can introduce WSGI middleware to wrap your Flask instances and introduce fixes
-and changes at the layer between your Flask application and your HTTP
-server. Werkzeug includes several `middlewares
-<https://werkzeug.palletsprojects.com/middleware/>`_.
-
-Fork.
------
-
-If none of the above options work, fork Flask.  The majority of code of Flask
-is within Werkzeug and Jinja2.  These libraries do the majority of the work.
-Flask is just the paste that glues those together.  For every project there is
-the point where the underlying framework gets in the way (due to assumptions
-the original developers had).  This is natural because if this would not be the
-case, the framework would be a very complex system to begin with which causes a
-steep learning curve and a lot of user frustration.
-
-This is not unique to Flask.  Many people use patched and modified
-versions of their framework to counter shortcomings.  This idea is also
-reflected in the license of Flask.  You don't have to contribute any
-changes back if you decide to modify the framework.
-
-The downside of forking is of course that Flask extensions will most
-likely break because the new framework has a different import name.
-Furthermore integrating upstream changes can be a complex process,
-depending on the number of changes.  Because of that, forking should be
-the very last resort.
-
-Scale like a pro.
------------------
-
-For many web applications the complexity of the code is less an issue than
-the scaling for the number of users or data entries expected.  Flask by
-itself is only limited in terms of scaling by your application code, the
-data store you want to use and the Python implementation and webserver you
-are running on.
-
-Scaling well means for example that if you double the amount of servers
-you get about twice the performance.  Scaling bad means that if you add a
-new server the application won't perform any better or would not even
-support a second server.
-
-There is only one limiting factor regarding scaling in Flask which are
-the context local proxies.  They depend on context which in Flask is
-defined as being either a thread, process or greenlet.  If your server
-uses some kind of concurrency that is not based on threads or greenlets,
-Flask will no longer be able to support these global proxies.  However the
-majority of servers are using either threads, greenlets or separate
-processes to achieve concurrency which are all methods well supported by
-the underlying Werkzeug library.
-
-Discuss with the community.
----------------------------
-
-The Flask developers keep the framework accessible to users with codebases big
-and small. If you find an obstacle in your way, caused by Flask, don't hesitate
-to contact the developers on the mailing list or Discord server.  The best way for
-the Flask and Flask extension developers to improve the tools for larger
-applications is getting feedback from users.
diff --git a/docs/cli.rst b/docs/cli.rst
index 4b40307e..be5a0b70 100644
--- a/docs/cli.rst
+++ b/docs/cli.rst
@@ -15,40 +15,10 @@ Application Discovery
 ---------------------
 
 The ``flask`` command is installed by Flask, not your application; it must be
-told where to find your application in order to use it. The ``FLASK_APP``
-environment variable is used to specify how to load the application.
+told where to find your application in order to use it. The ``--app``
+option is used to specify how to load the application.
 
-.. tabs::
-
-   .. group-tab:: Bash
-
-      .. code-block:: text
-
-         $ export FLASK_APP=hello
-         $ flask run
-
-   .. group-tab:: Fish
-
-      .. code-block:: text
-
-         $ set -x FLASK_APP hello
-         $ flask run
-
-   .. group-tab:: CMD
-
-      .. code-block:: text
-
-         > set FLASK_APP=hello
-         > flask run
-
-   .. group-tab:: Powershell
-
-      .. code-block:: text
-
-         > $env:FLASK_APP = "hello"
-         > flask run
-
-While ``FLASK_APP`` supports a variety of options for specifying your
+While ``--app`` supports a variety of options for specifying your
 application, most use cases should be simple. Here are the typical values:
 
 (nothing)
@@ -56,32 +26,32 @@ application, most use cases should be simple. Here are the typical values:
     automatically detecting an app (``app`` or ``application``) or
     factory (``create_app`` or ``make_app``).
 
-``FLASK_APP=hello``
+``--app hello``
     The given name is imported, automatically detecting an app (``app``
     or ``application``) or factory (``create_app`` or ``make_app``).
 
 ----
 
-``FLASK_APP`` has three parts: an optional path that sets the current working
+``--app`` has three parts: an optional path that sets the current working
 directory, a Python file or dotted import path, and an optional variable
 name of the instance or factory. If the name is a factory, it can optionally
 be followed by arguments in parentheses. The following values demonstrate these
 parts:
 
-``FLASK_APP=src/hello``
+``--app src/hello``
     Sets the current working directory to ``src`` then imports ``hello``.
 
-``FLASK_APP=hello.web``
+``--app hello.web``
     Imports the path ``hello.web``.
 
-``FLASK_APP=hello:app2``
+``--app hello:app2``
     Uses the ``app2`` Flask instance in ``hello``.
 
-``FLASK_APP="hello:create_app('dev')"``
+``--app 'hello:create_app("dev")'``
     The ``create_app`` factory in ``hello`` is called with the string ``'dev'``
     as the argument.
 
-If ``FLASK_APP`` is not set, the command will try to import "app" or
+If ``--app`` is not set, the command will try to import "app" or
 "wsgi" (as a ".py" file, or package) and try to detect an application
 instance or factory.
 
@@ -101,7 +71,7 @@ Run the Development Server
 The :func:`run <cli.run_command>` command will start the development server. It
 replaces the :meth:`Flask.run` method in most cases. ::
 
-    $ flask run
+    $ flask --app hello run
      * Serving Flask app "hello"
      * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)
 
@@ -116,167 +86,64 @@ server tries to start. See :ref:`address-already-in-use` for how to
 handle that.
 
 
-Open a Shell
-------------
-
-To explore the data in your application, you can start an interactive Python
-shell with the :func:`shell <cli.shell_command>` command. An application
-context will be active, and the app instance will be imported. ::
-
-    $ flask shell
-    Python 3.10.0 (default, Oct 27 2021, 06:59:51) [GCC 11.1.0] on linux
-    App: example [production]
-    Instance: /home/david/Projects/pallets/flask/instance
-    >>>
-
-Use :meth:`~Flask.shell_context_processor` to add other automatic imports.
-
-
-Environments
-------------
-
-.. versionadded:: 1.0
-
-The environment in which the Flask app runs is set by the
-:envvar:`FLASK_ENV` environment variable. If not set it defaults to
-``production``. The other recognized environment is ``development``.
-Flask and extensions may choose to enable behaviors based on the
-environment.
-
-If the env is set to ``development``, the ``flask`` command will enable
-debug mode and ``flask run`` will enable the interactive debugger and
-reloader.
-
-.. tabs::
-
-   .. group-tab:: Bash
-
-      .. code-block:: text
-
-         $ export FLASK_ENV=development
-         $ flask run
-          * Serving Flask app "hello"
-          * Environment: development
-          * Debug mode: on
-          * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)
-          * Restarting with inotify reloader
-          * Debugger is active!
-          * Debugger PIN: 223-456-919
-
-   .. group-tab:: Fish
-
-      .. code-block:: text
-
-         $ set -x FLASK_ENV development
-         $ flask run
-          * Serving Flask app "hello"
-          * Environment: development
-          * Debug mode: on
-          * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)
-          * Restarting with inotify reloader
-          * Debugger is active!
-          * Debugger PIN: 223-456-919
-
-   .. group-tab:: CMD
-
-      .. code-block:: text
-
-         > set FLASK_ENV=development
-         > flask run
-          * Serving Flask app "hello"
-          * Environment: development
-          * Debug mode: on
-          * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)
-          * Restarting with inotify reloader
-          * Debugger is active!
-          * Debugger PIN: 223-456-919
-
-   .. group-tab:: Powershell
-
-      .. code-block:: text
-
-         > $env:FLASK_ENV = "development"
-         > flask run
-          * Serving Flask app "hello"
-          * Environment: development
-          * Debug mode: on
-          * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)
-          * Restarting with inotify reloader
-          * Debugger is active!
-          * Debugger PIN: 223-456-919
-
-
-Watch Extra Files with the Reloader
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+Debug Mode
+~~~~~~~~~~
 
-When using development mode, the reloader will trigger whenever your
-Python code or imported modules change. The reloader can watch
-additional files with the ``--extra-files`` option, or the
-``FLASK_RUN_EXTRA_FILES`` environment variable. Multiple paths are
-separated with ``:``, or ``;`` on Windows.
+In debug mode, the ``flask run`` command will enable the interactive debugger and the
+reloader by default, and make errors easier to see and debug. To enable debug mode, use
+the ``--debug`` option.
 
-.. tabs::
+.. code-block:: console
 
-   .. group-tab:: Bash
+     $ flask --app hello run --debug
+      * Serving Flask app "hello"
+      * Debug mode: on
+      * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)
+      * Restarting with inotify reloader
+      * Debugger is active!
+      * Debugger PIN: 223-456-919
 
-      .. code-block:: text
+The ``--debug`` option can also be passed to the top level ``flask`` command to enable
+debug mode for any command. The following two ``run`` calls are equivalent.
 
-          $ flask run --extra-files file1:dirA/file2:dirB/
-          # or
-          $ export FLASK_RUN_EXTRA_FILES=file1:dirA/file2:dirB/
-          $ flask run
-           * Running on http://127.0.0.1:8000/
-           * Detected change in '/path/to/file1', reloading
+.. code-block:: console
 
-   .. group-tab:: Fish
+    $ flask --app hello --debug run
+    $ flask --app hello run --debug
 
-      .. code-block:: text
 
-          $ flask run --extra-files file1:dirA/file2:dirB/
-          # or
-          $ set -x FLASK_RUN_EXTRA_FILES file1 dirA/file2 dirB/
-          $ flask run
-           * Running on http://127.0.0.1:8000/
-           * Detected change in '/path/to/file1', reloading
+Watch and Ignore Files with the Reloader
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
-   .. group-tab:: CMD
+When using debug mode, the reloader will trigger whenever your Python code or imported
+modules change. The reloader can watch additional files with the ``--extra-files``
+option. Multiple paths are separated with ``:``, or ``;`` on Windows.
 
-      .. code-block:: text
-
-          > flask run --extra-files file1:dirA/file2:dirB/
-          # or
-          > set FLASK_RUN_EXTRA_FILES=file1:dirA/file2:dirB/
-          > flask run
-           * Running on http://127.0.0.1:8000/
-           * Detected change in '/path/to/file1', reloading
-
-   .. group-tab:: Powershell
-
-      .. code-block:: text
+.. code-block:: text
 
-          > flask run --extra-files file1:dirA/file2:dirB/
-          # or
-          > $env:FLASK_RUN_EXTRA_FILES = "file1:dirA/file2:dirB/"
-          > flask run
-           * Running on http://127.0.0.1:8000/
-           * Detected change in '/path/to/file1', reloading
+    $ flask run --extra-files file1:dirA/file2:dirB/
+     * Running on http://127.0.0.1:8000/
+     * Detected change in '/path/to/file1', reloading
 
+The reloader can also ignore files using :mod:`fnmatch` patterns with the
+``--exclude-patterns`` option. Multiple patterns are separated with ``:``, or ``;`` on
+Windows.
 
-Ignore files with the Reloader
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
-The reloader can also ignore files using :mod:`fnmatch` patterns with
-the ``--exclude-patterns`` option, or the ``FLASK_RUN_EXCLUDE_PATTERNS``
-environment variable. Multiple patterns are separated with ``:``, or
-``;`` on Windows.
+Open a Shell
+------------
 
+To explore the data in your application, you can start an interactive Python
+shell with the :func:`shell <cli.shell_command>` command. An application
+context will be active, and the app instance will be imported. ::
 
-Debug Mode
-----------
+    $ flask shell
+    Python 3.10.0 (default, Oct 27 2021, 06:59:51) [GCC 11.1.0] on linux
+    App: example [production]
+    Instance: /home/david/Projects/pallets/flask/instance
+    >>>
 
-Debug mode will be enabled when :envvar:`FLASK_ENV` is ``development``,
-as described above. If you want to control debug mode separately, use
-:envvar:`FLASK_DEBUG`. The value ``1`` enables it, ``0`` disables it.
+Use :meth:`~Flask.shell_context_processor` to add other automatic imports.
 
 
 .. _dotenv:
@@ -284,14 +151,21 @@ as described above. If you want to control debug mode separately, use
 Environment Variables From dotenv
 ---------------------------------
 
-Rather than setting ``FLASK_APP`` each time you open a new terminal, you can
-use Flask's dotenv support to set environment variables automatically.
+The ``flask`` command supports setting any option for any command with
+environment variables. The variables are named like ``FLASK_OPTION`` or
+``FLASK_COMMAND_OPTION``, for example ``FLASK_APP`` or
+``FLASK_RUN_PORT``.
+
+Rather than passing options every time you run a command, or environment
+variables every time you open a new terminal, you can use Flask's dotenv
+support to set environment variables automatically.
 
 If `python-dotenv`_ is installed, running the ``flask`` command will set
-environment variables defined in the files :file:`.env` and :file:`.flaskenv`.
-This can be used to avoid having to set ``FLASK_APP`` manually every time you
-open a new terminal, and to set configuration using environment variables
-similar to how some deployment services work.
+environment variables defined in the files ``.env`` and ``.flaskenv``.
+You can also specify an extra file to load with the ``--env-file``
+option. Dotenv files can be used to avoid having to set ``--app`` or
+``FLASK_APP`` manually, and to set configuration using environment
+variables similar to how some deployment services work.
 
 Variables set on the command line are used over those set in :file:`.env`,
 which are used over those set in :file:`.flaskenv`. :file:`.flaskenv` should be
@@ -299,9 +173,7 @@ used for public variables, such as ``FLASK_APP``, while :file:`.env` should not
 be committed to your repository so that it can set private variables.
 
 Directories are scanned upwards from the directory you call ``flask``
-from to locate the files. The current working directory will be set to the
-location of the file, with the assumption that that is the top level project
-directory.
+from to locate the files.
 
 The files are only loaded by the ``flask`` command or calling
 :meth:`~Flask.run`. If you would like to load these files when running in
@@ -549,12 +421,14 @@ commands directly to the application's level:
 Application Context
 ~~~~~~~~~~~~~~~~~~~
 
-Commands added using the Flask app's :attr:`~Flask.cli`
-:meth:`~cli.AppGroup.command` decorator will be executed with an application
-context pushed, so your command and extensions have access to the app and its
-configuration. If you create a command using the Click :func:`~click.command`
-decorator instead of the Flask decorator, you can use
-:func:`~cli.with_appcontext` to get the same behavior. ::
+Commands added using the Flask app's :attr:`~Flask.cli` or
+:class:`~flask.cli.FlaskGroup` :meth:`~cli.AppGroup.command` decorator
+will be executed with an application context pushed, so your custom
+commands and parameters have access to the app and its configuration. The
+:func:`~cli.with_appcontext` decorator can be used to get the same
+behavior, but is not needed in most cases.
+
+.. code-block:: python
 
     import click
     from flask.cli import with_appcontext
@@ -566,12 +440,6 @@ decorator instead of the Flask decorator, you can use
 
     app.cli.add_command(do_work)
 
-If you're sure a command doesn't need the context, you can disable it::
-
-    @app.cli.command(with_appcontext=False)
-    def do_work():
-        ...
-
 
 Plugins
 -------
@@ -614,7 +482,7 @@ Custom Scripts
 --------------
 
 When you are using the app factory pattern, it may be more convenient to define
-your own Click script. Instead of using ``FLASK_APP`` and letting Flask load
+your own Click script. Instead of using ``--app`` and letting Flask load
 your application, you can create your own Click object and export it as a
 `console script`_ entry point.
 
@@ -648,7 +516,7 @@ Define the entry point in :file:`setup.py`::
     )
 
 Install the application in the virtualenv in editable mode and the custom
-script is available. Note that you don't need to set ``FLASK_APP``. ::
+script is available. Note that you don't need to set ``--app``. ::
 
     $ pip install -e .
     $ wiki run
@@ -668,53 +536,36 @@ script is available. Note that you don't need to set ``FLASK_APP``. ::
 PyCharm Integration
 -------------------
 
-PyCharm Professional provides a special Flask run configuration. For
-the Community Edition, we need to configure it to call the ``flask run``
-CLI command with the correct environment variables. These instructions
-should be similar for any other IDE you might want to use.
+PyCharm Professional provides a special Flask run configuration to run the development
+server. For the Community Edition, and for other commands besides ``run``, you need to
+create a custom run configuration. These instructions should be similar for any other
+IDE you use.
 
-In PyCharm, with your project open, click on *Run* from the menu bar and
-go to *Edit Configurations*. You'll be greeted by a screen similar to
-this:
+In PyCharm, with your project open, click on *Run* from the menu bar and go to *Edit
+Configurations*. You'll see a screen similar to this:
 
-.. image:: _static/pycharm-runconfig.png
+.. image:: _static/pycharm-run-config.png
     :align: center
     :class: screenshot
-    :alt: Screenshot of PyCharms's run configuration settings.
-
-There's quite a few options to change, but once we've done it for one
-command, we can easily copy the entire configuration and make a single
-tweak to give us access to other commands, including any custom ones you
-may implement yourself.
-
-Click the + (*Add New Configuration*) button and select *Python*. Give
-the configuration a name such as "flask run". For the ``flask run``
-command, check "Single instance only" since you can't run the server
-more than once at the same time.
+    :alt: Screenshot of PyCharm run configuration.
 
-Select *Module name* from the dropdown (**A**) then input ``flask``.
+Once you create a configuration for the ``flask run``, you can copy and change it to
+call any other command.
 
-The *Parameters* field (**B**) is set to the CLI command to execute
-(with any arguments). In this example we use ``run``, which will run
-the development server.
+Click the *+ (Add New Configuration)* button and select *Python*. Give the configuration
+a name such as "flask run".
 
-You can skip this next step if you're using :ref:`dotenv`. We need to
-add an environment variable (**C**) to identify our application. Click
-on the browse button and add an entry with ``FLASK_APP`` on the left and
-the Python import or file on the right (``hello`` for example). Add an
-entry with ``FLASK_ENV`` and set it to ``development``.
+Click the *Script path* dropdown and change it to *Module name*, then input ``flask``.
 
-Next we need to set the working directory (**D**) to be the folder where
-our application resides.
+The *Parameters* field is set to the CLI command to execute along with any arguments.
+This example uses ``--app hello run --debug``, which will run the development server in
+debug mode. ``--app hello`` should be the import or file with your Flask app.
 
-If you have installed your project as a package in your virtualenv, you
-may untick the *PYTHONPATH* options (**E**). This will more accurately
-match how you deploy the app later.
+If you installed your project as a package in your virtualenv, you may uncheck the
+*PYTHONPATH* options. This will more accurately match how you deploy later.
 
-Click *Apply* to save the configuration, or *OK* to save and close the
-window. Select the configuration in the main PyCharm window and click
-the play button next to it to run the server.
+Click *OK* to save and close the configuration. Select the configuration in the main
+PyCharm window and click the play button next to it to run the server.
 
-Now that we have a configuration which runs ``flask run`` from within
-PyCharm, we can copy that configuration and alter the *Script* argument
-to run a different CLI command, e.g. ``flask shell``.
+Now that you have a configuration for ``flask run``, you can copy that configuration and
+change the *Parameters* argument to run a different CLI command.
diff --git a/docs/conf.py b/docs/conf.py
index ae2922d7..f0be0722 100644
--- a/docs/conf.py
+++ b/docs/conf.py
@@ -29,7 +29,7 @@ intersphinx_mapping = {
     "itsdangerous": ("https://itsdangerous.palletsprojects.com/", None),
     "sqlalchemy": ("https://docs.sqlalchemy.org/", None),
     "wtforms": ("https://wtforms.readthedocs.io/", None),
-    "blinker": ("https://pythonhosted.org/blinker/", None),
+    "blinker": ("https://blinker.readthedocs.io/", None),
 }
 issues_github_path = "pallets/flask"
 
diff --git a/docs/config.rst b/docs/config.rst
index 7a5e4da1..9db2045f 100644
--- a/docs/config.rst
+++ b/docs/config.rst
@@ -42,66 +42,22 @@ method::
     )
 
 
-Environment and Debug Features
-------------------------------
+Debug Mode
+----------
 
-The :data:`ENV` and :data:`DEBUG` config values are special because they
-may behave inconsistently if changed after the app has begun setting up.
-In order to set the environment and debug mode reliably, Flask uses
-environment variables.
+The :data:`DEBUG` config value is special because it may behave inconsistently if
+changed after the app has begun setting up. In order to set debug mode reliably, use the
+``--debug`` option on the ``flask`` or ``flask run`` command. ``flask run`` will use the
+interactive debugger and reloader by default in debug mode.
 
-The environment is used to indicate to Flask, extensions, and other
-programs, like Sentry, what context Flask is running in. It is
-controlled with the :envvar:`FLASK_ENV` environment variable and
-defaults to ``production``.
-
-Setting :envvar:`FLASK_ENV` to ``development`` will enable debug mode.
-``flask run`` will use the interactive debugger and reloader by default
-in debug mode. To control this separately from the environment, use the
-:envvar:`FLASK_DEBUG` flag.
-
-.. versionchanged:: 1.0
-    Added :envvar:`FLASK_ENV` to control the environment separately
-    from debug mode. The development environment enables debug mode.
-
-To switch Flask to the development environment and enable debug mode,
-set :envvar:`FLASK_ENV`:
-
-.. tabs::
-
-   .. group-tab:: Bash
-
-      .. code-block:: text
-
-         $ export FLASK_ENV=development
-         $ flask run
-
-   .. group-tab:: Fish
-
-      .. code-block:: text
-
-         $ set -x FLASK_ENV development
-         $ flask run
-
-   .. group-tab:: CMD
-
-      .. code-block:: text
-
-         > set FLASK_ENV=development
-         > flask run
-
-   .. group-tab:: Powershell
-
-      .. code-block:: text
+.. code-block:: text
 
-         > $env:FLASK_ENV = "development"
-         > flask run
+    $ flask --app hello run --debug
 
-Using the environment variables as described above is recommended. While
-it is possible to set :data:`ENV` and :data:`DEBUG` in your config or
-code, this is strongly discouraged. They can't be read early by the
-``flask`` command, and some systems or extensions may have already
-configured themselves based on a previous value.
+Using the option is recommended. While it is possible to set :data:`DEBUG` in your
+config or code, this is strongly discouraged. It can't be read early by the
+``flask run`` command, and some systems or extensions may have already configured
+themselves based on a previous value.
 
 
 Builtin Configuration Values
@@ -111,32 +67,27 @@ The following configuration values are used internally by Flask:
 
 .. py:data:: ENV
 
-    What environment the app is running in. Flask and extensions may
-    enable behaviors based on the environment, such as enabling debug
-    mode. The :attr:`~flask.Flask.env` attribute maps to this config
-    key. This is set by the :envvar:`FLASK_ENV` environment variable and
-    may not behave as expected if set in code.
-
-    **Do not enable development when deploying in production.**
+    What environment the app is running in. The :attr:`~flask.Flask.env` attribute maps
+    to this config key.
 
     Default: ``'production'``
 
+    .. deprecated:: 2.2
+        Will be removed in Flask 2.3. Use ``--debug`` instead.
+
     .. versionadded:: 1.0
 
 .. py:data:: DEBUG
 
-    Whether debug mode is enabled. When using ``flask run`` to start the
-    development server, an interactive debugger will be shown for
-    unhandled exceptions, and the server will be reloaded when code
-    changes. The :attr:`~flask.Flask.debug` attribute maps to this
-    config key. This is enabled when :data:`ENV` is ``'development'``
-    and is overridden by the ``FLASK_DEBUG`` environment variable. It
-    may not behave as expected if set in code.
+    Whether debug mode is enabled. When using ``flask run`` to start the development
+    server, an interactive debugger will be shown for unhandled exceptions, and the
+    server will be reloaded when code changes. The :attr:`~flask.Flask.debug` attribute
+    maps to this config key. This is set with the ``FLASK_DEBUG`` environment variable.
+    It may not behave as expected if set in code.
 
     **Do not enable debug mode when deploying in production.**
 
-    Default: ``True`` if :data:`ENV` is ``'development'``, or ``False``
-    otherwise.
+    Default: ``False``
 
 .. py:data:: TESTING
 
@@ -154,14 +105,6 @@ The following configuration values are used internally by Flask:
 
     Default: ``None``
 
-.. py:data:: PRESERVE_CONTEXT_ON_EXCEPTION
-
-    Don't pop the request context when an exception occurs. If not set, this
-    is true if ``DEBUG`` is true. This allows debuggers to introspect the
-    request data on errors, and should normally not need to be set directly.
-
-    Default: ``None``
-
 .. py:data:: TRAP_HTTP_EXCEPTIONS
 
     If there is no handler for an ``HTTPException``-type exception, re-raise it
@@ -337,6 +280,10 @@ The following configuration values are used internally by Flask:
 
     Default: ``True``
 
+    .. deprecated:: 2.2
+        Will be removed in Flask 2.3. Set ``app.json.ensure_ascii``
+        instead.
+
 .. py:data:: JSON_SORT_KEYS
 
     Sort the keys of JSON objects alphabetically. This is useful for caching
@@ -346,19 +293,30 @@ The following configuration values are used internally by Flask:
 
     Default: ``True``
 
+    .. deprecated:: 2.2
+        Will be removed in Flask 2.3. Set ``app.json.sort_keys``
+        instead.
+
 .. py:data:: JSONIFY_PRETTYPRINT_REGULAR
 
-    ``jsonify`` responses will be output with newlines, spaces, and indentation
-    for easier reading by humans. Always enabled in debug mode.
+    :func:`~flask.jsonify` responses will be output with newlines,
+    spaces, and indentation for easier reading by humans. Always enabled
+    in debug mode.
 
     Default: ``False``
 
+    .. deprecated:: 2.2
+        Will be removed in Flask 2.3. Set ``app.json.compact`` instead.
+
 .. py:data:: JSONIFY_MIMETYPE
 
     The mimetype of ``jsonify`` responses.
 
     Default: ``'application/json'``
 
+    .. deprecated:: 2.2
+        Will be removed in Flask 2.3. Set ``app.json.mimetype`` instead.
+
 .. py:data:: TEMPLATES_AUTO_RELOAD
 
     Reload templates when they are changed. If not set, it will be enabled in
@@ -420,17 +378,27 @@ The following configuration values are used internally by Flask:
 
     Added :data:`MAX_COOKIE_SIZE` to control a warning from Werkzeug.
 
+.. versionchanged:: 2.2
+    Removed ``PRESERVE_CONTEXT_ON_EXCEPTION``.
+
+.. versionchanged:: 2.2
+    ``JSON_AS_ASCII``, ``JSON_SORT_KEYS``,
+    ``JSONIFY_MIMETYPE``, and ``JSONIFY_PRETTYPRINT_REGULAR`` will be
+    removed in Flask 2.3. The default ``app.json`` provider has
+    equivalent attributes instead.
+
+.. versionchanged:: 2.2
+    ``ENV`` will be removed in Flask 2.3. Use ``--debug`` instead.
+
 
 Configuring from Python Files
 -----------------------------
 
-Configuration becomes more useful if you can store it in a separate file,
-ideally located outside the actual application package. This makes
-packaging and distributing your application possible via various package
-handling tools (:doc:`/patterns/distribute`) and finally modifying the
-configuration file afterwards.
+Configuration becomes more useful if you can store it in a separate file, ideally
+located outside the actual application package. You can deploy your application, then
+separately configure it for the specific deployment.
 
-So a common pattern is this::
+A common pattern is this::
 
     app = Flask(__name__)
     app.config.from_object('yourapplication.default_settings')
@@ -722,10 +690,8 @@ your configuration files.  However here a list of good recommendations:
     code at all.  If you are working often on different projects you can
     even create your own script for sourcing that activates a virtualenv
     and exports the development configuration for you.
--   Use a tool like `fabric`_ in production to push code and
-    configurations separately to the production server(s).  For some
-    details about how to do that, head over to the
-    :doc:`/patterns/fabric` pattern.
+-   Use a tool like `fabric`_ to push code and configuration separately
+    to the production server(s).
 
 .. _fabric: https://www.fabfile.org/
 
diff --git a/docs/debugging.rst b/docs/debugging.rst
index cd955312..18f42867 100644
--- a/docs/debugging.rst
+++ b/docs/debugging.rst
@@ -39,54 +39,22 @@ during a request. This debugger should only be used during development.
     security risk. Do not run the development server or debugger in a
     production environment.
 
-To enable the debugger, run the development server with the
-``FLASK_ENV`` environment variable set to ``development``. This puts
-Flask in debug mode, which changes how it handles some errors, and
-enables the debugger and reloader.
+The debugger is enabled by default when the development server is run in debug mode.
 
-.. tabs::
+.. code-block:: text
 
-   .. group-tab:: Bash
+    $ flask --app hello run --debug
 
-      .. code-block:: text
-
-         $ export FLASK_ENV=development
-         $ flask run
-
-   .. group-tab:: Fish
-
-      .. code-block:: text
-
-         $ set -x FLASK_ENV development
-         $ flask run
-
-   .. group-tab:: CMD
-
-      .. code-block:: text
-
-         > set FLASK_ENV=development
-         > flask run
-
-   .. group-tab:: Powershell
-
-      .. code-block:: text
-
-         > $env:FLASK_ENV = "development"
-         > flask run
-
-``FLASK_ENV`` can only be set as an environment variable. When running
-from Python code, passing ``debug=True`` enables debug mode, which is
-mostly equivalent. Debug mode can be controlled separately from
-``FLASK_ENV`` with the ``FLASK_DEBUG`` environment variable as well.
+When running from Python code, passing ``debug=True`` enables debug mode, which is
+mostly equivalent.
 
 .. code-block:: python
 
     app.run(debug=True)
 
-:doc:`/server` and :doc:`/cli` have more information about running the
-debugger, debug mode, and development mode. More information about the
-debugger can be found in the `Werkzeug documentation
-<https://werkzeug.palletsprojects.com/debug/>`__.
+:doc:`/server` and :doc:`/cli` have more information about running the debugger and
+debug mode. More information about the debugger can be found in the `Werkzeug
+documentation <https://werkzeug.palletsprojects.com/debug/>`__.
 
 
 External Debuggers
@@ -102,37 +70,9 @@ When using an external debugger, the app should still be in debug mode,
 but it can be useful to disable the built-in debugger and reloader,
 which can interfere.
 
-When running from the command line:
-
-.. tabs::
-
-   .. group-tab:: Bash
-
-      .. code-block:: text
-
-         $ export FLASK_ENV=development
-         $ flask run --no-debugger --no-reload
-
-   .. group-tab:: Fish
-
-      .. code-block:: text
-
-         $ set -x FLASK_ENV development
-         $ flask run --no-debugger --no-reload
-
-   .. group-tab:: CMD
-
-      .. code-block:: text
-
-         > set FLASK_ENV=development
-         > flask run --no-debugger --no-reload
-
-   .. group-tab:: Powershell
-
-      .. code-block:: text
+.. code-block:: text
 
-         > $env:FLASK_ENV = "development"
-         > flask run --no-debugger --no-reload
+    $ flask --app hello run --debug --no-debugger --no-reload
 
 When running from Python:
 
diff --git a/docs/deploying/apache-httpd.rst b/docs/deploying/apache-httpd.rst
new file mode 100644
index 00000000..bdeaf626
--- /dev/null
+++ b/docs/deploying/apache-httpd.rst
@@ -0,0 +1,66 @@
+Apache httpd
+============
+
+`Apache httpd`_ is a fast, production level HTTP server. When serving
+your application with one of the WSGI servers listed in :doc:`index`, it
+is often good or necessary to put a dedicated HTTP server in front of
+it. This "reverse proxy" can handle incoming requests, TLS, and other
+security and performance concerns better than the WSGI server.
+
+httpd can be installed using your system package manager, or a pre-built
+executable for Windows. Installing and running httpd itself is outside
+the scope of this doc. This page outlines the basics of configuring
+httpd to proxy your application. Be sure to read its documentation to
+understand what features are available.
+
+.. _Apache httpd: https://httpd.apache.org/
+
+
+Domain Name
+-----------
+
+Acquiring and configuring a domain name is outside the scope of this
+doc. In general, you will buy a domain name from a registrar, pay for
+server space with a hosting provider, and then point your registrar
+at the hosting provider's name servers.
+
+To simulate this, you can also edit your ``hosts`` file, located at
+``/etc/hosts`` on Linux. Add a line that associates a name with the
+local IP.
+
+Modern Linux systems may be configured to treat any domain name that
+ends with ``.localhost`` like this without adding it to the ``hosts``
+file.
+
+.. code-block:: python
+    :caption: ``/etc/hosts``
+
+    127.0.0.1 hello.localhost
+
+
+Configuration
+-------------
+
+The httpd configuration is located at ``/etc/httpd/conf/httpd.conf`` on
+Linux. It may be different depending on your operating system. Check the
+docs and look for ``httpd.conf``.
+
+Remove or comment out any existing ``DocumentRoot`` directive. Add the
+config lines below. We'll assume the WSGI server is listening locally at
+``http://127.0.0.1:8000``.
+
+.. code-block:: apache
+    :caption: ``/etc/httpd/conf/httpd.conf``
+
+    LoadModule proxy_module modules/mod_proxy.so
+    LoadModule proxy_http_module modules/mod_proxy_http.so
+    ProxyPass / http://127.0.0.1:8000/
+    RequestHeader set X-Forwarded-Proto http
+    RequestHeader set X-Forwarded-Prefix /
+
+The ``LoadModule`` lines might already exist. If so, make sure they are
+uncommented instead of adding them manually.
+
+Then :doc:`proxy_fix` so that your application uses the ``X-Forwarded``
+headers. ``X-Forwarded-For`` and ``X-Forwarded-Host`` are automatically
+set by ``ProxyPass``.
diff --git a/docs/deploying/asgi.rst b/docs/deploying/asgi.rst
index 39cd76b7..36acff8a 100644
--- a/docs/deploying/asgi.rst
+++ b/docs/deploying/asgi.rst
@@ -1,5 +1,3 @@
-.. _asgi:
-
 ASGI
 ====
 
diff --git a/docs/deploying/cgi.rst b/docs/deploying/cgi.rst
deleted file mode 100644
index 4c1cdfbf..00000000
--- a/docs/deploying/cgi.rst
+++ /dev/null
@@ -1,61 +0,0 @@
-CGI
-===
-
-If all other deployment methods do not work, CGI will work for sure.
-CGI is supported by all major servers but usually has a sub-optimal
-performance.
-
-This is also the way you can use a Flask application on Google's `App
-Engine`_, where execution happens in a CGI-like environment.
-
-.. admonition:: Watch Out
-
-   Please make sure in advance that any ``app.run()`` calls you might
-   have in your application file are inside an ``if __name__ ==
-   '__main__':`` block or moved to a separate file.  Just make sure it's
-   not called because this will always start a local WSGI server which
-   we do not want if we deploy that application to CGI / app engine.
-
-   With CGI, you will also have to make sure that your code does not contain
-   any ``print`` statements, or that ``sys.stdout`` is overridden by something
-   that doesn't write into the HTTP response.
-
-Creating a `.cgi` file
-----------------------
-
-First you need to create the CGI application file.  Let's call it
-:file:`yourapplication.cgi`::
-
-    #!/usr/bin/python
-    from wsgiref.handlers import CGIHandler
-    from yourapplication import app
-
-    CGIHandler().run(app)
-
-Server Setup
-------------
-
-Usually there are two ways to configure the server.  Either just copy the
-``.cgi`` into a :file:`cgi-bin` (and use `mod_rewrite` or something similar to
-rewrite the URL) or let the server point to the file directly.
-
-In Apache for example you can put something like this into the config:
-
-.. sourcecode:: apache
-
-    ScriptAlias /app /path/to/the/application.cgi
-
-On shared webhosting, though, you might not have access to your Apache config.
-In this case, a file called ``.htaccess``, sitting in the public directory
-you want your app to be available, works too but the ``ScriptAlias`` directive
-won't work in that case:
-
-.. sourcecode:: apache
-
-    RewriteEngine On
-    RewriteCond %{REQUEST_FILENAME} !-f # Don't interfere with static files
-    RewriteRule ^(.*)$ /path/to/the/application.cgi/$1 [L]
-
-For more information consult the documentation of your webserver.
-
-.. _App Engine: https://cloud.google.com/appengine/docs/
diff --git a/docs/deploying/eventlet.rst b/docs/deploying/eventlet.rst
new file mode 100644
index 00000000..243be5eb
--- /dev/null
+++ b/docs/deploying/eventlet.rst
@@ -0,0 +1,80 @@
+eventlet
+========
+
+Prefer using :doc:`gunicorn` with eventlet workers rather than using
+`eventlet`_ directly. Gunicorn provides a much more configurable and
+production-tested server.
+
+`eventlet`_ allows writing asynchronous, coroutine-based code that looks
+like standard synchronous Python. It uses `greenlet`_ to enable task
+switching without writing ``async/await`` or using ``asyncio``.
+
+:doc:`gevent` is another library that does the same thing. Certain
+dependencies you have, or other considerations, may affect which of the
+two you choose to use.
+
+eventlet provides a WSGI server that can handle many connections at once
+instead of one per worker process. You must actually use eventlet in
+your own code to see any benefit to using the server.
+
+.. _eventlet: https://eventlet.net/
+.. _greenlet: https://greenlet.readthedocs.io/en/latest/
+
+
+Installing
+----------
+
+When using eventlet, greenlet>=1.0 is required, otherwise context locals
+such as ``request`` will not work as expected. When using PyPy,
+PyPy>=7.3.7 is required.
+
+Create a virtualenv, install your application, then install
+``eventlet``.
+
+.. code-block:: text
+
+    $ cd hello-app
+    $ python -m venv venv
+    $ . venv/bin/activate
+    $ pip install .  # install your application
+    $ pip install eventlet
+
+
+Running
+-------
+
+To use eventlet to serve your application, write a script that imports
+its ``wsgi.server``, as well as your app or app factory.
+
+.. code-block:: python
+    :caption: ``wsgi.py``
+
+    import eventlet
+    from eventlet import wsgi
+    from hello import create_app
+
+    app = create_app()
+    wsgi.server(eventlet.listen(("127.0.0.1", 8000), app)
+
+.. code-block:: text
+
+    $ python wsgi.py
+    (x) wsgi starting up on http://127.0.0.1:8000
+
+
+Binding Externally
+------------------
+
+eventlet should not be run as root because it would cause your
+application code to run as root, which is not secure. However, this
+means it will not be possible to bind to port 80 or 443. Instead, a
+reverse proxy such as :doc:`nginx` or :doc:`apache-httpd` should be used
+in front of eventlet.
+
+You can bind to all external IPs on a non-privileged port by using
+``0.0.0.0`` in the server arguments shown in the previous section.
+Don't do this when using a reverse proxy setup, otherwise it will be
+possible to bypass the proxy.
+
+``0.0.0.0`` is not a valid address to navigate to, you'd use a specific
+IP address in your browser.
diff --git a/docs/deploying/fastcgi.rst b/docs/deploying/fastcgi.rst
deleted file mode 100644
index d3614d37..00000000
--- a/docs/deploying/fastcgi.rst
+++ /dev/null
@@ -1,238 +0,0 @@
-FastCGI
-=======
-
-FastCGI is a deployment option on servers like `nginx`_, `lighttpd`_, and
-`cherokee`_; see :doc:`uwsgi` and :doc:`wsgi-standalone` for other options.
-To use your WSGI application with any of them you will need a FastCGI
-server first. The most popular one is `flup`_ which we will use for
-this guide. Make sure to have it installed to follow along.
-
-.. admonition:: Watch Out
-
-   Please make sure in advance that any ``app.run()`` calls you might
-   have in your application file are inside an ``if __name__ ==
-   '__main__':`` block or moved to a separate file.  Just make sure it's
-   not called because this will always start a local WSGI server which
-   we do not want if we deploy that application to FastCGI.
-
-Creating a `.fcgi` file
------------------------
-
-First you need to create the FastCGI server file.  Let's call it
-`yourapplication.fcgi`::
-
-    #!/usr/bin/python
-    from flup.server.fcgi import WSGIServer
-    from yourapplication import app
-
-    if __name__ == '__main__':
-        WSGIServer(app).run()
-
-This is enough for Apache to work, however nginx and older versions of
-lighttpd need a socket to be explicitly passed to communicate with the
-FastCGI server.  For that to work you need to pass the path to the
-socket to the :class:`~flup.server.fcgi.WSGIServer`::
-
-    WSGIServer(application, bindAddress='/path/to/fcgi.sock').run()
-
-The path has to be the exact same path you define in the server
-config.
-
-Save the :file:`yourapplication.fcgi` file somewhere you will find it again.
-It makes sense to have that in :file:`/var/www/yourapplication` or something
-similar.
-
-Make sure to set the executable bit on that file so that the servers
-can execute it:
-
-.. sourcecode:: text
-
-    $ chmod +x /var/www/yourapplication/yourapplication.fcgi
-
-Configuring Apache
-------------------
-
-The example above is good enough for a basic Apache deployment but your
-`.fcgi` file will appear in your application URL e.g.
-``example.com/yourapplication.fcgi/news/``. There are few ways to configure
-your application so that yourapplication.fcgi does not appear in the URL.
-A preferable way is to use the ScriptAlias and SetHandler configuration
-directives to route requests to the FastCGI server. The following example
-uses FastCgiServer to start 5 instances of the application which will
-handle all incoming requests::
-
-    LoadModule fastcgi_module /usr/lib64/httpd/modules/mod_fastcgi.so
-
-    FastCgiServer /var/www/html/yourapplication/app.fcgi -idle-timeout 300 -processes 5
-
-    <VirtualHost *>
-        ServerName webapp1.mydomain.com
-        DocumentRoot /var/www/html/yourapplication
-
-        AddHandler fastcgi-script fcgi
-        ScriptAlias / /var/www/html/yourapplication/app.fcgi/
-
-        <Location />
-            SetHandler fastcgi-script
-        </Location>
-    </VirtualHost>
-
-These processes will be managed by Apache. If you're using a standalone
-FastCGI server, you can use the FastCgiExternalServer directive instead.
-Note that in the following the path is not real, it's simply used as an
-identifier to other
-directives such as AliasMatch::
-
-    FastCgiServer /var/www/html/yourapplication -host 127.0.0.1:3000
-
-If you cannot set ScriptAlias, for example on a shared web host, you can use
-WSGI middleware to remove yourapplication.fcgi from the URLs. Set .htaccess::
-
-    <IfModule mod_fcgid.c>
-       AddHandler fcgid-script .fcgi
-       <Files ~ (\.fcgi)>
-           SetHandler fcgid-script
-           Options +FollowSymLinks +ExecCGI
-       </Files>
-    </IfModule>
-
-    <IfModule mod_rewrite.c>
-       Options +FollowSymlinks
-       RewriteEngine On
-       RewriteBase /
-       RewriteCond %{REQUEST_FILENAME} !-f
-       RewriteRule ^(.*)$ yourapplication.fcgi/$1 [QSA,L]
-    </IfModule>
-
-Set yourapplication.fcgi::
-
-    #!/usr/bin/python
-    #: optional path to your local python site-packages folder
-    import sys
-    sys.path.insert(0, '<your_local_path>/lib/python<your_python_version>/site-packages')
-
-    from flup.server.fcgi import WSGIServer
-    from yourapplication import app
-
-    class ScriptNameStripper(object):
-       def __init__(self, app):
-           self.app = app
-
-       def __call__(self, environ, start_response):
-           environ['SCRIPT_NAME'] = ''
-           return self.app(environ, start_response)
-
-    app = ScriptNameStripper(app)
-
-    if __name__ == '__main__':
-        WSGIServer(app).run()
-
-Configuring lighttpd
---------------------
-
-A basic FastCGI configuration for lighttpd looks like that::
-
-    fastcgi.server = ("/yourapplication.fcgi" =>
-        ((
-            "socket" => "/tmp/yourapplication-fcgi.sock",
-            "bin-path" => "/var/www/yourapplication/yourapplication.fcgi",
-            "check-local" => "disable",
-            "max-procs" => 1
-        ))
-    )
-
-    alias.url = (
-        "/static/" => "/path/to/your/static/"
-    )
-
-    url.rewrite-once = (
-        "^(/static($|/.*))$" => "$1",
-        "^(/.*)$" => "/yourapplication.fcgi$1"
-    )
-
-Remember to enable the FastCGI, alias and rewrite modules. This configuration
-binds the application to ``/yourapplication``.  If you want the application to
-work in the URL root you have to work around a lighttpd bug with the
-:class:`~werkzeug.contrib.fixers.LighttpdCGIRootFix` middleware.
-
-Make sure to apply it only if you are mounting the application the URL
-root. Also, see the Lighty docs for more information on `FastCGI and Python
-<https://redmine.lighttpd.net/projects/lighttpd/wiki/Docs_ModFastCGI>`_ (note that
-explicitly passing a socket to run() is no longer necessary).
-
-Configuring nginx
------------------
-
-Installing FastCGI applications on nginx is a bit different because by
-default no FastCGI parameters are forwarded.
-
-A basic Flask FastCGI configuration for nginx looks like this::
-
-    location = /yourapplication { rewrite ^ /yourapplication/ last; }
-    location /yourapplication { try_files $uri @yourapplication; }
-    location @yourapplication {
-        include fastcgi_params;
-        fastcgi_split_path_info ^(/yourapplication)(.*)$;
-        fastcgi_param PATH_INFO $fastcgi_path_info;
-        fastcgi_param SCRIPT_NAME $fastcgi_script_name;
-        fastcgi_pass unix:/tmp/yourapplication-fcgi.sock;
-    }
-
-This configuration binds the application to ``/yourapplication``.  If you
-want to have it in the URL root it's a bit simpler because you don't
-have to figure out how to calculate ``PATH_INFO`` and ``SCRIPT_NAME``::
-
-    location / { try_files $uri @yourapplication; }
-    location @yourapplication {
-        include fastcgi_params;
-        fastcgi_param PATH_INFO $fastcgi_script_name;
-        fastcgi_param SCRIPT_NAME "";
-        fastcgi_pass unix:/tmp/yourapplication-fcgi.sock;
-    }
-
-Running FastCGI Processes
--------------------------
-
-Since nginx and others do not load FastCGI apps, you have to do it by
-yourself.  `Supervisor can manage FastCGI processes.
-<http://supervisord.org/configuration.html#fcgi-program-x-section-settings>`_
-You can look around for other FastCGI process managers or write a script
-to run your `.fcgi` file at boot, e.g. using a SysV ``init.d`` script.
-For a temporary solution, you can always run the ``.fcgi`` script inside
-GNU screen.  See ``man screen`` for details, and note that this is a
-manual solution which does not persist across system restart::
-
-    $ screen
-    $ /var/www/yourapplication/yourapplication.fcgi
-
-Debugging
----------
-
-FastCGI deployments tend to be hard to debug on most web servers.  Very
-often the only thing the server log tells you is something along the
-lines of "premature end of headers".  In order to debug the application
-the only thing that can really give you ideas why it breaks is switching
-to the correct user and executing the application by hand.
-
-This example assumes your application is called `application.fcgi` and
-that your web server user is `www-data`::
-
-    $ su www-data
-    $ cd /var/www/yourapplication
-    $ python application.fcgi
-    Traceback (most recent call last):
-      File "yourapplication.fcgi", line 4, in <module>
-    ImportError: No module named yourapplication
-
-In this case the error seems to be "yourapplication" not being on the
-python path.  Common problems are:
-
--   Relative paths being used.  Don't rely on the current working directory.
--   The code depending on environment variables that are not set by the
-    web server.
--   Different python interpreters being used.
-
-.. _nginx: https://nginx.org/
-.. _lighttpd: https://www.lighttpd.net/
-.. _cherokee: https://cherokee-project.com/
-.. _flup: https://pypi.org/project/flup/
diff --git a/docs/deploying/gevent.rst b/docs/deploying/gevent.rst
new file mode 100644
index 00000000..aae63e89
--- /dev/null
+++ b/docs/deploying/gevent.rst
@@ -0,0 +1,80 @@
+gevent
+======
+
+Prefer using :doc:`gunicorn` or :doc:`uwsgi` with gevent workers rather
+than using `gevent`_ directly. Gunicorn and uWSGI provide much more
+configurable and production-tested servers.
+
+`gevent`_ allows writing asynchronous, coroutine-based code that looks
+like standard synchronous Python. It uses `greenlet`_ to enable task
+switching without writing ``async/await`` or using ``asyncio``.
+
+:doc:`eventlet` is another library that does the same thing. Certain
+dependencies you have, or other considerations, may affect which of the
+two you choose to use.
+
+gevent provides a WSGI server that can handle many connections at once
+instead of one per worker process. You must actually use gevent in your
+own code to see any benefit to using the server.
+
+.. _gevent: https://www.gevent.org/
+.. _greenlet: https://greenlet.readthedocs.io/en/latest/
+
+
+Installing
+----------
+
+When using gevent, greenlet>=1.0 is required, otherwise context locals
+such as ``request`` will not work as expected. When using PyPy,
+PyPy>=7.3.7 is required.
+
+Create a virtualenv, install your application, then install ``gevent``.
+
+.. code-block:: text
+
+    $ cd hello-app
+    $ python -m venv venv
+    $ . venv/bin/activate
+    $ pip install .  # install your application
+    $ pip install gevent
+
+
+Running
+-------
+
+To use gevent to serve your application, write a script that imports its
+``WSGIServer``, as well as your app or app factory.
+
+.. code-block:: python
+    :caption: ``wsgi.py``
+
+    from gevent.pywsgi import WSGIServer
+    from hello import create_app
+
+    app = create_app()
+    http_server = WSGIServer(("127.0.0.1", 8000), app)
+    http_server.serve_forever()
+
+.. code-block:: text
+
+    $ python wsgi.py
+
+No output is shown when the server starts.
+
+
+Binding Externally
+------------------
+
+gevent should not be run as root because it would cause your
+application code to run as root, which is not secure. However, this
+means it will not be possible to bind to port 80 or 443. Instead, a
+reverse proxy such as :doc:`nginx` or :doc:`apache-httpd` should be used
+in front of gevent.
+
+You can bind to all external IPs on a non-privileged port by using
+``0.0.0.0`` in the server arguments shown in the previous section. Don't
+do this when using a reverse proxy setup, otherwise it will be possible
+to bypass the proxy.
+
+``0.0.0.0`` is not a valid address to navigate to, you'd use a specific
+IP address in your browser.
diff --git a/docs/deploying/gunicorn.rst b/docs/deploying/gunicorn.rst
new file mode 100644
index 00000000..93d11d39
--- /dev/null
+++ b/docs/deploying/gunicorn.rst
@@ -0,0 +1,130 @@
+Gunicorn
+========
+
+`Gunicorn`_ is a pure Python WSGI server with simple configuration and
+multiple worker implementations for performance tuning.
+
+*   It tends to integrate easily with hosting platforms.
+*   It does not support Windows (but does run on WSL).
+*   It is easy to install as it does not require additional dependencies
+    or compilation.
+*   It has built-in async worker support using gevent or eventlet.
+
+This page outlines the basics of running Gunicorn. Be sure to read its
+`documentation`_ and use ``gunicorn --help`` to understand what features
+are available.
+
+.. _Gunicorn: https://gunicorn.org/
+.. _documentation: https://docs.gunicorn.org/
+
+
+Installing
+----------
+
+Gunicorn is easy to install, as it does not require external
+dependencies or compilation. It runs on Windows only under WSL.
+
+Create a virtualenv, install your application, then install
+``gunicorn``.
+
+.. code-block:: text
+
+    $ cd hello-app
+    $ python -m venv venv
+    $ . venv/bin/activate
+    $ pip install .  # install your application
+    $ pip install gunicorn
+
+
+Running
+-------
+
+The only required argument to Gunicorn tells it how to load your Flask
+application. The syntax is ``{module_import}:{app_variable}``.
+``module_import`` is the dotted import name to the module with your
+application. ``app_variable`` is the variable with the application. It
+can also be a function call (with any arguments) if you're using the
+app factory pattern.
+
+.. code-block:: text
+
+    # equivalent to 'from hello import app'
+    $ gunicorn -w 4 'hello:app'
+
+    # equivalent to 'from hello import create_app; create_app()'
+    $ gunicorn -w 4 'hello:create_app()'
+
+    Starting gunicorn 20.1.0
+    Listening at: http://127.0.0.1:8000 (x)
+    Using worker: sync
+    Booting worker with pid: x
+    Booting worker with pid: x
+    Booting worker with pid: x
+    Booting worker with pid: x
+
+The ``-w`` option specifies the number of processes to run; a starting
+value could be ``CPU * 2``. The default is only 1 worker, which is
+probably not what you want for the default worker type.
+
+Logs for each request aren't shown by default, only worker info and
+errors are shown. To show access logs on stdout, use the
+``--access-logfile=-`` option.
+
+
+Binding Externally
+------------------
+
+Gunicorn should not be run as root because it would cause your
+application code to run as root, which is not secure. However, this
+means it will not be possible to bind to port 80 or 443. Instead, a
+reverse proxy such as :doc:`nginx` or :doc:`apache-httpd` should be used
+in front of Gunicorn.
+
+You can bind to all external IPs on a non-privileged port using the
+``-b 0.0.0.0`` option. Don't do this when using a reverse proxy setup,
+otherwise it will be possible to bypass the proxy.
+
+.. code-block:: text
+
+    $ gunicorn -w 4 -b 0.0.0.0 'hello:create_app()'
+    Listening at: http://0.0.0.0:8000 (x)
+
+``0.0.0.0`` is not a valid address to navigate to, you'd use a specific
+IP address in your browser.
+
+
+Async with gevent or eventlet
+-----------------------------
+
+The default sync worker is appropriate for many use cases. If you need
+asynchronous support, Gunicorn provides workers using either `gevent`_
+or `eventlet`_. This is not the same as Python's ``async/await``, or the
+ASGI server spec. You must actually use gevent/eventlet in your own code
+to see any benefit to using the workers.
+
+When using either gevent or eventlet, greenlet>=1.0 is required,
+otherwise context locals such as ``request`` will not work as expected.
+When using PyPy, PyPy>=7.3.7 is required.
+
+To use gevent:
+
+.. code-block:: text
+
+    $ gunicorn -k gevent 'hello:create_app()'
+    Starting gunicorn 20.1.0
+    Listening at: http://127.0.0.1:8000 (x)
+    Using worker: gevent
+    Booting worker with pid: x
+
+To use eventlet:
+
+.. code-block:: text
+
+    $ gunicorn -k eventlet 'hello:create_app()'
+    Starting gunicorn 20.1.0
+    Listening at: http://127.0.0.1:8000 (x)
+    Using worker: eventlet
+    Booting worker with pid: x
+
+.. _gevent: https://www.gevent.org/
+.. _eventlet: https://eventlet.net/
diff --git a/docs/deploying/index.rst b/docs/deploying/index.rst
index e1ed9269..4135596a 100644
--- a/docs/deploying/index.rst
+++ b/docs/deploying/index.rst
@@ -1,35 +1,79 @@
-Deployment Options
-==================
+Deploying to Production
+=======================
 
-While lightweight and easy to use, **Flask's built-in server is not suitable
-for production** as it doesn't scale well.  Some of the options available for
-properly running Flask in production are documented here.
+After developing your application, you'll want to make it available
+publicly to other users. When you're developing locally, you're probably
+using the built-in development server, debugger, and reloader. These
+should not be used in production. Instead, you should use a dedicated
+WSGI server or hosting platform, some of which will be described here.
 
-If you want to deploy your Flask application to a WSGI server not listed here,
-look up the server documentation about how to use a WSGI app with it.  Just
-remember that your :class:`Flask` application object is the actual WSGI
-application.
+"Production" means "not development", which applies whether you're
+serving your application publicly to millions of users or privately /
+locally to a single user. **Do not use the development server when
+deploying to production. It is intended for use only during local
+development. It is not designed to be particularly secure, stable, or
+efficient.**
 
+Self-Hosted Options
+-------------------
 
-Hosted options
---------------
+Flask is a WSGI *application*. A WSGI *server* is used to run the
+application, converting incoming HTTP requests to the standard WSGI
+environ, and converting outgoing WSGI responses to HTTP responses.
 
-- `Deploying Flask on Heroku <https://devcenter.heroku.com/articles/getting-started-with-python>`_
-- `Deploying Flask on Google App Engine <https://cloud.google.com/appengine/docs/standard/python3/runtime>`_
-- `Deploying Flask on Google Cloud Run <https://cloud.google.com/run/docs/quickstarts/build-and-deploy/python>`_
-- `Deploying Flask on AWS Elastic Beanstalk <https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/create-deploy-python-flask.html>`_
-- `Deploying on Azure (IIS) <https://docs.microsoft.com/en-us/azure/app-service/containers/how-to-configure-python>`_
-- `Deploying on PythonAnywhere <https://help.pythonanywhere.com/pages/Flask/>`_
+The primary goal of these docs is to familiarize you with the concepts
+involved in running a WSGI application using a production WSGI server
+and HTTP server. There are many WSGI servers and HTTP servers, with many
+configuration possibilities. The pages below discuss the most common
+servers, and show the basics of running each one. The next section
+discusses platforms that can manage this for you.
 
-Self-hosted options
--------------------
+.. toctree::
+    :maxdepth: 1
+
+    gunicorn
+    waitress
+    mod_wsgi
+    uwsgi
+    gevent
+    eventlet
+    asgi
+
+WSGI servers have HTTP servers built-in. However, a dedicated HTTP
+server may be safer, more efficient, or more capable. Putting an HTTP
+server in front of the WSGI server is called a "reverse proxy."
 
 .. toctree::
-   :maxdepth: 2
-
-   wsgi-standalone
-   uwsgi
-   mod_wsgi
-   fastcgi
-   cgi
-   asgi
+    :maxdepth: 1
+
+    proxy_fix
+    nginx
+    apache-httpd
+
+This list is not exhaustive, and you should evaluate these and other
+servers based on your application's needs. Different servers will have
+different capabilities, configuration, and support.
+
+
+Hosting Platforms
+-----------------
+
+There are many services available for hosting web applications without
+needing to maintain your own server, networking, domain, etc. Some
+services may have a free tier up to a certain time or bandwidth. Many of
+these services use one of the WSGI servers described above, or a similar
+interface. The links below are for some of the most common platforms,
+which have instructions for Flask, WSGI, or Python.
+
+- `PythonAnywhere <https://help.pythonanywhere.com/pages/Flask/>`_
+- `Google App Engine <https://cloud.google.com/appengine/docs/standard/python3/building-app>`_
+- `Google Cloud Run <https://cloud.google.com/run/docs/quickstarts/build-and-deploy/deploy-python-service>`_
+- `AWS Elastic Beanstalk <https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/create-deploy-python-flask.html>`_
+- `Microsoft Azure <https://docs.microsoft.com/en-us/azure/app-service/quickstart-python>`_
+
+This list is not exhaustive, and you should evaluate these and other
+services based on your application's needs. Different services will have
+different capabilities, configuration, pricing, and support.
+
+You'll probably need to :doc:`proxy_fix` when using most hosting
+platforms.
diff --git a/docs/deploying/mod_wsgi.rst b/docs/deploying/mod_wsgi.rst
index 801dfa5c..eae973de 100644
--- a/docs/deploying/mod_wsgi.rst
+++ b/docs/deploying/mod_wsgi.rst
@@ -1,216 +1,94 @@
-mod_wsgi (Apache)
-=================
+mod_wsgi
+========
 
-If you are using the `Apache`_ webserver, consider using `mod_wsgi`_.
+`mod_wsgi`_ is a WSGI server integrated with the `Apache httpd`_ server.
+The modern `mod_wsgi-express`_ command makes it easy to configure and
+start the server without needing to write Apache httpd configuration.
 
-.. admonition:: Watch Out
+*   Tightly integrated with Apache httpd.
+*   Supports Windows directly.
+*   Requires a compiler and the Apache development headers to install.
+*   Does not require a reverse proxy setup.
 
-   Please make sure in advance that any ``app.run()`` calls you might
-   have in your application file are inside an ``if __name__ ==
-   '__main__':`` block or moved to a separate file.  Just make sure it's
-   not called because this will always start a local WSGI server which
-   we do not want if we deploy that application to mod_wsgi.
+This page outlines the basics of running mod_wsgi-express, not the more
+complex installation and configuration with httpd. Be sure to read the
+`mod_wsgi-express`_, `mod_wsgi`_, and `Apache httpd`_ documentation to
+understand what features are available.
 
-.. _Apache: https://httpd.apache.org/
+.. _mod_wsgi-express: https://pypi.org/project/mod-wsgi/
+.. _mod_wsgi: https://modwsgi.readthedocs.io/
+.. _Apache httpd: https://httpd.apache.org/
 
-Installing `mod_wsgi`
----------------------
 
-If you don't have `mod_wsgi` installed yet you have to either install it
-using a package manager or compile it yourself.  The mod_wsgi
-`installation instructions`_ cover source installations on UNIX systems.
+Installing
+----------
 
-If you are using Ubuntu/Debian you can apt-get it and activate it as
-follows:
+Installing mod_wsgi requires a compiler and the Apache server and
+development headers installed. You will get an error if they are not.
+How to install them depends on the OS and package manager that you use.
 
-.. sourcecode:: text
+Create a virtualenv, install your application, then install
+``mod_wsgi``.
 
-    $ apt-get install libapache2-mod-wsgi-py3
+.. code-block:: text
 
-If you are using a yum based distribution (Fedora, OpenSUSE, etc..) you
-can install it as follows:
+    $ cd hello-app
+    $ python -m venv venv
+    $ . venv/bin/activate
+    $ pip install .  # install your application
+    $ pip install mod_wsgi
 
-.. sourcecode:: text
 
-    $ yum install mod_wsgi
+Running
+-------
 
-On FreeBSD install `mod_wsgi` by compiling the `www/mod_wsgi` port or by
-using pkg_add:
+The only argument to ``mod_wsgi-express`` specifies a script containing
+your Flask application, which must be called ``application``. You can
+write a small script to import your app with this name, or to create it
+if using the app factory pattern.
 
-.. sourcecode:: text
+.. code-block:: python
+    :caption: ``wsgi.py``
 
-    $ pkg install ap24-py37-mod_wsgi
+    from hello import app
 
-If you are using pkgsrc you can install `mod_wsgi` by compiling the
-`www/ap2-wsgi` package.
+    application = app
 
-If you encounter segfaulting child processes after the first apache
-reload you can safely ignore them.  Just restart the server.
+.. code-block:: python
+    :caption: ``wsgi.py``
 
-Creating a `.wsgi` file
------------------------
+    from hello import create_app
 
-To run your application you need a :file:`yourapplication.wsgi` file.
-This file contains the code `mod_wsgi` is executing on startup
-to get the application object.  The object called `application`
-in that file is then used as application.
-
-For most applications the following file should be sufficient::
-
-    from yourapplication import app as application
-
-If a factory function is used in a :file:`__init__.py` file, then the function should be imported::
-
-    from yourapplication import create_app
     application = create_app()
 
-If you don't have a factory function for application creation but a singleton
-instance you can directly import that one as `application`.
-
-Store that file somewhere that you will find it again (e.g.:
-:file:`/var/www/yourapplication`) and make sure that `yourapplication` and all
-the libraries that are in use are on the python load path.  If you don't
-want to install it system wide consider using a `virtual python`_
-instance.  Keep in mind that you will have to actually install your
-application into the virtualenv as well.  Alternatively there is the
-option to just patch the path in the ``.wsgi`` file before the import::
-
-    import sys
-    sys.path.insert(0, '/path/to/the/application')
-
-Configuring Apache
-------------------
-
-The last thing you have to do is to create an Apache configuration file
-for your application.  In this example we are telling `mod_wsgi` to
-execute the application under a different user for security reasons:
-
-.. sourcecode:: apache
-
-    <VirtualHost *>
-        ServerName example.com
-
-        WSGIDaemonProcess yourapplication user=user1 group=group1 threads=5
-        WSGIScriptAlias / /var/www/yourapplication/yourapplication.wsgi
-
-        <Directory /var/www/yourapplication>
-            WSGIProcessGroup yourapplication
-            WSGIApplicationGroup %{GLOBAL}
-            Order deny,allow
-            Allow from all
-        </Directory>
-    </VirtualHost>
-
-Note: WSGIDaemonProcess isn't implemented in Windows and Apache will
-refuse to run with the above configuration. On a Windows system, eliminate those lines:
-
-.. sourcecode:: apache
-
-    <VirtualHost *>
-        ServerName example.com
-        WSGIScriptAlias / C:\yourdir\yourapp.wsgi
-        <Directory C:\yourdir>
-            Order deny,allow
-            Allow from all
-        </Directory>
-    </VirtualHost>
-
-Note: There have been some changes in access control configuration
-for `Apache 2.4`_.
-
-.. _Apache 2.4: https://httpd.apache.org/docs/trunk/upgrading.html
-
-Most notably, the syntax for directory permissions has changed from httpd 2.2
-
-.. sourcecode:: apache
+Now run the ``mod_wsgi-express start-server`` command.
 
-    Order allow,deny
-    Allow from all
+.. code-block:: text
 
-to httpd 2.4 syntax
+    $ mod_wsgi-express start-server wsgi.py --processes 4
 
-.. sourcecode:: apache
+The ``--processes`` option specifies the number of worker processes to
+run; a starting value could be ``CPU * 2``.
 
-    Require all granted
+Logs for each request aren't show in the terminal. If an error occurs,
+its information is written to the error log file shown when starting the
+server.
 
 
-For more information consult the `mod_wsgi documentation`_.
-
-.. _mod_wsgi: https://github.com/GrahamDumpleton/mod_wsgi
-.. _installation instructions: https://modwsgi.readthedocs.io/en/develop/installation.html
-.. _virtual python: https://pypi.org/project/virtualenv/
-.. _mod_wsgi documentation: https://modwsgi.readthedocs.io/en/develop/index.html
-
-Troubleshooting
----------------
-
-If your application does not run, follow this guide to troubleshoot:
-
-**Problem:** application does not run, errorlog shows SystemExit ignored
-    You have an ``app.run()`` call in your application file that is not
-    guarded by an ``if __name__ == '__main__':`` condition.  Either
-    remove that :meth:`~flask.Flask.run` call from the file and move it
-    into a separate :file:`run.py` file or put it into such an if block.
-
-**Problem:** application gives permission errors
-    Probably caused by your application running as the wrong user.  Make
-    sure the folders the application needs access to have the proper
-    privileges set and the application runs as the correct user
-    (``user`` and ``group`` parameter to the `WSGIDaemonProcess`
-    directive)
-
-**Problem:** application dies with an error on print
-    Keep in mind that mod_wsgi disallows doing anything with
-    :data:`sys.stdout` and :data:`sys.stderr`.  You can disable this
-    protection from the config by setting the `WSGIRestrictStdout` to
-    ``off``:
-
-    .. sourcecode:: apache
-
-        WSGIRestrictStdout Off
-
-    Alternatively you can also replace the standard out in the .wsgi file
-    with a different stream::
-
-        import sys
-        sys.stdout = sys.stderr
-
-**Problem:** accessing resources gives IO errors
-    Your application probably is a single .py file you symlinked into
-    the site-packages folder.  Please be aware that this does not work,
-    instead you either have to put the folder into the pythonpath the
-    file is stored in, or convert your application into a package.
-
-    The reason for this is that for non-installed packages, the module
-    filename is used to locate the resources and for symlinks the wrong
-    filename is picked up.
-
-Support for Automatic Reloading
--------------------------------
-
-To help deployment tools you can activate support for automatic
-reloading.  Whenever something changes the ``.wsgi`` file, `mod_wsgi` will
-reload all the daemon processes for us.
-
-For that, just add the following directive to your `Directory` section:
-
-.. sourcecode:: apache
-
-   WSGIScriptReloading On
-
-Working with Virtual Environments
----------------------------------
+Binding Externally
+------------------
 
-Virtual environments have the advantage that they never install the
-required dependencies system wide so you have a better control over what
-is used where.  If you want to use a virtual environment with mod_wsgi
-you have to modify your ``.wsgi`` file slightly.
+Unlike the other WSGI servers in these docs, mod_wsgi can be run as
+root to bind to privileged ports like 80 and 443. However, it must be
+configured to drop permissions to a different user and group for the
+worker processes.
 
-Add the following lines to the top of your ``.wsgi`` file::
+For example, if you created a ``hello`` user and group, you should
+install your virtualenv and application as that user, then tell
+mod_wsgi to drop to that user after starting.
 
-    activate_this = '/path/to/env/bin/activate_this.py'
-    with open(activate_this) as file_:
-        exec(file_.read(), dict(__file__=activate_this))
+.. code-block:: text
 
-This sets up the load paths according to the settings of the virtual
-environment.  Keep in mind that the path has to be absolute.
+    $ sudo /home/hello/venv/bin/mod_wsgi-express start-server \
+        /home/hello/wsgi.py \
+        --user hello --group hello --port 80 --processes 4
diff --git a/docs/deploying/nginx.rst b/docs/deploying/nginx.rst
new file mode 100644
index 00000000..6b25c073
--- /dev/null
+++ b/docs/deploying/nginx.rst
@@ -0,0 +1,69 @@
+nginx
+=====
+
+`nginx`_ is a fast, production level HTTP server. When serving your
+application with one of the WSGI servers listed in :doc:`index`, it is
+often good or necessary to put a dedicated HTTP server in front of it.
+This "reverse proxy" can handle incoming requests, TLS, and other
+security and performance concerns better than the WSGI server.
+
+Nginx can be installed using your system package manager, or a pre-built
+executable for Windows. Installing and running Nginx itself is outside
+the scope of this doc. This page outlines the basics of configuring
+Nginx to proxy your application. Be sure to read its documentation to
+understand what features are available.
+
+.. _nginx: https://nginx.org/
+
+
+Domain Name
+-----------
+
+Acquiring and configuring a domain name is outside the scope of this
+doc. In general, you will buy a domain name from a registrar, pay for
+server space with a hosting provider, and then point your registrar
+at the hosting provider's name servers.
+
+To simulate this, you can also edit your ``hosts`` file, located at
+``/etc/hosts`` on Linux. Add a line that associates a name with the
+local IP.
+
+Modern Linux systems may be configured to treat any domain name that
+ends with ``.localhost`` like this without adding it to the ``hosts``
+file.
+
+.. code-block:: python
+    :caption: ``/etc/hosts``
+
+    127.0.0.1 hello.localhost
+
+
+Configuration
+-------------
+
+The nginx configuration is located at ``/etc/nginx/nginx.conf`` on
+Linux. It may be different depending on your operating system. Check the
+docs and look for ``nginx.conf``.
+
+Remove or comment out any existing ``server`` section. Add a ``server``
+section and use the ``proxy_pass`` directive to point to the address the
+WSGI server is listening on. We'll assume the WSGI server is listening
+locally at ``http://127.0.0.1:8000``.
+
+.. code-block:: nginx
+    :caption: ``/etc/nginx.conf``
+
+    server {
+        listen 80;
+        server_name _;
+
+        location / {
+            proxy_pass http://127.0.0.1:8000/;
+            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
+            proxy_set_header X-Forwarded-Proto $scheme;
+            proxy_set_header X-Forwarded-Host $host;
+            proxy_set_header X-Forwarded-Prefix /;
+        }
+    }
+
+Then :doc:`proxy_fix` so that your application uses these headers.
diff --git a/docs/deploying/proxy_fix.rst b/docs/deploying/proxy_fix.rst
new file mode 100644
index 00000000..e2c42e82
--- /dev/null
+++ b/docs/deploying/proxy_fix.rst
@@ -0,0 +1,33 @@
+Tell Flask it is Behind a Proxy
+===============================
+
+When using a reverse proxy, or many Python hosting platforms, the proxy
+will intercept and forward all external requests to the local WSGI
+server.
+
+From the WSGI server and Flask application's perspectives, requests are
+now coming from the HTTP server to the local address, rather than from
+the remote address to the external server address.
+
+HTTP servers should set ``X-Forwarded-`` headers to pass on the real
+values to the application. The application can then be told to trust and
+use those values by wrapping it with the
+:doc:`werkzeug:middleware/proxy_fix` middleware provided by Werkzeug.
+
+This middleware should only be used if the application is actually
+behind a proxy, and should be configured with the number of proxies that
+are chained in front of it. Not all proxies set all the headers. Since
+incoming headers can be faked, you must set how many proxies are setting
+each header so the middleware knows what to trust.
+
+.. code-block:: python
+
+    from werkzeug.middleware.proxy_fix import ProxyFix
+
+    app.wsgi_app = ProxyFix(
+        app.wsgi_app, x_for=1, x_proto=1, x_host=1, x_prefix=1
+    )
+
+Remember, only apply this middleware if you are behind a proxy, and set
+the correct number of proxies that set each header. It can be a security
+issue if you get this configuration wrong.
diff --git a/docs/deploying/uwsgi.rst b/docs/deploying/uwsgi.rst
index b6958dc0..2da5efe2 100644
--- a/docs/deploying/uwsgi.rst
+++ b/docs/deploying/uwsgi.rst
@@ -1,71 +1,145 @@
 uWSGI
 =====
 
-uWSGI is a deployment option on servers like `nginx`_, `lighttpd`_, and
-`cherokee`_; see :doc:`fastcgi` and :doc:`wsgi-standalone` for other options.
-To use your WSGI application with uWSGI protocol you will need a uWSGI server
-first. uWSGI is both a protocol and an application server; the application
-server can serve uWSGI, FastCGI, and HTTP protocols.
+`uWSGI`_ is a fast, compiled server suite with extensive configuration
+and capabilities beyond a basic server.
 
-The most popular uWSGI server is `uwsgi`_, which we will use for this
-guide. Make sure to have it installed to follow along.
+*   It can be very performant due to being a compiled program.
+*   It is complex to configure beyond the basic application, and has so
+    many options that it can be difficult for beginners to understand.
+*   It does not support Windows (but does run on WSL).
+*   It requires a compiler to install in some cases.
 
-.. admonition:: Watch Out
+This page outlines the basics of running uWSGI. Be sure to read its
+documentation to understand what features are available.
 
-   Please make sure in advance that any ``app.run()`` calls you might
-   have in your application file are inside an ``if __name__ ==
-   '__main__':`` block or moved to a separate file.  Just make sure it's
-   not called because this will always start a local WSGI server which
-   we do not want if we deploy that application to uWSGI.
+.. _uWSGI: https://uwsgi-docs.readthedocs.io/en/latest/
 
-Starting your app with uwsgi
-----------------------------
 
-`uwsgi` is designed to operate on WSGI callables found in python modules.
+Installing
+----------
 
-Given a flask application in myapp.py, use the following command:
+uWSGI has multiple ways to install it. The most straightforward is to
+install the ``pyuwsgi`` package, which provides precompiled wheels for
+common platforms. However, it does not provide SSL support, which can be
+provided with a reverse proxy instead.
 
-.. sourcecode:: text
+Create a virtualenv, install your application, then install ``pyuwsgi``.
 
-    $ uwsgi -s /tmp/yourapplication.sock --manage-script-name --mount /yourapplication=myapp:app
+.. code-block:: text
 
-The ``--manage-script-name`` will move the handling of ``SCRIPT_NAME``
-to uwsgi, since it is smarter about that.
-It is used together with the ``--mount`` directive which will make
-requests to ``/yourapplication`` be directed to ``myapp:app``.
-If your application is accessible at root level, you can use a
-single ``/`` instead of ``/yourapplication``. ``myapp`` refers to the name of
-the file of your flask application (without extension) or the module which
-provides ``app``. ``app`` is the callable inside of your application (usually
-the line reads ``app = Flask(__name__)``).
+    $ cd hello-app
+    $ python -m venv venv
+    $ . venv/bin/activate
+    $ pip install .  # install your application
+    $ pip install pyuwsgi
 
-If you want to deploy your flask application inside of a virtual environment,
-you need to also add ``--virtualenv /path/to/virtual/environment``. You might
-also need to add ``--plugin python`` or ``--plugin python3`` depending on which
-python version you use for your project.
+If you have a compiler available, you can install the ``uwsgi`` package
+instead. Or install the ``pyuwsgi`` package from sdist instead of wheel.
+Either method will include SSL support.
 
-Configuring nginx
+.. code-block:: text
+
+    $ pip install uwsgi
+
+    # or
+    $ pip install --no-binary pyuwsgi pyuwsgi
+
+
+Running
+-------
+
+The most basic way to run uWSGI is to tell it to start an HTTP server
+and import your application.
+
+.. code-block:: text
+
+    $ uwsgi --http 127.0.0.1:8000 --master -p 4 -w hello:app
+
+    *** Starting uWSGI 2.0.20 (64bit) on [x] ***
+    *** Operational MODE: preforking ***
+    mounting hello:app on /
+    spawned uWSGI master process (pid: x)
+    spawned uWSGI worker 1 (pid: x, cores: 1)
+    spawned uWSGI worker 2 (pid: x, cores: 1)
+    spawned uWSGI worker 3 (pid: x, cores: 1)
+    spawned uWSGI worker 4 (pid: x, cores: 1)
+    spawned uWSGI http 1 (pid: x)
+
+If you're using the app factory pattern, you'll need to create a small
+Python file to create the app, then point uWSGI at that.
+
+.. code-block:: python
+    :caption: ``wsgi.py``
+
+    from hello import create_app
+
+    app = create_app()
+
+.. code-block:: text
+
+    $ uwsgi --http 127.0.0.1:8000 --master -p 4 -w wsgi:app
+
+The ``--http`` option starts an HTTP server at 127.0.0.1 port 8000. The
+``--master`` option specifies the standard worker manager. The ``-p``
+option starts 4 worker processes; a starting value could be ``CPU * 2``.
+The ``-w`` option tells uWSGI how to import your application
+
+
+Binding Externally
+------------------
+
+uWSGI should not be run as root with the configuration shown in this doc
+because it would cause your application code to run as root, which is
+not secure. However, this means it will not be possible to bind to port
+80 or 443. Instead, a reverse proxy such as :doc:`nginx` or
+:doc:`apache-httpd` should be used in front of uWSGI. It is possible to
+run uWSGI as root securely, but that is beyond the scope of this doc.
+
+uWSGI has optimized integration with `Nginx uWSGI`_ and
+`Apache mod_proxy_uwsgi`_, and possibly other servers, instead of using
+a standard HTTP proxy. That configuration is beyond the scope of this
+doc, see the links for more information.
+
+.. _Nginx uWSGI: https://uwsgi-docs.readthedocs.io/en/latest/Nginx.html
+.. _Apache mod_proxy_uwsgi: https://uwsgi-docs.readthedocs.io/en/latest/Apache.html#mod-proxy-uwsgi
+
+You can bind to all external IPs on a non-privileged port using the
+``--http 0.0.0.0:8000`` option. Don't do this when using a reverse proxy
+setup, otherwise it will be possible to bypass the proxy.
+
+.. code-block:: text
+
+    $ uwsgi --http 0.0.0.0:8000 --master -p 4 -w wsgi:app
+
+``0.0.0.0`` is not a valid address to navigate to, you'd use a specific
+IP address in your browser.
+
+
+Async with gevent
 -----------------
 
-A basic flask nginx configuration looks like this::
+The default sync worker is appropriate for many use cases. If you need
+asynchronous support, uWSGI provides a `gevent`_ worker. This is not the
+same as Python's ``async/await``, or the ASGI server spec. You must
+actually use gevent in your own code to see any benefit to using the
+worker.
+
+When using gevent, greenlet>=1.0 is required, otherwise context locals
+such as ``request`` will not work as expected. When using PyPy,
+PyPy>=7.3.7 is required.
+
+.. code-block:: text
 
-    location = /yourapplication { rewrite ^ /yourapplication/; }
-    location /yourapplication { try_files $uri @yourapplication; }
-    location @yourapplication {
-      include uwsgi_params;
-      uwsgi_pass unix:/tmp/yourapplication.sock;
-    }
+    $ uwsgi --http 127.0.0.1:8000 --master --gevent 100 -w wsgi:app
 
-This configuration binds the application to ``/yourapplication``.  If you want
-to have it in the URL root its a bit simpler::
+    *** Starting uWSGI 2.0.20 (64bit) on [x] ***
+    *** Operational MODE: async ***
+    mounting hello:app on /
+    spawned uWSGI master process (pid: x)
+    spawned uWSGI worker 1 (pid: x, cores: 100)
+    spawned uWSGI http 1 (pid: x)
+    *** running gevent loop engine [addr:x] ***
 
-    location / { try_files $uri @yourapplication; }
-    location @yourapplication {
-        include uwsgi_params;
-        uwsgi_pass unix:/tmp/yourapplication.sock;
-    }
 
-.. _nginx: https://nginx.org/
-.. _lighttpd: https://www.lighttpd.net/
-.. _cherokee: https://cherokee-project.com/
-.. _uwsgi: https://uwsgi-docs.readthedocs.io/en/latest/
+.. _gevent: https://www.gevent.org/
diff --git a/docs/deploying/waitress.rst b/docs/deploying/waitress.rst
new file mode 100644
index 00000000..eb70e058
--- /dev/null
+++ b/docs/deploying/waitress.rst
@@ -0,0 +1,75 @@
+Waitress
+========
+
+`Waitress`_ is a pure Python WSGI server.
+
+*   It is easy to configure.
+*   It supports Windows directly.
+*   It is easy to install as it does not require additional dependencies
+    or compilation.
+*   It does not support streaming requests, full request data is always
+    buffered.
+*   It uses a single process with multiple thread workers.
+
+This page outlines the basics of running Waitress. Be sure to read its
+documentation and ``waitress-serve --help`` to understand what features
+are available.
+
+.. _Waitress: https://docs.pylonsproject.org/projects/waitress/
+
+
+Installing
+----------
+
+Create a virtualenv, install your application, then install
+``waitress``.
+
+.. code-block:: text
+
+    $ cd hello-app
+    $ python -m venv venv
+    $ . venv/bin/activate
+    $ pip install .  # install your application
+    $ pip install waitress
+
+
+Running
+-------
+
+The only required argument to ``waitress-serve`` tells it how to load
+your Flask application. The syntax is ``{module}:{app}``. ``module`` is
+the dotted import name to the module with your application. ``app`` is
+the variable with the application. If you're using the app factory
+pattern, use ``--call {module}:{factory}`` instead.
+
+.. code-block:: text
+
+    # equivalent to 'from hello import app'
+    $ waitress-serve --host 127.0.0.1 hello:app
+
+    # equivalent to 'from hello import create_app; create_app()'
+    $ waitress-serve --host 127.0.0.1 --call hello:create_app
+
+    Serving on http://127.0.0.1:8080
+
+The ``--host`` option binds the server to local ``127.0.0.1`` only.
+
+Logs for each request aren't shown, only errors are shown. Logging can
+be configured through the Python interface instead of the command line.
+
+
+Binding Externally
+------------------
+
+Waitress should not be run as root because it would cause your
+application code to run as root, which is not secure. However, this
+means it will not be possible to bind to port 80 or 443. Instead, a
+reverse proxy such as :doc:`nginx` or :doc:`apache-httpd` should be used
+in front of Waitress.
+
+You can bind to all external IPs on a non-privileged port by not
+specifying the ``--host`` option. Don't do this when using a revers
+proxy setup, otherwise it will be possible to bypass the proxy.
+
+``0.0.0.0`` is not a valid address to navigate to, you'd use a specific
+IP address in your browser.
diff --git a/docs/deploying/wsgi-standalone.rst b/docs/deploying/wsgi-standalone.rst
deleted file mode 100644
index e66eacba..00000000
--- a/docs/deploying/wsgi-standalone.rst
+++ /dev/null
@@ -1,262 +0,0 @@
-Standalone WSGI Servers
-=======================
-
-Most WSGI servers also provide HTTP servers, so they can run a WSGI
-application and make it available externally.
-
-It may still be a good idea to run the server behind a dedicated HTTP
-server such as Apache or Nginx. See :ref:`deploying-proxy-setups` if you
-run into issues with that.
-
-
-Gunicorn
---------
-
-`Gunicorn`_ is a WSGI and HTTP server for UNIX. To run a Flask
-application, tell Gunicorn how to import your Flask app object.
-
-.. code-block:: text
-
-    $ gunicorn -w 4 -b 0.0.0.0:5000 your_project:app
-
-The ``-w 4`` option uses 4 workers to handle 4 requests at once. The
-``-b 0.0.0.0:5000`` serves the application on all interfaces on port
-5000.
-
-Gunicorn provides many options for configuring the server, either
-through a configuration file or with command line options. Use
-``gunicorn --help`` or see the docs for more information.
-
-The command expects the name of your module or package to import and
-the application instance within the module. If you use the application
-factory pattern, you can pass a call to that.
-
-.. code-block:: text
-
-    $ gunicorn -w 4 -b 0.0.0.0:5000 "myproject:create_app()"
-
-
-Async with Gevent or Eventlet
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-The default sync worker is appropriate for many use cases. If you need
-asynchronous support, Gunicorn provides workers using either `gevent`_
-or `eventlet`_. This is not the same as Python's ``async/await``, or the
-ASGI server spec.
-
-When using either gevent or eventlet, greenlet>=1.0 is required,
-otherwise context locals such as ``request`` will not work as expected.
-When using PyPy, PyPy>=7.3.7 is required.
-
-To use gevent:
-
-.. code-block:: text
-
-    $ gunicorn -k gevent -b 0.0.0.0:5000 your_project:app
-
-To use eventlet:
-
-.. code-block:: text
-
-    $ gunicorn -k eventlet -b 0.0.0.0:5000 your_project:app
-
-
-.. _Gunicorn: https://gunicorn.org/
-.. _gevent: http://www.gevent.org/
-.. _eventlet: https://eventlet.net/
-.. _greenlet: https://greenlet.readthedocs.io/en/latest/
-
-
-uWSGI
------
-
-`uWSGI`_ is a fast application server written in C. It is very
-configurable, which makes it more complicated to setup than Gunicorn.
-It also provides many other utilities for writing robust web
-applications. To run a Flask application, tell uWSGI how to import
-your Flask app object.
-
-.. code-block:: text
-
-    $ uwsgi --master -p 4 --http 0.0.0.0:5000 -w your_project:app
-
-The ``-p 4`` option uses 4 workers to handle 4 requests at once. The
-``--http 0.0.0.0:5000`` serves the application on all interfaces on port
-5000.
-
-uWSGI has optimized integration with Nginx and Apache instead of using
-a standard HTTP proxy. See :doc:`configuring uWSGI and Nginx <uwsgi>`.
-
-
-Async with Gevent
-~~~~~~~~~~~~~~~~~
-
-The default sync worker is appropriate for many use cases. If you need
-asynchronous support, uWSGI provides workers using `gevent`_. It also
-supports other async modes, see the docs for more information. This is
-not the same as Python's ``async/await``, or the ASGI server spec.
-
-When using gevent, greenlet>=1.0 is required, otherwise context locals
-such as ``request`` will not work as expected. When using PyPy,
-PyPy>=7.3.7 is required.
-
-.. code-block:: text
-
-    $ uwsgi --master --gevent 100 --http 0.0.0.0:5000 -w your_project:app
-
-.. _uWSGI: https://uwsgi-docs.readthedocs.io/en/latest/
-
-
-Gevent
-------
-
-Prefer using `Gunicorn`_ with Gevent workers rather than using Gevent
-directly. Gunicorn provides a much more configurable and
-production-tested server. See the section on Gunicorn above.
-
-`Gevent`_ allows writing asynchronous, coroutine-based code that looks
-like standard synchronous Python. It uses `greenlet`_ to enable task
-switching without writing ``async/await`` or using ``asyncio``.
-
-It provides a WSGI server that can handle many connections at once
-instead of one per worker process.
-
-`Eventlet`_, described below, is another library that does the same
-thing. Certain dependencies you have, or other consideration, may affect
-which of the two you choose to use
-
-To use gevent to serve your application, import its ``WSGIServer`` and
-use it to run your ``app``.
-
-.. code-block:: python
-
-    from gevent.pywsgi import WSGIServer
-    from your_project import app
-
-    http_server = WSGIServer(("", 5000), app)
-    http_server.serve_forever()
-
-
-Eventlet
---------
-
-Prefer using `Gunicorn`_ with Eventlet workers rather than using
-Eventlet directly. Gunicorn provides a much more configurable and
-production-tested server. See the section on Gunicorn above.
-
-`Eventlet`_ allows writing asynchronous, coroutine-based code that looks
-like standard synchronous Python. It uses `greenlet`_ to enable task
-switching without writing ``async/await`` or using ``asyncio``.
-
-It provides a WSGI server that can handle many connections at once
-instead of one per worker process.
-
-`Gevent`_, described above, is another library that does the same
-thing. Certain dependencies you have, or other consideration, may affect
-which of the two you choose to use
-
-To use eventlet to serve your application, import its ``wsgi.server``
-and use it to run your ``app``.
-
-.. code-block:: python
-
-    import eventlet
-    from eventlet import wsgi
-    from your_project import app
-
-    wsgi.server(eventlet.listen(("", 5000), app)
-
-
-Twisted Web
------------
-
-`Twisted Web`_ is the web server shipped with `Twisted`_, a mature,
-non-blocking event-driven networking library. Twisted Web comes with a
-standard WSGI container which can be controlled from the command line using
-the ``twistd`` utility:
-
-.. code-block:: text
-
-    $ twistd web --wsgi myproject.app
-
-This example will run a Flask application called ``app`` from a module named
-``myproject``.
-
-Twisted Web supports many flags and options, and the ``twistd`` utility does
-as well; see ``twistd -h`` and ``twistd web -h`` for more information. For
-example, to run a Twisted Web server in the foreground, on port 8080, with an
-application from ``myproject``:
-
-.. code-block:: text
-
-    $ twistd -n web --port tcp:8080 --wsgi myproject.app
-
-.. _Twisted: https://twistedmatrix.com/trac/
-.. _Twisted Web: https://twistedmatrix.com/trac/wiki/TwistedWeb
-
-
-.. _deploying-proxy-setups:
-
-Proxy Setups
-------------
-
-If you deploy your application using one of these servers behind an HTTP proxy
-you will need to rewrite a few headers in order for the application to work.
-The two problematic values in the WSGI environment usually are ``REMOTE_ADDR``
-and ``HTTP_HOST``.  You can configure your httpd to pass these headers, or you
-can fix them in middleware.  Werkzeug ships a fixer that will solve some common
-setups, but you might want to write your own WSGI middleware for specific
-setups.
-
-Here's a simple nginx configuration which proxies to an application served on
-localhost at port 8000, setting appropriate headers:
-
-.. sourcecode:: nginx
-
-    server {
-        listen 80;
-
-        server_name _;
-
-        access_log  /var/log/nginx/access.log;
-        error_log  /var/log/nginx/error.log;
-
-        location / {
-            proxy_pass         http://127.0.0.1:8000/;
-            proxy_redirect     off;
-
-            proxy_set_header   Host                 $host;
-            proxy_set_header   X-Real-IP            $remote_addr;
-            proxy_set_header   X-Forwarded-For      $proxy_add_x_forwarded_for;
-            proxy_set_header   X-Forwarded-Proto    $scheme;
-        }
-    }
-
-If your httpd is not providing these headers, the most common setup invokes the
-host being set from ``X-Forwarded-Host`` and the remote address from
-``X-Forwarded-For``::
-
-    from werkzeug.middleware.proxy_fix import ProxyFix
-    app.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1, x_host=1)
-
-.. admonition:: Trusting Headers
-
-   Please keep in mind that it is a security issue to use such a middleware in
-   a non-proxy setup because it will blindly trust the incoming headers which
-   might be forged by malicious clients.
-
-If you want to rewrite the headers from another header, you might want to
-use a fixer like this::
-
-    class CustomProxyFix(object):
-
-        def __init__(self, app):
-            self.app = app
-
-        def __call__(self, environ, start_response):
-            host = environ.get('HTTP_X_FHOST', '')
-            if host:
-                environ['HTTP_HOST'] = host
-            return self.app(environ, start_response)
-
-    app.wsgi_app = CustomProxyFix(app.wsgi_app)
diff --git a/docs/design.rst b/docs/design.rst
index 5d57063e..066cf107 100644
--- a/docs/design.rst
+++ b/docs/design.rst
@@ -130,9 +130,25 @@ being present.  You can easily use your own templating language, but an
 extension could still depend on Jinja itself.
 
 
-Micro with Dependencies
+What does "micro" mean?
 -----------------------
 
+Micro does not mean that your whole web application has to fit into a single
+Python file (although it certainly can), nor does it mean that Flask is lacking
+in functionality. The "micro" in microframework means Flask aims to keep the
+core simple but extensible. Flask won't make many decisions for you, such as
+what database to use. Those decisions that it does make, such as what
+templating engine to use, are easy to change.  Everything else is up to you, so
+that Flask can be everything you need and nothing you don't.
+
+By default, Flask does not include a database abstraction layer, form
+validation or anything else where different libraries already exist that can
+handle that. Instead, Flask supports extensions to add such functionality to
+your application as if it was implemented in Flask itself. Numerous extensions
+provide database integration, form validation, upload handling, various open
+authentication technologies, and more. Flask may be "micro", but it's ready for
+production use on a variety of needs.
+
 Why does Flask call itself a microframework and yet it depends on two
 libraries (namely Werkzeug and Jinja2).  Why shouldn't it?  If we look
 over to the Ruby side of web development there we have a protocol very
@@ -167,9 +183,6 @@ large applications harder to maintain.  However Flask is just not designed
 for large applications or asynchronous servers.  Flask wants to make it
 quick and easy to write a traditional web application.
 
-Also see the :doc:`/becomingbig` section of the documentation for some
-inspiration for larger applications based on Flask.
-
 
 Async/await and ASGI support
 ----------------------------
@@ -204,5 +217,12 @@ requirements and Flask could not meet those if it would force any of this
 into the core.  The majority of web applications will need a template
 engine in some sort.  However not every application needs a SQL database.
 
+As your codebase grows, you are free to make the design decisions appropriate
+for your project.  Flask will continue to provide a very simple glue layer to
+the best that Python has to offer.  You can implement advanced patterns in
+SQLAlchemy or another database tool, introduce non-relational data persistence
+as appropriate, and take advantage of framework-agnostic tools built for WSGI,
+the Python web interface.
+
 The idea of Flask is to build a good foundation for all applications.
 Everything else is up to you or extensions.
diff --git a/docs/extensiondev.rst b/docs/extensiondev.rst
index dbaf62cb..4ddb6da0 100644
--- a/docs/extensiondev.rst
+++ b/docs/extensiondev.rst
@@ -1,310 +1,278 @@
 Flask Extension Development
 ===========================
 
-Flask, being a microframework, often requires some repetitive steps to get
-a third party library working. Many such extensions are already available
-on `PyPI`_.
-
-If you want to create your own Flask extension for something that does not
-exist yet, this guide to extension development will help you get your
-extension running in no time and to feel like users would expect your
-extension to behave.
-
-Anatomy of an Extension
------------------------
-
-Extensions are all located in a package called ``flask_something``
-where "something" is the name of the library you want to bridge.  So for
-example if you plan to add support for a library named `simplexml` to
-Flask, you would name your extension's package ``flask_simplexml``.
-
-The name of the actual extension (the human readable name) however would
-be something like "Flask-SimpleXML".  Make sure to include the name
-"Flask" somewhere in that name and that you check the capitalization.
-This is how users can then register dependencies to your extension in
-their :file:`setup.py` files.
-
-But what do extensions look like themselves?  An extension has to ensure
-that it works with multiple Flask application instances at once.  This is
-a requirement because many people will use patterns like the
-:doc:`/patterns/appfactories` pattern to create their application as
-needed to aid unittests and to support multiple configurations. Because
-of that it is crucial that your application supports that kind of
-behavior.
-
-Most importantly the extension must be shipped with a :file:`setup.py` file and
-registered on PyPI.  Also the development checkout link should work so
-that people can easily install the development version into their
-virtualenv without having to download the library by hand.
-
-Flask extensions must be licensed under a BSD, MIT or more liberal license
-in order to be listed in the Flask Extension Registry.  Keep in mind
-that the Flask Extension Registry is a moderated place and libraries will
-be reviewed upfront if they behave as required.
-
-"Hello Flaskext!"
------------------
-
-So let's get started with creating such a Flask extension.  The extension
-we want to create here will provide very basic support for SQLite3.
-
-First we create the following folder structure::
-
-    flask-sqlite3/
-        flask_sqlite3.py
-        LICENSE
-        README
-
-Here's the contents of the most important files:
-
-setup.py
-````````
-
-The next file that is absolutely required is the :file:`setup.py` file which is
-used to install your Flask extension.  The following contents are
-something you can work with::
-
-    """
-    Flask-SQLite3
-    -------------
-
-    This is the description for that library
-    """
-    from setuptools import setup
-
-
-    setup(
-        name='Flask-SQLite3',
-        version='1.0',
-        url='http://example.com/flask-sqlite3/',
-        license='BSD',
-        author='Your Name',
-        author_email='your-email@example.com',
-        description='Very short description',
-        long_description=__doc__,
-        py_modules=['flask_sqlite3'],
-        # if you would be using a package instead use packages instead
-        # of py_modules:
-        # packages=['flask_sqlite3'],
-        zip_safe=False,
-        include_package_data=True,
-        platforms='any',
-        install_requires=[
-            'Flask'
-        ],
-        classifiers=[
-            'Environment :: Web Environment',
-            'Intended Audience :: Developers',
-            'License :: OSI Approved :: BSD License',
-            'Operating System :: OS Independent',
-            'Programming Language :: Python',
-            'Topic :: Internet :: WWW/HTTP :: Dynamic Content',
-            'Topic :: Software Development :: Libraries :: Python Modules'
-        ]
-    )
-
-That's a lot of code but you can really just copy/paste that from existing
-extensions and adapt.
-
-flask_sqlite3.py
-````````````````
-
-Now this is where your extension code goes.  But how exactly should such
-an extension look like?  What are the best practices?  Continue reading
-for some insight.
-
-Initializing Extensions
------------------------
-
-Many extensions will need some kind of initialization step.  For example,
-consider an application that's currently connecting to SQLite like the
-documentation suggests (:doc:`/patterns/sqlite3`). So how does the
-extension know the name of the application object?
-
-Quite simple: you pass it to it.
-
-There are two recommended ways for an extension to initialize:
-
-initialization functions:
-
-    If your extension is called `helloworld` you might have a function
-    called ``init_helloworld(app[, extra_args])`` that initializes the
-    extension for that application.  It could attach before / after
-    handlers etc.
+.. currentmodule:: flask
 
-classes:
+Extensions are extra packages that add functionality to a Flask
+application. While `PyPI`_ contains many Flask extensions, you may not
+find one that fits your need. If this is the case, you can create your
+own, and publish it for others to use as well.
 
-    Classes work mostly like initialization functions but can later be
-    used to further change the behavior.
+This guide will show how to create a Flask extension, and some of the
+common patterns and requirements involved. Since extensions can do
+anything, this guide won't be able to cover every possibility.
 
-What to use depends on what you have in mind.  For the SQLite 3 extension
-we will use the class-based approach because it will provide users with an
-object that handles opening and closing database connections.
+The best ways to learn about extensions are to look at how other
+extensions you use are written, and discuss with others. Discuss your
+design ideas with others on our `Discord Chat`_ or
+`GitHub Discussions`_.
 
-When designing your classes, it's important to make them easily reusable
-at the module level. This means the object itself must not under any
-circumstances store any application specific state and must be shareable
-between different applications.
+The best extensions share common patterns, so that anyone familiar with
+using one extension won't feel completely lost with another. This can
+only work if collaboration happens early.
 
-The Extension Code
-------------------
-
-Here's the contents of the `flask_sqlite3.py` for copy/paste::
-
-    import sqlite3
-    from flask import current_app, _app_ctx_stack
 
+Naming
+------
 
-    class SQLite3(object):
-        def __init__(self, app=None):
-            self.app = app
-            if app is not None:
-                self.init_app(app)
-
-        def init_app(self, app):
-            app.config.setdefault('SQLITE3_DATABASE', ':memory:')
-            app.teardown_appcontext(self.teardown)
-
-        def connect(self):
-            return sqlite3.connect(current_app.config['SQLITE3_DATABASE'])
-
-        def teardown(self, exception):
-            ctx = _app_ctx_stack.top
-            if hasattr(ctx, 'sqlite3_db'):
-                ctx.sqlite3_db.close()
-
-        @property
-        def connection(self):
-            ctx = _app_ctx_stack.top
-            if ctx is not None:
-                if not hasattr(ctx, 'sqlite3_db'):
-                    ctx.sqlite3_db = self.connect()
-                return ctx.sqlite3_db
-
-
-So here's what these lines of code do:
-
-1.  The ``__init__`` method takes an optional app object and, if supplied, will
-    call ``init_app``.
-2.  The ``init_app`` method exists so that the ``SQLite3`` object can be
-    instantiated without requiring an app object.  This method supports the
-    factory pattern for creating applications.  The ``init_app`` will set the
-    configuration for the database, defaulting to an in memory database if
-    no configuration is supplied.  In addition, the ``init_app`` method
-    attaches the ``teardown`` handler.
-3.  Next, we define a ``connect`` method that opens a database connection.
-4.  Finally, we add a ``connection`` property that on first access opens
-    the database connection and stores it on the context.  This is also
-    the recommended way to handling resources: fetch resources lazily the
-    first time they are used.
-
-    Note here that we're attaching our database connection to the top
-    application context via ``_app_ctx_stack.top``. Extensions should use
-    the top context for storing their own information with a sufficiently
-    complex name.
-
-So why did we decide on a class-based approach here?  Because using our
-extension looks something like this::
-
-    from flask import Flask
-    from flask_sqlite3 import SQLite3
-
-    app = Flask(__name__)
-    app.config.from_pyfile('the-config.cfg')
-    db = SQLite3(app)
-
-You can then use the database from views like this::
-
-    @app.route('/')
-    def show_all():
-        cur = db.connection.cursor()
-        cur.execute(...)
-
-Likewise if you are outside of a request you can use the database by
-pushing an app context::
-
-    with app.app_context():
-        cur = db.connection.cursor()
-        cur.execute(...)
-
-At the end of the ``with`` block the teardown handles will be executed
-automatically.
-
-Additionally, the ``init_app`` method is used to support the factory pattern
-for creating apps::
-
-    db = SQLite3()
-    # Then later on.
-    app = create_app('the-config.cfg')
-    db.init_app(app)
-
-Keep in mind that supporting this factory pattern for creating apps is required
-for approved flask extensions (described below).
-
-.. admonition:: Note on ``init_app``
+A Flask extension typically has ``flask`` in its name as a prefix or
+suffix. If it wraps another library, it should include the library name
+as well. This makes it easy to search for extensions, and makes their
+purpose clearer.
 
-   As you noticed, ``init_app`` does not assign ``app`` to ``self``.  This
-   is intentional!  Class based Flask extensions must only store the
-   application on the object when the application was passed to the
-   constructor.  This tells the extension: I am not interested in using
-   multiple applications.
+A general Python packaging recommendation is that the install name from
+the package index and the name used in ``import`` statements should be
+related. The import name is lowercase, with words separated by
+underscores (``_``). The install name is either lower case or title
+case, with words separated by dashes (``-``). If it wraps another
+library, prefer using the same case as that library's name.
 
-   When the extension needs to find the current application and it does
-   not have a reference to it, it must either use the
-   :data:`~flask.current_app` context local or change the API in a way
-   that you can pass the application explicitly.
+Here are some example install and import names:
 
+-   ``Flask-Name`` imported as ``flask_name``
+-   ``flask-name-lower`` imported as ``flask_name_lower``
+-   ``Flask-ComboName`` imported as ``flask_comboname``
+-   ``Name-Flask`` imported as ``name_flask``
 
-Using _app_ctx_stack
---------------------
 
-In the example above, before every request, a ``sqlite3_db`` variable is
-assigned to ``_app_ctx_stack.top``.  In a view function, this variable is
-accessible using the ``connection`` property of ``SQLite3``.  During the
-teardown of a request, the ``sqlite3_db`` connection is closed.  By using
-this pattern, the *same* connection to the sqlite3 database is accessible
-to anything that needs it for the duration of the request.
+The Extension Class and Initialization
+--------------------------------------
 
+All extensions will need some entry point that initializes the
+extension with the application. The most common pattern is to create a
+class that represents the extension's configuration and behavior, with
+an ``init_app`` method to apply the extension instance to the given
+application instance.
 
-Learn from Others
------------------
+.. code-block:: python
 
-This documentation only touches the bare minimum for extension development.
-If you want to learn more, it's a very good idea to check out existing extensions
-on the `PyPI`_.  If you feel lost there is still the `mailinglist`_ and the
-`Discord server`_ to get some ideas for nice looking APIs.  Especially if you do
-something nobody before you did, it might be a very good idea to get some more
-input.  This not only generates useful feedback on what people might want from
-an extension, but also avoids having multiple developers working in isolation
-on pretty much the same problem.
-
-Remember: good API design is hard, so introduce your project on the
-mailing list, and let other developers give you a helping hand with
-designing the API.
+    class HelloExtension:
+        def __init__(self, app=None):
+            if app is not None:
+                self.init_app(app)
 
-The best Flask extensions are extensions that share common idioms for the
-API.  And this can only work if collaboration happens early.
+        def init_app(self, app):
+            app.before_request(...)
+
+It is important that the app is not stored on the extension, don't do
+``self.app = app``. The only time the extension should have direct
+access to an app is during ``init_app``, otherwise it should use
+:data:`current_app`.
+
+This allows the extension to support the application factory pattern,
+avoids circular import issues when importing the extension instance
+elsewhere in a user's code, and makes testing with different
+configurations easier.
+
+.. code-block:: python
+
+    hello = HelloExtension()
+
+    def create_app():
+        app = Flask(__name__)
+        hello.init_app(app)
+        return app
+
+Above, the ``hello`` extension instance exists independently of the
+application. This means that other modules in a user's project can do
+``from project import hello`` and use the extension in blueprints before
+the app exists.
+
+The :attr:`Flask.extensions` dict can be used to store a reference to
+the extension on the application, or some other state specific to the
+application. Be aware that this is a single namespace, so use a name
+unique to your extension, such as the extension's name without the
+"flask" prefix.
+
+
+Adding Behavior
+---------------
+
+There are many ways that an extension can add behavior. Any setup
+methods that are available on the :class:`Flask` object can be used
+during an extension's ``init_app`` method.
+
+A common pattern is to use :meth:`~Flask.before_request` to initialize
+some data or a connection at the beginning of each request, then
+:meth:`~Flask.teardown_request` to clean it up at the end. This can be
+stored on :data:`g`, discussed more below.
+
+A more lazy approach is to provide a method that initializes and caches
+the data or connection. For example, a ``ext.get_db`` method could
+create a database connection the first time it's called, so that a view
+that doesn't use the database doesn't create a connection.
+
+Besides doing something before and after every view, your extension
+might want to add some specific views as well. In this case, you could
+define a :class:`Blueprint`, then call :meth:`~Flask.register_blueprint`
+during ``init_app`` to add the blueprint to the app.
+
+
+Configuration Techniques
+------------------------
+
+There can be multiple levels and sources of configuration for an
+extension. You should consider what parts of your extension fall into
+each one.
+
+-   Configuration per application instance, through ``app.config``
+    values. This is configuration that could reasonably change for each
+    deployment of an application. A common example is a URL to an
+    external resource, such as a database. Configuration keys should
+    start with the extension's name so that they don't interfere with
+    other extensions.
+-   Configuration per extension instance, through ``__init__``
+    arguments. This configuration usually affects how the extension
+    is used, such that it wouldn't make sense to change it per
+    deployment.
+-   Configuration per extension instance, through instance attributes
+    and decorator methods. It might be more ergonomic to assign to
+    ``ext.value``, or use a ``@ext.register`` decorator to register a
+    function, after the extension instance has been created.
+-   Global configuration through class attributes. Changing a class
+    attribute like ``Ext.connection_class`` can customize default
+    behavior without making a subclass. This could be combined
+    per-extension configuration to override defaults.
+-   Subclassing and overriding methods and attributes. Making the API of
+    the extension itself something that can be overridden provides a
+    very powerful tool for advanced customization.
+
+The :class:`~flask.Flask` object itself uses all of these techniques.
+
+It's up to you to decide what configuration is appropriate for your
+extension, based on what you need and what you want to support.
+
+Configuration should not be changed after the application setup phase is
+complete and the server begins handling requests. Configuration is
+global, any changes to it are not guaranteed to be visible to other
+workers.
+
+
+Data During a Request
+---------------------
+
+When writing a Flask application, the :data:`~flask.g` object is used to
+store information during a request. For example the
+:doc:`tutorial <tutorial/database>` stores a connection to a SQLite
+database as ``g.db``. Extensions can also use this, with some care.
+Since ``g`` is a single global namespace, extensions must use unique
+names that won't collide with user data. For example, use the extension
+name as a prefix, or as a namespace.
+
+.. code-block:: python
+
+    # an internal prefix with the extension name
+    g._hello_user_id = 2
+
+    # or an internal prefix as a namespace
+    from types import SimpleNamespace
+    g._hello = SimpleNamespace()
+    g._hello.user_id = 2
+
+The data in ``g`` lasts for an application context. An application
+context is active when a request context is, or when a CLI command is
+run. If you're storing something that should be closed, use
+:meth:`~flask.Flask.teardown_appcontext` to ensure that it gets closed
+when the application context ends. If it should only be valid during a
+request, or would not be used in the CLI outside a request, use
+:meth:`~flask.Flask.teardown_request`.
+
+
+Views and Models
+----------------
+
+Your extension views might want to interact with specific models in your
+database, or some other extension or data connected to your application.
+For example, let's consider a ``Flask-SimpleBlog`` extension that works
+with Flask-SQLAlchemy to provide a ``Post`` model and views to write
+and read posts.
+
+The ``Post`` model needs to subclass the Flask-SQLAlchemy ``db.Model``
+object, but that's only available once you've created an instance of
+that extension, not when your extension is defining its views. So how
+can the view code, defined before the model exists, access the model?
+
+One method could be to use :doc:`views`. During ``__init__``, create
+the model, then create the views by passing the model to the view
+class's :meth:`~views.View.as_view` method.
+
+.. code-block:: python
+
+    class PostAPI(MethodView):
+        def __init__(self, model):
+            self.model = model
+
+        def get(self, id):
+            post = self.model.query.get(id)
+            return jsonify(post.to_json())
+
+    class BlogExtension:
+        def __init__(self, db):
+            class Post(db.Model):
+                id = db.Column(primary_key=True)
+                title = db.Column(db.String, nullable=False)
+
+            self.post_model = Post
 
-Approved Extensions
--------------------
+        def init_app(self, app):
+            api_view = PostAPI.as_view(model=self.post_model)
 
-Flask previously had the concept of approved extensions. These came with
-some vetting of support and compatibility. While this list became too
-difficult to maintain over time, the guidelines are still relevant to
-all extensions maintained and developed today, as they help the Flask
+    db = SQLAlchemy()
+    blog = BlogExtension(db)
+    db.init_app(app)
+    blog.init_app(app)
+
+Another technique could be to use an attribute on the extension, such as
+``self.post_model`` from above. Add the extension to ``app.extensions``
+in ``init_app``, then access
+``current_app.extensions["simple_blog"].post_model`` from views.
+
+You may also want to provide base classes so that users can provide
+their own ``Post`` model that conforms to the API your extension
+expects. So they could implement ``class Post(blog.BasePost)``, then
+set it as ``blog.post_model``.
+
+As you can see, this can get a bit complex. Unfortunately, there's no
+perfect solution here, only different strategies and tradeoffs depending
+on your needs and how much customization you want to offer. Luckily,
+this sort of resource dependency is not a common need for most
+extensions. Remember, if you need help with design, ask on our
+`Discord Chat`_ or `GitHub Discussions`_.
+
+
+Recommended Extension Guidelines
+--------------------------------
+
+Flask previously had the concept of "approved extensions", where the
+Flask maintainers evaluated the quality, support, and compatibility of
+the extensions before listing them. While the list became too difficult
+to maintain over time, the guidelines are still relevant to all
+extensions maintained and developed today, as they help the Flask
 ecosystem remain consistent and compatible.
 
-0.  An approved Flask extension requires a maintainer. In the event an
-    extension author would like to move beyond the project, the project
-    should find a new maintainer and transfer access to the repository,
-    documentation, PyPI, and any other services. If no maintainer
-    is available, give access to the Pallets core team.
-1.  The naming scheme is *Flask-ExtensionName* or *ExtensionName-Flask*.
+1.  An extension requires a maintainer. In the event an extension author
+    would like to move beyond the project, the project should find a new
+    maintainer and transfer access to the repository, documentation,
+    PyPI, and any other services. The `Pallets-Eco`_ organization on
+    GitHub allows for community maintenance with oversight from the
+    Pallets maintainers.
+2.  The naming scheme is *Flask-ExtensionName* or *ExtensionName-Flask*.
     It must provide exactly one package or module named
     ``flask_extension_name``.
-2.  The extension must be BSD or MIT licensed. It must be open source
-    and publicly available.
-3.  The extension's API must have the following characteristics:
+3.  The extension must use an open source license. The Python web
+    ecosystem tends to prefer BSD or MIT. It must be open source and
+    publicly available.
+4.  The extension's API must have the following characteristics:
 
     -   It must support multiple applications running in the same Python
         process. Use ``current_app`` instead of ``self.app``, store
@@ -312,21 +280,25 @@ ecosystem remain consistent and compatible.
     -   It must be possible to use the factory pattern for creating
         applications. Use the ``ext.init_app()`` pattern.
 
-4.  From a clone of the repository, an extension with its dependencies
-    must be installable with ``pip install -e .``.
-5.  It must ship a testing suite that can be invoked with ``tox -e py``
-    or ``pytest``. If not using ``tox``, the test dependencies should be
-    specified in a ``requirements.txt`` file. The tests must be part of
-    the sdist distribution.
-6.  The documentation must use the ``flask`` theme from the
-    `Official Pallets Themes`_. A link to the documentation or project
-    website must be in the PyPI metadata or the readme.
-7.  For maximum compatibility, the extension should support the same
-    versions of Python that Flask supports. 3.7+ is recommended as of
-    December 2021. Use ``python_requires=">= 3.7"`` in ``setup.py`` to
-    indicate supported versions.
+5.  From a clone of the repository, an extension with its dependencies
+    must be installable in editable mode with ``pip install -e .``.
+6.  It must ship tests that can be invoked with a common tool like
+    ``tox -e py``, ``nox -s test`` or ``pytest``. If not using ``tox``,
+    the test dependencies should be specified in a requirements file.
+    The tests must be part of the sdist distribution.
+7.  A link to the documentation or project website must be in the PyPI
+    metadata or the readme. The documentation should use the Flask theme
+    from the `Official Pallets Themes`_.
+8.  The extension's dependencies should not use upper bounds or assume
+    any particular version scheme, but should use lower bounds to
+    indicate minimum compatibility support. For example,
+    ``sqlalchemy>=1.4``.
+9.  Indicate the versions of Python supported using
+    ``python_requires=">=version"``. Flask itself supports Python >=3.7
+    as of December 2021, but this will update over time.
 
 .. _PyPI: https://pypi.org/search/?c=Framework+%3A%3A+Flask
-.. _mailinglist: https://mail.python.org/mailman/listinfo/flask
-.. _Discord server: https://discord.gg/pallets
+.. _Discord Chat: https://discord.gg/pallets
+.. _GitHub Discussions: https://github.com/pallets/flask/discussions
 .. _Official Pallets Themes: https://pypi.org/project/Pallets-Sphinx-Themes/
+.. _Pallets-Eco: https://github.com/pallets-eco
diff --git a/docs/extensions.rst b/docs/extensions.rst
index 784fd807..4713ec8e 100644
--- a/docs/extensions.rst
+++ b/docs/extensions.rst
@@ -39,10 +39,10 @@ an extension called "Flask-Foo" might be used like this::
 Building Extensions
 -------------------
 
-While the `PyPI <pypi_>`_ contains many Flask extensions, you may
-not find an extension that fits your need. If this is the case, you can
-create your own. Read :doc:`/extensiondev` to develop your own Flask
-extension.
+While `PyPI <pypi_>`_ contains many Flask extensions, you may not find
+an extension that fits your need. If this is the case, you can create
+your own, and publish it for others to use as well. Read
+:doc:`extensiondev` to develop your own Flask extension.
 
 
 .. _pypi: https://pypi.org/search/?c=Framework+%3A%3A+Flask
diff --git a/docs/foreword.rst b/docs/foreword.rst
deleted file mode 100644
index 6a6d17f9..00000000
--- a/docs/foreword.rst
+++ /dev/null
@@ -1,53 +0,0 @@
-Foreword
-========
-
-Read this before you get started with Flask.  This hopefully answers some
-questions about the purpose and goals of the project, and when you
-should or should not be using it.
-
-What does "micro" mean?
------------------------
-
-Micro does not mean that your whole web application has to fit into a single
-Python file (although it certainly can), nor does it mean that Flask is lacking
-in functionality. The "micro" in microframework means Flask aims to keep the
-core simple but extensible. Flask won't make many decisions for you, such as
-what database to use. Those decisions that it does make, such as what
-templating engine to use, are easy to change.  Everything else is up to you, so
-that Flask can be everything you need and nothing you don't.
-
-By default, Flask does not include a database abstraction layer, form
-validation or anything else where different libraries already exist that can
-handle that. Instead, Flask supports extensions to add such functionality to
-your application as if it was implemented in Flask itself. Numerous extensions
-provide database integration, form validation, upload handling, various open
-authentication technologies, and more. Flask may be "micro", but it's ready for
-production use on a variety of needs.
-
-Configuration and Conventions
------------------------------
-
-Flask has many configuration values, with sensible defaults, and a few
-conventions when getting started.  By convention, templates and static
-files are stored in subdirectories within the application's Python
-source tree, with the names :file:`templates` and :file:`static`
-respectively. While this can be changed, you usually don't have to,
-especially when getting started.
-
-Growing with Flask
-------------------
-
-Once you have Flask up and running, you'll find a variety of extensions
-available in the community to integrate your project for production.
-
-As your codebase grows, you are free to make the design decisions appropriate
-for your project.  Flask will continue to provide a very simple glue layer to
-the best that Python has to offer.  You can implement advanced patterns in
-SQLAlchemy or another database tool, introduce non-relational data persistence
-as appropriate, and take advantage of framework-agnostic tools built for WSGI,
-the Python web interface.
-
-Flask includes many hooks to customize its behavior. Should you need more
-customization, the Flask class is built for subclassing. If you are interested
-in that, check out the :doc:`becomingbig` chapter.  If you are curious about
-the Flask design principles, head over to the section about :doc:`design`.
diff --git a/docs/htmlfaq.rst b/docs/htmlfaq.rst
deleted file mode 100644
index 4807c266..00000000
--- a/docs/htmlfaq.rst
+++ /dev/null
@@ -1,206 +0,0 @@
-HTML/XHTML FAQ
-==============
-
-The Flask documentation and example applications are using HTML5.  You
-may notice that in many situations, when end tags are optional they are
-not used, so that the HTML is cleaner and faster to load.  Because there
-is much confusion about HTML and XHTML among developers, this document tries
-to answer some of the major questions.
-
-
-History of XHTML
-----------------
-
-For a while, it appeared that HTML was about to be replaced by XHTML.
-However, barely any websites on the Internet are actual XHTML (which is
-HTML processed using XML rules).  There are a couple of major reasons
-why this is the case.  One of them is Internet Explorer's lack of proper
-XHTML support. The XHTML spec states that XHTML must be served with the MIME
-type :mimetype:`application/xhtml+xml`, but Internet Explorer refuses
-to read files with that MIME type.
-While it is relatively easy to configure Web servers to serve XHTML properly,
-few people do.  This is likely because properly using XHTML can be quite
-painful.
-
-One of the most important causes of pain is XML's draconian (strict and
-ruthless) error handling.  When an XML parsing error is encountered,
-the browser is supposed to show the user an ugly error message, instead
-of attempting to recover from the error and display what it can.  Most of
-the (X)HTML generation on the web is based on non-XML template engines
-(such as Jinja, the one used in Flask) which do not protect you from
-accidentally creating invalid XHTML.  There are XML based template engines,
-such as Kid and the popular Genshi, but they often come with a larger
-runtime overhead and are not as straightforward to use because they have
-to obey XML rules.
-
-The majority of users, however, assumed they were properly using XHTML.
-They wrote an XHTML doctype at the top of the document and self-closed all
-the necessary tags (``<br>`` becomes ``<br/>`` or ``<br></br>`` in XHTML).
-However, even if the document properly validates as XHTML, what really
-determines XHTML/HTML processing in browsers is the MIME type, which as
-said before is often not set properly. So the valid XHTML was being treated
-as invalid HTML.
-
-XHTML also changed the way JavaScript is used. To properly work with XHTML,
-programmers have to use the namespaced DOM interface with the XHTML
-namespace to query for HTML elements.
-
-History of HTML5
-----------------
-
-Development of the HTML5 specification was started in 2004 under the name
-"Web Applications 1.0" by the Web Hypertext Application Technology Working
-Group, or WHATWG (which was formed by the major browser vendors Apple,
-Mozilla, and Opera) with the goal of writing a new and improved HTML
-specification, based on existing browser behavior instead of unrealistic
-and backwards-incompatible specifications.
-
-For example, in HTML4 ``<title/Hello/`` theoretically parses exactly the
-same as ``<title>Hello</title>``.  However, since people were using
-XHTML-like tags along the lines of ``<link />``, browser vendors implemented
-the XHTML syntax over the syntax defined by the specification.
-
-In 2007, the specification was adopted as the basis of a new HTML
-specification under the umbrella of the W3C, known as HTML5.  Currently,
-it appears that XHTML is losing traction, as the XHTML 2 working group has
-been disbanded and HTML5 is being implemented by all major browser vendors.
-
-HTML versus XHTML
------------------
-
-The following table gives you a quick overview of features available in
-HTML 4.01, XHTML 1.1 and HTML5. (XHTML 1.0 is not included, as it was
-superseded by XHTML 1.1 and the barely-used XHTML5.)
-
-.. tabularcolumns:: |p{9cm}|p{2cm}|p{2cm}|p{2cm}|
-
-+-----------------------------------------+----------+----------+----------+
-|                                         | HTML4.01 | XHTML1.1 | HTML5    |
-+=========================================+==========+==========+==========+
-| ``<tag/value/`` == ``<tag>value</tag>`` | |Y| [1]_ | |N|      | |N|      |
-+-----------------------------------------+----------+----------+----------+
-| ``<br/>`` supported                     | |N|      | |Y|      | |Y| [2]_ |
-+-----------------------------------------+----------+----------+----------+
-| ``<script/>`` supported                 | |N|      | |Y|      | |N|      |
-+-----------------------------------------+----------+----------+----------+
-| should be served as `text/html`         | |Y|      | |N| [3]_ | |Y|      |
-+-----------------------------------------+----------+----------+----------+
-| should be served as                     | |N|      | |Y|      | |N|      |
-| `application/xhtml+xml`                 |          |          |          |
-+-----------------------------------------+----------+----------+----------+
-| strict error handling                   | |N|      | |Y|      | |N|      |
-+-----------------------------------------+----------+----------+----------+
-| inline SVG                              | |N|      | |Y|      | |Y|      |
-+-----------------------------------------+----------+----------+----------+
-| inline MathML                           | |N|      | |Y|      | |Y|      |
-+-----------------------------------------+----------+----------+----------+
-| ``<video>`` tag                         | |N|      | |N|      | |Y|      |
-+-----------------------------------------+----------+----------+----------+
-| ``<audio>`` tag                         | |N|      | |N|      | |Y|      |
-+-----------------------------------------+----------+----------+----------+
-| New semantic tags like ``<article>``    | |N|      | |N|      | |Y|      |
-+-----------------------------------------+----------+----------+----------+
-
-.. [1] This is an obscure feature inherited from SGML. It is usually not
-       supported by browsers, for reasons detailed above.
-.. [2] This is for compatibility with server code that generates XHTML for
-       tags such as ``<br>``.  It should not be used in new code.
-.. [3] XHTML 1.0 is the last XHTML standard that allows to be served
-       as `text/html` for backwards compatibility reasons.
-
-.. |Y| image:: _static/yes.png
-       :alt: Yes
-.. |N| image:: _static/no.png
-       :alt: No
-
-What does "strict" mean?
-------------------------
-
-HTML5 has strictly defined parsing rules, but it also specifies exactly
-how a browser should react to parsing errors - unlike XHTML, which simply
-states parsing should abort. Some people are confused by apparently
-invalid syntax that still generates the expected results (for example,
-missing end tags or unquoted attribute values).
-
-Some of these work because of the lenient error handling most browsers use
-when they encounter a markup error, others are actually specified.  The
-following constructs are optional in HTML5 by standard, but have to be
-supported by browsers:
-
--   Wrapping the document in an ``<html>`` tag
--   Wrapping header elements in ``<head>`` or the body elements in
-    ``<body>``
--   Closing the ``<p>``, ``<li>``, ``<dt>``, ``<dd>``, ``<tr>``,
-    ``<td>``, ``<th>``, ``<tbody>``, ``<thead>``, or ``<tfoot>`` tags.
--   Quoting attributes, so long as they contain no whitespace or
-    special characters (like ``<``, ``>``, ``'``, or ``"``).
--   Requiring boolean attributes to have a value.
-
-This means the following page in HTML5 is perfectly valid:
-
-.. sourcecode:: html
-
-    <!doctype html>
-    <title>Hello HTML5</title>
-    <div class=header>
-      <h1>Hello HTML5</h1>
-      <p class=tagline>HTML5 is awesome
-    </div>
-    <ul class=nav>
-      <li><a href=/index>Index</a>
-      <li><a href=/downloads>Downloads</a>
-      <li><a href=/about>About</a>
-    </ul>
-    <div class=body>
-      <h2>HTML5 is probably the future</h2>
-      <p>
-        There might be some other things around but in terms of
-        browser vendor support, HTML5 is hard to beat.
-      <dl>
-        <dt>Key 1
-        <dd>Value 1
-        <dt>Key 2
-        <dd>Value 2
-      </dl>
-    </div>
-
-
-New technologies in HTML5
--------------------------
-
-HTML5 adds many new features that make Web applications easier to write
-and to use.
-
--   The ``<audio>`` and ``<video>`` tags provide a way to embed audio and
-    video without complicated add-ons like QuickTime or Flash.
--   Semantic elements like ``<article>``, ``<header>``, ``<nav>``, and
-    ``<time>`` that make content easier to understand.
--   The ``<canvas>`` tag, which supports a powerful drawing API, reducing
-    the need for server-generated images to present data graphically.
--   New form control types like ``<input type="date">`` that allow user
-    agents to make entering and validating values easier.
--   Advanced JavaScript APIs like Web Storage, Web Workers, Web Sockets,
-    geolocation, and offline applications.
-
-Many other features have been added, as well. A good guide to new features
-in HTML5 is Mark Pilgrim's book, `Dive Into HTML5`_.
-Not all of them are supported in browsers yet, however, so use caution.
-
-.. _Dive Into HTML5: https://diveintohtml5.info/
-
-What should be used?
---------------------
-
-Currently, the answer is HTML5.  There are very few reasons to use XHTML
-considering the latest developments in Web browsers.  To summarize the
-reasons given above:
-
--   Internet Explorer has poor support for XHTML.
--   Many JavaScript libraries also do not support XHTML, due to the more
-    complicated namespacing API it requires.
--   HTML5 adds several new features, including semantic tags and the
-    long-awaited ``<audio>`` and ``<video>`` tags.
--   It has the support of most browser vendors behind it.
--   It is much easier to write, and more compact.
-
-For most applications, it is undoubtedly better to use HTML5 than XHTML.
diff --git a/docs/index.rst b/docs/index.rst
index 6ff62529..747749d0 100644
--- a/docs/index.rst
+++ b/docs/index.rst
@@ -29,15 +29,14 @@ toolkit. The documentation for these libraries can be found at:
 User's Guide
 ------------
 
-This part of the documentation, which is mostly prose, begins with some
-background information about Flask, then focuses on step-by-step
-instructions for web development with Flask.
+Flask provides configuration and conventions, with sensible defaults, to get started.
+This section of the documentation explains the different parts of the Flask framework
+and how they can be used, customized, and extended. Beyond Flask itself, look for
+community-maintained extensions to add even more functionality.
 
 .. toctree::
    :maxdepth: 2
 
-   foreword
-   advanced_foreword
    installation
    quickstart
    tutorial/index
@@ -49,6 +48,7 @@ instructions for web development with Flask.
    config
    signals
    views
+   lifecycle
    appcontext
    reqcontext
    blueprints
@@ -57,8 +57,8 @@ instructions for web development with Flask.
    server
    shell
    patterns/index
+   security
    deploying/index
-   becomingbig
    async-await
 
 
@@ -77,14 +77,10 @@ method, this part of the documentation is for you.
 Additional Notes
 ----------------
 
-Design notes, legal information and changelog are here for the interested.
-
 .. toctree::
    :maxdepth: 2
 
    design
-   htmlfaq
-   security
    extensiondev
    contributing
    license
diff --git a/docs/lifecycle.rst b/docs/lifecycle.rst
new file mode 100644
index 00000000..2344d98a
--- /dev/null
+++ b/docs/lifecycle.rst
@@ -0,0 +1,168 @@
+Application Structure and Lifecycle
+===================================
+
+Flask makes it pretty easy to write a web application. But there are quite a few
+different parts to an application and to each request it handles. Knowing what happens
+during application setup, serving, and handling requests will help you know what's
+possible in Flask and how to structure your application.
+
+
+Application Setup
+-----------------
+
+The first step in creating a Flask application is creating the application object. Each
+Flask application is an instance of the :class:`.Flask` class, which collects all
+configuration, extensions, and views.
+
+.. code-block:: python
+
+    from flask import Flask
+
+    app = Flask(__name__)
+    app.config.from_mapping(
+        SECRET_KEY="dev",
+    )
+    app.config.from_prefixed_env()
+
+    @app.route("/")
+    def index():
+        return "Hello, World!"
+
+This is known as the "application setup phase", it's the code you write that's outside
+any view functions or other handlers. It can be split up between different modules and
+sub-packages, but all code that you want to be part of your application must be imported
+in order for it to be registered.
+
+All application setup must be completed before you start serving your application and
+handling requests. This is because WSGI servers divide work between multiple workers, or
+can be distributed across multiple machines. If the configuration changed in one worker,
+there's no way for Flask to ensure consistency between other workers.
+
+Flask tries to help developers catch some of these setup ordering issues by showing an
+error if setup-related methods are called after requests are handled. In that case
+you'll see this error:
+
+    The setup method 'route' can no longer be called on the application. It has already
+    handled its first request, any changes will not be applied consistently.
+    Make sure all imports, decorators, functions, etc. needed to set up the application
+    are done before running it.
+
+However, it is not possible for Flask to detect all cases of out-of-order setup. In
+general, don't do anything to modify the ``Flask`` app object and ``Blueprint`` objects
+from within view functions that run during requests. This includes:
+
+-   Adding routes, view functions, and other request handlers with ``@app.route``,
+    ``@app.errorhandler``, ``@app.before_request``, etc.
+-   Registering blueprints.
+-   Loading configuration with ``app.config``.
+-   Setting up the Jinja template environment with ``app.jinja_env``.
+-   Setting a session interface, instead of the default itsdangerous cookie.
+-   Setting a JSON provider with ``app.json``, instead of the default provider.
+-   Creating and initializing Flask extensions.
+
+
+Serving the Application
+-----------------------
+
+Flask is a WSGI application framework. The other half of WSGI is the WSGI server. During
+development, Flask, through Werkzeug, provides a development WSGI server with the
+``flask run`` CLI command. When you are done with development, use a production server
+to serve your application, see :doc:`deploying/index`.
+
+Regardless of what server you're using, it will follow the :pep:`3333` WSGI spec. The
+WSGI server will be told how to access your Flask application object, which is the WSGI
+application. Then it will start listening for HTTP requests, translate the request data
+into a WSGI environ, and call the WSGI application with that data. The WSGI application
+will return data that is translated into an HTTP response.
+
+#.  Browser or other client makes HTTP request.
+#.  WSGI server receives request.
+#.  WSGI server converts HTTP data to WSGI ``environ`` dict.
+#.  WSGI server calls WSGI application with the ``environ``.
+#.  Flask, the WSGI application, does all its internal processing to route the request
+    to a view function, handle errors, etc.
+#.  Flask translates View function return into WSGI response data, passes it to WSGI
+    server.
+#.  WSGI server creates and send an HTTP response.
+#.  Client receives the HTTP response.
+
+
+Middleware
+~~~~~~~~~~
+
+The WSGI application above is a callable that behaves in a certain way. Middleware
+is a WSGI application that wraps another WSGI application. It's a similar concept to
+Python decorators. The outermost middleware will be called by the server. It can modify
+the data passed to it, then call the WSGI application (or further middleware) that it
+wraps, and so on. And it can take the return value of that call and modify it further.
+
+From the WSGI server's perspective, there is one WSGI application, the one it calls
+directly. Typically, Flask is the "real" application at the end of the chain of
+middleware. But even Flask can call further WSGI applications, although that's an
+advanced, uncommon use case.
+
+A common middleware you'll see used with Flask is Werkzeug's
+:class:`~werkzeug.middleware.proxy_fix.ProxyFix`, which modifies the request to look
+like it came directly from a client even if it passed through HTTP proxies on the way.
+There are other middleware that can handle serving static files, authentication, etc.
+
+
+How a Request is Handled
+------------------------
+
+For us, the interesting part of the steps above is when Flask gets called by the WSGI
+server (or middleware). At that point, it will do quite a lot to handle the request and
+generate the response. At the most basic, it will match the URL to a view function, call
+the view function, and pass the return value back to the server. But there are many more
+parts that you can use to customize its behavior.
+
+#.  WSGI server calls the Flask object, which calls :meth:`.Flask.wsgi_app`.
+#.  A :class:`.RequestContext` object is created. This converts the WSGI ``environ``
+    dict into a :class:`.Request` object. It also creates an :class:`AppContext` object.
+#.  The :doc:`app context <appcontext>` is pushed, which makes :data:`.current_app` and
+    :data:`.g` available.
+#.  The :data:`.appcontext_pushed` signal is sent.
+#.  The :doc:`request context <reqcontext>` is pushed, which makes :attr:`.request` and
+    :class:`.session` available.
+#.  The session is opened, loading any existing session data using the app's
+    :attr:`~.Flask.session_interface`, an instance of :class:`.SessionInterface`.
+#.  The URL is matched against the URL rules registered with the :meth:`~.Flask.route`
+    decorator during application setup. If there is no match, the error - usually a 404,
+    405, or redirect - is stored to be handled later.
+#.  The :data:`.request_started` signal is sent.
+#.  Any :meth:`~.Flask.url_value_preprocessor` decorated functions are called.
+#.  Any :meth:`~.Flask.before_request` decorated functions are called. If any of
+    these function returns a value it is treated as the response immediately.
+#.  If the URL didn't match a route a few steps ago, that error is raised now.
+#.  The :meth:`~.Flask.route` decorated view function associated with the matched URL
+    is called and returns a value to be used as the response.
+#.  If any step so far raised an exception, and there is an :meth:`~.Flask.errorhandler`
+    decorated function that matches the exception class or HTTP error code, it is
+    called to handle the error and return a response.
+#.  Whatever returned a response value - a before request function, the view, or an
+    error handler, that value is converted to a :class:`.Response` object.
+#.  Any :func:`~.after_this_request` decorated functions are called, then cleared.
+#.  Any :meth:`~.Flask.after_request` decorated functions are called, which can modify
+    the response object.
+#.  The session is saved, persisting any modified session data using the app's
+    :attr:`~.Flask.session_interface`.
+#.  The :data:`.request_finished` signal is sent.
+#.  If any step so far raised an exception, and it was not handled by an error handler
+    function, it is handled now. HTTP exceptions are treated as responses with their
+    corresponding status code, other exceptions are converted to a generic 500 response.
+    The :data:`.got_request_exception` signal is sent.
+#.  The response object's status, headers, and body are returned to the WSGI server.
+#.  Any :meth:`~.Flask.teardown_request` decorated functions are called.
+#.  The :data:`.request_tearing_down` signal is sent.
+#.  The request context is popped, :attr:`.request` and :class:`.session` are no longer
+    available.
+#.  Any :meth:`~.Flask.teardown_appcontext` decorated functions are called.
+#.  The :data:`.appcontext_tearing_down` signal is sent.
+#.  The app context is popped, :data:`.current_app` and :data:`.g` are no longer
+    available.
+#.  The :data:`.appcontext_popped` signal is sent.
+
+There are even more decorators and customization points than this, but that aren't part
+of every request lifecycle. They're more specific to certain things you might use during
+a request, such as templates, building URLs, or handling JSON data. See the rest of this
+documentation, as well as the :doc:`api` to explore further.
diff --git a/docs/patterns/appdispatch.rst b/docs/patterns/appdispatch.rst
index 0c5e846e..efa470a7 100644
--- a/docs/patterns/appdispatch.rst
+++ b/docs/patterns/appdispatch.rst
@@ -93,7 +93,7 @@ exist yet, it is dynamically created and remembered::
 
     from threading import Lock
 
-    class SubdomainDispatcher(object):
+    class SubdomainDispatcher:
 
         def __init__(self, domain, create_app):
             self.domain = domain
@@ -148,7 +148,7 @@ request path up to the first slash::
     from threading import Lock
     from werkzeug.wsgi import pop_path_info, peek_path_info
 
-    class PathDispatcher(object):
+    class PathDispatcher:
 
         def __init__(self, default_app, create_app):
             self.default_app = default_app
diff --git a/docs/patterns/appfactories.rst b/docs/patterns/appfactories.rst
index a0e88ab3..a76e676f 100644
--- a/docs/patterns/appfactories.rst
+++ b/docs/patterns/appfactories.rst
@@ -89,71 +89,20 @@ Using Applications
 
 To run such an application, you can use the :command:`flask` command:
 
-.. tabs::
+.. code-block:: text
 
-   .. group-tab:: Bash
+    $ flask --app hello run
 
-      .. code-block:: text
+Flask will automatically detect the factory if it is named
+``create_app`` or ``make_app`` in ``hello``. You can also pass arguments
+to the factory like this:
 
-         $ export FLASK_APP=myapp
-         $ flask run
+.. code-block:: text
 
-   .. group-tab:: Fish
+    $ flask --app hello:create_app(local_auth=True) run``
 
-      .. code-block:: text
-
-         $ set -x FLASK_APP myapp
-         $ flask run
-
-   .. group-tab:: CMD
-
-      .. code-block:: text
-
-         > set FLASK_APP=myapp
-         > flask run
-
-   .. group-tab:: Powershell
-
-      .. code-block:: text
-
-         > $env:FLASK_APP = "myapp"
-         > flask run
-
-Flask will automatically detect the factory (``create_app`` or ``make_app``)
-in ``myapp``. You can also pass arguments to the factory like this:
-
-.. tabs::
-
-   .. group-tab:: Bash
-
-      .. code-block:: text
-
-         $ export FLASK_APP="myapp:create_app('dev')"
-         $ flask run
-
-   .. group-tab:: Fish
-
-      .. code-block:: text
-
-         $ set -x FLASK_APP "myapp:create_app('dev')"
-         $ flask run
-
-   .. group-tab:: CMD
-
-      .. code-block:: text
-
-         > set FLASK_APP="myapp:create_app('dev')"
-         > flask run
-
-   .. group-tab:: Powershell
-
-      .. code-block:: text
-
-         > $env:FLASK_APP = "myapp:create_app('dev')"
-         > flask run
-
-Then the ``create_app`` factory in ``myapp`` is called with the string
-``'dev'`` as the argument. See :doc:`/cli` for more detail.
+Then the ``create_app`` factory in ``myapp`` is called with the keyword
+argument ``local_auth=True``. See :doc:`/cli` for more detail.
 
 Factory Improvements
 --------------------
diff --git a/docs/patterns/celery.rst b/docs/patterns/celery.rst
index 38a9a025..2e9a43a7 100644
--- a/docs/patterns/celery.rst
+++ b/docs/patterns/celery.rst
@@ -1,101 +1,242 @@
-Celery Background Tasks
-=======================
+Background Tasks with Celery
+============================
 
-If your application has a long running task, such as processing some uploaded
-data or sending email, you don't want to wait for it to finish during a
-request. Instead, use a task queue to send the necessary data to another
-process that will run the task in the background while the request returns
-immediately.
+If your application has a long running task, such as processing some uploaded data or
+sending email, you don't want to wait for it to finish during a request. Instead, use a
+task queue to send the necessary data to another process that will run the task in the
+background while the request returns immediately.
+
+`Celery`_ is a powerful task queue that can be used for simple background tasks as well
+as complex multi-stage programs and schedules. This guide will show you how to configure
+Celery using Flask. Read Celery's `First Steps with Celery`_ guide to learn how to use
+Celery itself.
+
+.. _Celery: https://celery.readthedocs.io
+.. _First Steps with Celery: https://celery.readthedocs.io/en/latest/getting-started/first-steps-with-celery.html
+
+The Flask repository contains `an example <https://github.com/pallets/flask/tree/main/examples/celery>`_
+based on the information on this page, which also shows how to use JavaScript to submit
+tasks and poll for progress and results.
 
-Celery is a powerful task queue that can be used for simple background tasks
-as well as complex multi-stage programs and schedules. This guide will show you
-how to configure Celery using Flask, but assumes you've already read the
-`First Steps with Celery <https://celery.readthedocs.io/en/latest/getting-started/first-steps-with-celery.html>`_
-guide in the Celery documentation.
 
 Install
 -------
 
-Celery is a separate Python package. Install it from PyPI using pip::
+Install Celery from PyPI, for example using pip:
+
+.. code-block:: text
 
     $ pip install celery
 
-Configure
----------
 
-The first thing you need is a Celery instance, this is called the celery
-application.  It serves the same purpose as the :class:`~flask.Flask`
-object in Flask, just for Celery.  Since this instance is used as the
-entry-point for everything you want to do in Celery, like creating tasks
-and managing workers, it must be possible for other modules to import it.
+Integrate Celery with Flask
+---------------------------
 
-For instance you can place this in a ``tasks`` module.  While you can use
-Celery without any reconfiguration with Flask, it becomes a bit nicer by
-subclassing tasks and adding support for Flask's application contexts and
-hooking it up with the Flask configuration.
+You can use Celery without any integration with Flask, but it's convenient to configure
+it through Flask's config, and to let tasks access the Flask application.
 
-This is all that is necessary to properly integrate Celery with Flask::
+Celery uses similar ideas to Flask, with a ``Celery`` app object that has configuration
+and registers tasks. While creating a Flask app, use the following code to create and
+configure a Celery app as well.
 
-    from celery import Celery
+.. code-block:: python
 
-    def make_celery(app):
-        celery = Celery(
-            app.import_name,
-            backend=app.config['CELERY_RESULT_BACKEND'],
-            broker=app.config['CELERY_BROKER_URL']
-        )
-        celery.conf.update(app.config)
+    from celery import Celery, Task
 
-        class ContextTask(celery.Task):
-            def __call__(self, *args, **kwargs):
+    def celery_init_app(app: Flask) -> Celery:
+        class FlaskTask(Task):
+            def __call__(self, *args: object, **kwargs: object) -> object:
                 with app.app_context():
                     return self.run(*args, **kwargs)
 
-        celery.Task = ContextTask
-        return celery
+        celery_app = Celery(app.name, task_cls=FlaskTask)
+        celery_app.config_from_object(app.config["CELERY"])
+        celery_app.set_default()
+        app.extensions["celery"] = celery_app
+        return celery_app
 
-The function creates a new Celery object, configures it with the broker
-from the application config, updates the rest of the Celery config from
-the Flask config and then creates a subclass of the task that wraps the
-task execution in an application context.
+This creates and returns a ``Celery`` app object. Celery `configuration`_ is taken from
+the ``CELERY`` key in the Flask configuration. The Celery app is set as the default, so
+that it is seen during each request. The ``Task`` subclass automatically runs task
+functions with a Flask app context active, so that services like your database
+connections are available.
 
-An example task
----------------
+.. _configuration: https://celery.readthedocs.io/en/stable/userguide/configuration.html
+
+Here's a basic ``example.py`` that configures Celery to use Redis for communication. We
+enable a result backend, but ignore results by default. This allows us to store results
+only for tasks where we care about the result.
 
-Let's write a task that adds two numbers together and returns the result. We
-configure Celery's broker and backend to use Redis, create a ``celery``
-application using the factory from above, and then use it to define the task. ::
+.. code-block:: python
 
     from flask import Flask
 
-    flask_app = Flask(__name__)
-    flask_app.config.update(
-        CELERY_BROKER_URL='redis://localhost:6379',
-        CELERY_RESULT_BACKEND='redis://localhost:6379'
+    app = Flask(__name__)
+    app.config.from_mapping(
+        CELERY=dict(
+            broker_url="redis://localhost",
+            result_backend="redis://localhost",
+            task_ignore_result=True,
+        ),
     )
-    celery = make_celery(flask_app)
+    celery_app = celery_init_app(app)
+
+Point the ``celery worker`` command at this and it will find the ``celery_app`` object.
+
+.. code-block:: text
+
+    $ celery -A example worker --loglevel INFO
+
+You can also run the ``celery beat`` command to run tasks on a schedule. See Celery's
+docs for more information about defining schedules.
+
+.. code-block:: text
+
+    $ celery -A example beat --loglevel INFO
+
+
+Application Factory
+-------------------
+
+When using the Flask application factory pattern, call the ``celery_init_app`` function
+inside the factory. It sets ``app.extensions["celery"]`` to the Celery app object, which
+can be used to get the Celery app from the Flask app returned by the factory.
+
+.. code-block:: python
+
+    def create_app() -> Flask:
+        app = Flask(__name__)
+        app.config.from_mapping(
+            CELERY=dict(
+                broker_url="redis://localhost",
+                result_backend="redis://localhost",
+                task_ignore_result=True,
+            ),
+        )
+        app.config.from_prefixed_env()
+        celery_init_app(app)
+        return app
+
+To use ``celery`` commands, Celery needs an app object, but that's no longer directly
+available. Create a ``make_celery.py`` file that calls the Flask app factory and gets
+the Celery app from the returned Flask app.
+
+.. code-block:: python
+
+    from example import create_app
+
+    flask_app = create_app()
+    celery_app = flask_app.extensions["celery"]
+
+Point the ``celery`` command to this file.
+
+.. code-block:: text
+
+    $ celery -A make_celery worker --loglevel INFO
+    $ celery -A make_celery beat --loglevel INFO
 
-    @celery.task()
-    def add_together(a, b):
+
+Defining Tasks
+--------------
+
+Using ``@celery_app.task`` to decorate task functions requires access to the
+``celery_app`` object, which won't be available when using the factory pattern. It also
+means that the decorated tasks are tied to the specific Flask and Celery app instances,
+which could be an issue during testing if you change configuration for a test.
+
+Instead, use Celery's ``@shared_task`` decorator. This creates task objects that will
+access whatever the "current app" is, which is a similar concept to Flask's blueprints
+and app context. This is why we called ``celery_app.set_default()`` above.
+
+Here's an example task that adds two numbers together and returns the result.
+
+.. code-block:: python
+
+    from celery import shared_task
+
+    @shared_task(ignore_result=False)
+    def add_together(a: int, b: int) -> int:
         return a + b
 
-This task can now be called in the background::
+Earlier, we configured Celery to ignore task results by default. Since we want to know
+the return value of this task, we set ``ignore_result=False``. On the other hand, a task
+that didn't need a result, such as sending an email, wouldn't set this.
+
+
+Calling Tasks
+-------------
+
+The decorated function becomes a task object with methods to call it in the background.
+The simplest way is to use the ``delay(*args, **kwargs)`` method. See Celery's docs for
+more methods.
+
+A Celery worker must be running to run the task. Starting a worker is shown in the
+previous sections.
+
+.. code-block:: python
+
+    from flask import request
+
+    @app.post("/add")
+    def start_add() -> dict[str, object]:
+        a = request.form.get("a", type=int)
+        b = request.form.get("b", type=int)
+        result = add_together.delay(a, b)
+        return {"result_id": result.id}
+
+The route doesn't get the task's result immediately. That would defeat the purpose by
+blocking the response. Instead, we return the running task's result id, which we can use
+later to get the result.
+
+
+Getting Results
+---------------
+
+To fetch the result of the task we started above, we'll add another route that takes the
+result id we returned before. We return whether the task is finished (ready), whether it
+finished successfully, and what the return value (or error) was if it is finished.
+
+.. code-block:: python
+
+    from celery.result import AsyncResult
+
+    @app.get("/result/<id>")
+    def task_result(id: str) -> dict[str, object]:
+        result = AsyncResult(id)
+        return {
+            "ready": result.ready(),
+            "successful": result.successful(),
+            "value": result.result if result.ready() else None,
+        }
+
+Now you can start the task using the first route, then poll for the result using the
+second route. This keeps the Flask request workers from being blocked waiting for tasks
+to finish.
+
+The Flask repository contains `an example <https://github.com/pallets/flask/tree/main/examples/celery>`_
+using JavaScript to submit tasks and poll for progress and results.
+
 
-    result = add_together.delay(23, 42)
-    result.wait()  # 65
+Passing Data to Tasks
+---------------------
 
-Run a worker
-------------
+The "add" task above took two integers as arguments. To pass arguments to tasks, Celery
+has to serialize them to a format that it can pass to other processes. Therefore,
+passing complex objects is not recommended. For example, it would be impossible to pass
+a SQLAlchemy model object, since that object is probably not serializable and is tied to
+the session that queried it.
 
-If you jumped in and already executed the above code you will be
-disappointed to learn that ``.wait()`` will never actually return.
-That's because you also need to run a Celery worker to receive and execute the
-task. ::
+Pass the minimal amount of data necessary to fetch or recreate any complex data within
+the task. Consider a task that will run when the logged in user asks for an archive of
+their data. The Flask request knows the logged in user, and has the user object queried
+from the database. It got that by querying the database for a given id, so the task can
+do the same thing. Pass the user's id rather than the user object.
 
-    $ celery -A your_application.celery worker
+.. code-block:: python
 
-The ``your_application`` string has to point to your application's package
-or module that creates the ``celery`` object.
+    @shared_task
+    def generate_user_archive(user_id: str) -> None:
+        user = db.session.get(User, user_id)
+        ...
 
-Now that the worker is running, ``wait`` will return the result once the task
-is finished.
+    generate_user_archive.delay(current_user.id)
diff --git a/docs/patterns/distribute.rst b/docs/patterns/distribute.rst
deleted file mode 100644
index 83885df7..00000000
--- a/docs/patterns/distribute.rst
+++ /dev/null
@@ -1,170 +0,0 @@
-Deploying with Setuptools
-=========================
-
-`Setuptools`_, is an extension library that is commonly used to
-distribute Python libraries and extensions. It extends distutils, a basic
-module installation system shipped with Python to also support various more
-complex constructs that make larger applications easier to distribute:
-
-- **support for dependencies**: a library or application can declare a
-  list of other libraries it depends on which will be installed
-  automatically for you.
-- **package registry**: setuptools registers your package with your
-  Python installation.  This makes it possible to query information
-  provided by one package from another package.  The best known feature of
-  this system is the entry point support which allows one package to
-  declare an "entry point" that another package can hook into to extend the
-  other package.
-- **installation manager**: :command:`pip` can install other libraries for you.
-
-Flask itself, and all the libraries you can find on PyPI are distributed with
-either setuptools or distutils.
-
-In this case we assume your application is called
-:file:`yourapplication.py` and you are not using a module, but a
-package. If you have not yet converted your application into a package,
-head over to :doc:`packages` to see how this can be done.
-
-A working deployment with setuptools is the first step into more complex
-and more automated deployment scenarios.  If you want to fully automate
-the process, also read the :doc:`fabric` chapter.
-
-Basic Setup Script
-------------------
-
-Because you have Flask installed, you have setuptools available on your system.
-Flask already depends upon setuptools.
-
-Standard disclaimer applies: :ref:`use a virtualenv
-<install-create-env>`.
-
-Your setup code always goes into a file named :file:`setup.py` next to your
-application.  The name of the file is only convention, but because
-everybody will look for a file with that name, you better not change it.
-
-A basic :file:`setup.py` file for a Flask application looks like this::
-
-    from setuptools import setup
-
-    setup(
-        name='Your Application',
-        version='1.0',
-        long_description=__doc__,
-        packages=['yourapplication'],
-        include_package_data=True,
-        zip_safe=False,
-        install_requires=['Flask']
-    )
-
-Please keep in mind that you have to list subpackages explicitly.  If you
-want setuptools to lookup the packages for you automatically, you can use
-the ``find_packages`` function::
-
-    from setuptools import setup, find_packages
-
-    setup(
-        ...
-        packages=find_packages()
-    )
-
-Most parameters to the ``setup`` function should be self explanatory,
-``include_package_data`` and ``zip_safe`` might not be.
-``include_package_data`` tells setuptools to look for a :file:`MANIFEST.in` file
-and install all the entries that match as package data.  We will use this
-to distribute the static files and templates along with the Python module
-(see :ref:`distributing-resources`).  The ``zip_safe`` flag can be used to
-force or prevent zip Archive creation.  In general you probably don't want
-your packages to be installed as zip files because some tools do not
-support them and they make debugging a lot harder.
-
-
-Tagging Builds
---------------
-
-It is useful to distinguish between release and development builds. Add a
-:file:`setup.cfg` file to configure these options. ::
-
-    [egg_info]
-    tag_build = .dev
-    tag_date = 1
-
-    [aliases]
-    release = egg_info -Db ''
-
-Running ``python setup.py sdist`` will create a development package
-with ".dev" and the current date appended: ``flaskr-1.0.dev20160314.tar.gz``.
-Running ``python setup.py release sdist`` will create a release package
-with only the version: ``flaskr-1.0.tar.gz``.
-
-
-.. _distributing-resources:
-
-Distributing Resources
-----------------------
-
-If you try to install the package you just created, you will notice that
-folders like :file:`static` or :file:`templates` are not installed for you.  The
-reason for this is that setuptools does not know which files to add for
-you.  What you should do, is to create a :file:`MANIFEST.in` file next to your
-:file:`setup.py` file.  This file lists all the files that should be added to
-your tarball::
-
-    recursive-include yourapplication/templates *
-    recursive-include yourapplication/static *
-
-Don't forget that even if you enlist them in your :file:`MANIFEST.in` file, they
-won't be installed for you unless you set the `include_package_data`
-parameter of the ``setup`` function to ``True``!
-
-
-Declaring Dependencies
-----------------------
-
-Dependencies are declared in the ``install_requires`` parameter as a list.
-Each item in that list is the name of a package that should be pulled from
-PyPI on installation.  By default it will always use the most recent
-version, but you can also provide minimum and maximum version
-requirements.  Here some examples::
-
-    install_requires=[
-        'Flask>=0.2',
-        'SQLAlchemy>=0.6',
-        'BrokenPackage>=0.7,<=1.0'
-    ]
-
-As mentioned earlier, dependencies are pulled from PyPI.  What if you
-want to depend on a package that cannot be found on PyPI and won't be
-because it is an internal package you don't want to share with anyone?
-Just do it as if there was a PyPI entry and provide a list of
-alternative locations where setuptools should look for tarballs::
-
-    dependency_links=['http://example.com/yourfiles']
-
-Make sure that page has a directory listing and the links on the page are
-pointing to the actual tarballs with their correct filenames as this is
-how setuptools will find the files.  If you have an internal company
-server that contains the packages, provide the URL to that server.
-
-
-Installing / Developing
------------------------
-
-To install your application (ideally into a virtualenv) just run the
-:file:`setup.py` script with the ``install`` parameter.  It will install your
-application into the virtualenv's site-packages folder and also download
-and install all dependencies::
-
-    $ python setup.py install
-
-If you are developing on the package and also want the requirements to be
-installed, you can use the ``develop`` command instead::
-
-    $ python setup.py develop
-
-This has the advantage of just installing a link to the site-packages
-folder instead of copying the data over.  You can then continue to work on
-the code without having to run ``install`` again after each change.
-
-
-.. _pip: https://pypi.org/project/pip/
-.. _Setuptools: https://pypi.org/project/setuptools/
diff --git a/docs/patterns/fabric.rst b/docs/patterns/fabric.rst
deleted file mode 100644
index 0cd39ddc..00000000
--- a/docs/patterns/fabric.rst
+++ /dev/null
@@ -1,184 +0,0 @@
-Deploying with Fabric
-=====================
-
-`Fabric`_ is a tool for Python similar to Makefiles but with the ability
-to execute commands on a remote server.  In combination with a properly
-set up Python package (:doc:`packages`) and a good concept for
-configurations (:doc:`/config`) it is very easy to deploy Flask
-applications to external servers.
-
-Before we get started, here a quick checklist of things we have to ensure
-upfront:
-
--   Fabric 1.0 has to be installed locally.  This tutorial assumes the
-    latest version of Fabric.
--   The application already has to be a package and requires a working
-    :file:`setup.py` file (:doc:`distribute`).
--   In the following example we are using `mod_wsgi` for the remote
-    servers.  You can of course use your own favourite server there, but
-    for this example we chose Apache + `mod_wsgi` because it's very easy
-    to setup and has a simple way to reload applications without root
-    access.
-
-Creating the first Fabfile
---------------------------
-
-A fabfile is what controls what Fabric executes.  It is named :file:`fabfile.py`
-and executed by the `fab` command.  All the functions defined in that file
-will show up as `fab` subcommands.  They are executed on one or more
-hosts.  These hosts can be defined either in the fabfile or on the command
-line.  In this case we will add them to the fabfile.
-
-This is a basic first example that has the ability to upload the current
-source code to the server and install it into a pre-existing
-virtual environment::
-
-    from fabric.api import *
-
-    # the user to use for the remote commands
-    env.user = 'appuser'
-    # the servers where the commands are executed
-    env.hosts = ['server1.example.com', 'server2.example.com']
-
-    def pack():
-        # build the package
-        local('python setup.py sdist --formats=gztar', capture=False)
-
-    def deploy():
-        # figure out the package name and version
-        dist = local('python setup.py --fullname', capture=True).strip()
-        filename = f'{dist}.tar.gz'
-
-        # upload the package to the temporary folder on the server
-        put(f'dist/{filename}', f'/tmp/{filename}')
-
-        # install the package in the application's virtualenv with pip
-        run(f'/var/www/yourapplication/env/bin/pip install /tmp/{filename}')
-
-        # remove the uploaded package
-        run(f'rm -r /tmp/{filename}')
-
-        # touch the .wsgi file to trigger a reload in mod_wsgi
-        run('touch /var/www/yourapplication.wsgi')
-
-Running Fabfiles
-----------------
-
-Now how do you execute that fabfile?  You use the `fab` command.  To
-deploy the current version of the code on the remote server you would use
-this command::
-
-    $ fab pack deploy
-
-However this requires that our server already has the
-:file:`/var/www/yourapplication` folder created and
-:file:`/var/www/yourapplication/env` to be a virtual environment.  Furthermore
-are we not creating the configuration or ``.wsgi`` file on the server.  So
-how do we bootstrap a new server into our infrastructure?
-
-This now depends on the number of servers we want to set up.  If we just
-have one application server (which the majority of applications will
-have), creating a command in the fabfile for this is overkill.  But
-obviously you can do that.  In that case you would probably call it
-`setup` or `bootstrap` and then pass the servername explicitly on the
-command line::
-
-    $ fab -H newserver.example.com bootstrap
-
-To setup a new server you would roughly do these steps:
-
-1.  Create the directory structure in :file:`/var/www`::
-
-        $ mkdir /var/www/yourapplication
-        $ cd /var/www/yourapplication
-        $ virtualenv --distribute env
-
-2.  Upload a new :file:`application.wsgi` file to the server and the
-    configuration file for the application (eg: :file:`application.cfg`)
-
-3.  Create a new Apache config for ``yourapplication`` and activate it.
-    Make sure to activate watching for changes of the ``.wsgi`` file so
-    that we can automatically reload the application by touching it.
-    See :doc:`/deploying/mod_wsgi`.
-
-So now the question is, where do the :file:`application.wsgi` and
-:file:`application.cfg` files come from?
-
-The WSGI File
--------------
-
-The WSGI file has to import the application and also to set an environment
-variable so that the application knows where to look for the config.  This
-is a short example that does exactly that::
-
-    import os
-    os.environ['YOURAPPLICATION_CONFIG'] = '/var/www/yourapplication/application.cfg'
-    from yourapplication import app
-
-The application itself then has to initialize itself like this to look for
-the config at that environment variable::
-
-    app = Flask(__name__)
-    app.config.from_object('yourapplication.default_config')
-    app.config.from_envvar('YOURAPPLICATION_CONFIG')
-
-This approach is explained in detail in the :doc:`/config` section of the
-documentation.
-
-The Configuration File
-----------------------
-
-Now as mentioned above, the application will find the correct
-configuration file by looking up the ``YOURAPPLICATION_CONFIG`` environment
-variable.  So we have to put the configuration in a place where the
-application will able to find it.  Configuration files have the unfriendly
-quality of being different on all computers, so you do not version them
-usually.
-
-A popular approach is to store configuration files for different servers
-in a separate version control repository and check them out on all
-servers.  Then symlink the file that is active for the server into the
-location where it's expected (eg: :file:`/var/www/yourapplication`).
-
-Either way, in our case here we only expect one or two servers and we can
-upload them ahead of time by hand.
-
-
-First Deployment
-----------------
-
-Now we can do our first deployment.  We have set up the servers so that
-they have their virtual environments and activated apache configs.  Now we
-can pack up the application and deploy it::
-
-    $ fab pack deploy
-
-Fabric will now connect to all servers and run the commands as written
-down in the fabfile.  First it will execute pack so that we have our
-tarball ready and then it will execute deploy and upload the source code
-to all servers and install it there.  Thanks to the :file:`setup.py` file we
-will automatically pull in the required libraries into our virtual
-environment.
-
-Next Steps
-----------
-
-From that point onwards there is so much that can be done to make
-deployment actually fun:
-
--   Create a `bootstrap` command that initializes new servers.  It could
-    initialize a new virtual environment, setup apache appropriately etc.
--   Put configuration files into a separate version control repository
-    and symlink the active configs into place.
--   You could also put your application code into a repository and check
-    out the latest version on the server and then install.  That way you
-    can also easily go back to older versions.
--   hook in testing functionality so that you can deploy to an external
-    server and run the test suite.
-
-Working with Fabric is fun and you will notice that it's quite magical to
-type ``fab deploy`` and see your application being deployed automatically
-to one or more remote servers.
-
-
-.. _Fabric: https://www.fabfile.org/
diff --git a/docs/patterns/index.rst b/docs/patterns/index.rst
index f765cd8a..1f2c07dd 100644
--- a/docs/patterns/index.rst
+++ b/docs/patterns/index.rst
@@ -19,8 +19,6 @@ collected in the following pages.
    appfactories
    appdispatch
    urlprocessors
-   distribute
-   fabric
    sqlite3
    sqlalchemy
    fileuploads
@@ -29,7 +27,7 @@ collected in the following pages.
    wtforms
    templateinheritance
    flashing
-   jquery
+   javascript
    lazyloading
    mongoengine
    favicon
diff --git a/docs/patterns/javascript.rst b/docs/patterns/javascript.rst
new file mode 100644
index 00000000..4b1d7e0f
--- /dev/null
+++ b/docs/patterns/javascript.rst
@@ -0,0 +1,259 @@
+JavaScript, ``fetch``, and JSON
+===============================
+
+You may want to make your HTML page dynamic, by changing data without
+reloading the entire page. Instead of submitting an HTML ``<form>`` and
+performing a redirect to re-render the template, you can add
+`JavaScript`_ that calls |fetch|_ and replaces content on the page.
+
+|fetch|_ is the modern, built-in JavaScript solution to making
+requests from a page. You may have heard of other "AJAX" methods and
+libraries, such as |XHR|_ or `jQuery`_. These are no longer needed in
+modern browsers, although you may choose to use them or another library
+depending on your application's requirements. These docs will only focus
+on built-in JavaScript features.
+
+.. _JavaScript: https://developer.mozilla.org/Web/JavaScript
+.. |fetch| replace:: ``fetch()``
+.. _fetch: https://developer.mozilla.org/Web/API/Fetch_API
+.. |XHR| replace:: ``XMLHttpRequest()``
+.. _XHR: https://developer.mozilla.org/Web/API/XMLHttpRequest
+.. _jQuery: https://jquery.com/
+
+
+Rendering Templates
+-------------------
+
+It is important to understand the difference between templates and
+JavaScript. Templates are rendered on the server, before the response is
+sent to the user's browser. JavaScript runs in the user's browser, after
+the template is rendered and sent. Therefore, it is impossible to use
+JavaScript to affect how the Jinja template is rendered, but it is
+possible to render data into the JavaScript that will run.
+
+To provide data to JavaScript when rendering the template, use the
+:func:`~jinja-filters.tojson` filter in a ``<script>`` block. This will
+convert the data to a valid JavaScript object, and ensure that any
+unsafe HTML characters are rendered safely. If you do not use the
+``tojson`` filter, you will get a ``SyntaxError`` in the browser
+console.
+
+.. code-block:: python
+
+    data = generate_report()
+    return render_template("report.html", chart_data=data)
+
+.. code-block:: jinja
+
+    <script>
+        const chart_data = {{ chart_data|tojson }}
+        chartLib.makeChart(chart_data)
+    </script>
+
+A less common pattern is to add the data to a ``data-`` attribute on an
+HTML tag. In this case, you must use single quotes around the value, not
+double quotes, otherwise you will produce invalid or unsafe HTML.
+
+.. code-block:: jinja
+
+    <div data-chart='{{ chart_data|tojson }}'></div>
+
+
+Generating URLs
+---------------
+
+The other way to get data from the server to JavaScript is to make a
+request for it. First, you need to know the URL to request.
+
+The simplest way to generate URLs is to continue to use
+:func:`~flask.url_for` when rendering the template. For example:
+
+.. code-block:: javascript
+
+    const user_url = {{ url_for("user", id=current_user.id)|tojson }}
+    fetch(user_url).then(...)
+
+However, you might need to generate a URL based on information you only
+know in JavaScript. As discussed above, JavaScript runs in the user's
+browser, not as part of the template rendering, so you can't use
+``url_for`` at that point.
+
+In this case, you need to know the "root URL" under which your
+application is served. In simple setups, this is ``/``, but it might
+also be something else, like ``https://example.com/myapp/``.
+
+A simple way to tell your JavaScript code about this root is to set it
+as a global variable when rendering the template. Then you can use it
+when generating URLs from JavaScript.
+
+.. code-block:: javascript
+
+    const SCRIPT_ROOT = {{ request.script_root|tojson }}
+    let user_id = ...  // do something to get a user id from the page
+    let user_url = `${SCRIPT_ROOT}/user/${user_id}`
+    fetch(user_url).then(...)
+
+
+Making a Request with ``fetch``
+-------------------------------
+
+|fetch|_ takes two arguments, a URL and an object with other options,
+and returns a |Promise|_. We won't cover all the available options, and
+will only use ``then()`` on the promise, not other callbacks or
+``await`` syntax. Read the linked MDN docs for more information about
+those features.
+
+By default, the GET method is used. If the response contains JSON, it
+can be used with a ``then()`` callback chain.
+
+.. code-block:: javascript
+
+    const room_url = {{ url_for("room_detail", id=room.id)|tojson }}
+    fetch(room_url)
+        .then(response => response.json())
+        .then(data => {
+            // data is a parsed JSON object
+        })
+
+To send data, use a data method such as POST, and pass the ``body``
+option. The most common types for data are form data or JSON data.
+
+To send form data, pass a populated |FormData|_ object. This uses the
+same format as an HTML form, and would be accessed with ``request.form``
+in a Flask view.
+
+.. code-block:: javascript
+
+    let data = new FormData()
+    data.append("name": "Flask Room")
+    data.append("description": "Talk about Flask here.")
+    fetch(room_url, {
+        "method": "POST",
+        "body": data,
+    }).then(...)
+
+In general, prefer sending request data as form data, as would be used
+when submitting an HTML form. JSON can represent more complex data, but
+unless you need that it's better to stick with the simpler format. When
+sending JSON data, the ``Content-Type: application/json`` header must be
+sent as well, otherwise Flask will return a 400 error.
+
+.. code-block:: javascript
+
+    let data = {
+        "name": "Flask Room",
+        "description": "Talk about Flask here.",
+    }
+    fetch(room_url, {
+        "method": "POST",
+        "headers": {"Content-Type": "application/json"},
+        "body": JSON.stringify(data),
+    }).then(...)
+
+.. |Promise| replace:: ``Promise``
+.. _Promise: https://developer.mozilla.org/Web/JavaScript/Reference/Global_Objects/Promise
+.. |FormData| replace:: ``FormData``
+.. _FormData: https://developer.mozilla.org/en-US/docs/Web/API/FormData
+
+
+Following Redirects
+-------------------
+
+A response might be a redirect, for example if you logged in with
+JavaScript instead of a traditional HTML form, and your view returned
+a redirect instead of JSON. JavaScript requests do follow redirects, but
+they don't change the page. If you want to make the page change you can
+inspect the response and apply the redirect manually.
+
+.. code-block:: javascript
+
+    fetch("/login", {"body": ...}).then(
+        response => {
+            if (response.redirected) {
+                window.location = response.url
+            } else {
+                showLoginError()
+            }
+        }
+    )
+
+
+Replacing Content
+-----------------
+
+A response might be new HTML, either a new section of the page to add or
+replace, or an entirely new page. In general, if you're returning the
+entire page, it would be better to handle that with a redirect as shown
+in the previous section. The following example shows how to replace a
+``<div>`` with the HTML returned by a request.
+
+.. code-block:: html
+
+    <div id="geology-fact">
+        {{ include "geology_fact.html" }}
+    </div>
+    <script>
+        const geology_url = {{ url_for("geology_fact")|tojson }}
+        const geology_div = getElementById("geology-fact")
+        fetch(geology_url)
+            .then(response => response.text)
+            .then(text => geology_div.innerHtml = text)
+    </script>
+
+
+Return JSON from Views
+----------------------
+
+To return a JSON object from your API view, you can directly return a
+dict from the view. It will be serialized to JSON automatically.
+
+.. code-block:: python
+
+    @app.route("/user/<int:id>")
+    def user_detail(id):
+        user = User.query.get_or_404(id)
+        return {
+            "username": User.username,
+            "email": User.email,
+            "picture": url_for("static", filename=f"users/{id}/profile.png"),
+        }
+
+If you want to return another JSON type, use the
+:func:`~flask.json.jsonify` function, which creates a response object
+with the given data serialized to JSON.
+
+.. code-block:: python
+
+    from flask import jsonify
+
+    @app.route("/users")
+    def user_list():
+        users = User.query.order_by(User.name).all()
+        return jsonify([u.to_json() for u in users])
+
+It is usually not a good idea to return file data in a JSON response.
+JSON cannot represent binary data directly, so it must be base64
+encoded, which can be slow, takes more bandwidth to send, and is not as
+easy to cache. Instead, serve files using one view, and generate a URL
+to the desired file to include in the JSON. Then the client can make a
+separate request to get the linked resource after getting the JSON.
+
+
+Receiving JSON in Views
+-----------------------
+
+Use the :attr:`~flask.Request.json` property of the
+:data:`~flask.request` object to decode the request's body as JSON. If
+the body is not valid JSON, or the ``Content-Type`` header is not set to
+``application/json``, a 400 Bad Request error will be raised.
+
+.. code-block:: python
+
+    from flask import request
+
+    @app.post("/user/<int:id>")
+    def user_update(id):
+        user = User.query.get_or_404(id)
+        user.update_from_json(request.json)
+        db.session.commit()
+        return user.to_json()
diff --git a/docs/patterns/jquery.rst b/docs/patterns/jquery.rst
index 0a75bb71..7ac6856e 100644
--- a/docs/patterns/jquery.rst
+++ b/docs/patterns/jquery.rst
@@ -1,148 +1,6 @@
+:orphan:
+
 AJAX with jQuery
 ================
 
-`jQuery`_ is a small JavaScript library commonly used to simplify working
-with the DOM and JavaScript in general.  It is the perfect tool to make
-web applications more dynamic by exchanging JSON between server and
-client.
-
-JSON itself is a very lightweight transport format, very similar to how
-Python primitives (numbers, strings, dicts and lists) look like which is
-widely supported and very easy to parse.  It became popular a few years
-ago and quickly replaced XML as transport format in web applications.
-
-.. _jQuery: https://jquery.com/
-
-Loading jQuery
---------------
-
-In order to use jQuery, you have to download it first and place it in the
-static folder of your application and then ensure it's loaded.  Ideally
-you have a layout template that is used for all pages where you just have
-to add a script statement to the bottom of your ``<body>`` to load jQuery:
-
-.. sourcecode:: html
-
-   <script src="{{ url_for('static', filename='jquery.js') }}"></script>
-
-Another method is using Google's `AJAX Libraries API
-<https://developers.google.com/speed/libraries/>`_ to load jQuery:
-
-.. sourcecode:: html
-
-    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
-    <script>window.jQuery || document.write('<script src="{{
-      url_for('static', filename='jquery.js') }}">\x3C/script>')</script>
-
-In this case you have to put jQuery into your static folder as a fallback, but it will
-first try to load it directly from Google. This has the advantage that your
-website will probably load faster for users if they went to at least one
-other website before using the same jQuery version from Google because it
-will already be in the browser cache.
-
-Where is My Site?
------------------
-
-Do you know where your application is?  If you are developing the answer
-is quite simple: it's on localhost port something and directly on the root
-of that server.  But what if you later decide to move your application to
-a different location?  For example to ``http://example.com/myapp``?  On
-the server side this never was a problem because we were using the handy
-:func:`~flask.url_for` function that could answer that question for
-us, but if we are using jQuery we should not hardcode the path to
-the application but make that dynamic, so how can we do that?
-
-A simple method would be to add a script tag to our page that sets a
-global variable to the prefix to the root of the application.  Something
-like this:
-
-.. sourcecode:: html+jinja
-
-   <script>
-     $SCRIPT_ROOT = {{ request.script_root|tojson }};
-   </script>
-
-
-JSON View Functions
--------------------
-
-Now let's create a server side function that accepts two URL arguments of
-numbers which should be added together and then sent back to the
-application in a JSON object.  This is a really ridiculous example and is
-something you usually would do on the client side alone, but a simple
-example that shows how you would use jQuery and Flask nonetheless::
-
-    from flask import Flask, jsonify, render_template, request
-    app = Flask(__name__)
-
-    @app.route('/_add_numbers')
-    def add_numbers():
-        a = request.args.get('a', 0, type=int)
-        b = request.args.get('b', 0, type=int)
-        return jsonify(result=a + b)
-
-    @app.route('/')
-    def index():
-        return render_template('index.html')
-
-As you can see I also added an `index` method here that renders a
-template.  This template will load jQuery as above and have a little form where
-we can add two numbers and a link to trigger the function on the server
-side.
-
-Note that we are using the :meth:`~werkzeug.datastructures.MultiDict.get` method here
-which will never fail.  If the key is missing a default value (here ``0``)
-is returned.  Furthermore it can convert values to a specific type (like
-in our case `int`).  This is especially handy for code that is
-triggered by a script (APIs, JavaScript etc.) because you don't need
-special error reporting in that case.
-
-The HTML
---------
-
-Your index.html template either has to extend a :file:`layout.html` template with
-jQuery loaded and the `$SCRIPT_ROOT` variable set, or do that on the top.
-Here's the HTML code needed for our little application (:file:`index.html`).
-Notice that we also drop the script directly into the HTML here.  It is
-usually a better idea to have that in a separate script file:
-
-.. sourcecode:: html
-
-    <script>
-      $(function() {
-        $('a#calculate').bind('click', function() {
-          $.getJSON($SCRIPT_ROOT + '/_add_numbers', {
-            a: $('input[name="a"]').val(),
-            b: $('input[name="b"]').val()
-          }, function(data) {
-            $("#result").text(data.result);
-          });
-          return false;
-        });
-      });
-    </script>
-    <h1>jQuery Example</h1>
-    <p><input type=text size=5 name=a> +
-       <input type=text size=5 name=b> =
-       <span id=result>?</span>
-    <p><a href=# id=calculate>calculate server side</a>
-
-I won't go into detail here about how jQuery works, just a very quick
-explanation of the little bit of code above:
-
-1. ``$(function() { ... })`` specifies code that should run once the
-   browser is done loading the basic parts of the page.
-2. ``$('selector')`` selects an element and lets you operate on it.
-3. ``element.bind('event', func)`` specifies a function that should run
-   when the user clicked on the element.  If that function returns
-   `false`, the default behavior will not kick in (in this case, navigate
-   to the `#` URL).
-4. ``$.getJSON(url, data, func)`` sends a ``GET`` request to `url` and will
-   send the contents of the `data` object as query parameters.  Once the
-   data arrived, it will call the given function with the return value as
-   argument.  Note that we can use the `$SCRIPT_ROOT` variable here that
-   we set earlier.
-
-Check out the :gh:`example source <examples/javascript>` for a full
-application demonstrating the code on this page, as well as the same
-thing using ``XMLHttpRequest`` and ``fetch``.
+Obsolete, see :doc:`/patterns/javascript` instead.
diff --git a/docs/patterns/packages.rst b/docs/patterns/packages.rst
index 7c3a34cf..3c7ae425 100644
--- a/docs/patterns/packages.rst
+++ b/docs/patterns/packages.rst
@@ -56,70 +56,19 @@ a big problem, just add a new file called :file:`setup.py` next to the inner
         ],
     )
 
-In order to run the application you need to export an environment variable
-that tells Flask where to find the application instance:
+Install your application so it is importable:
 
-.. tabs::
+.. code-block:: text
 
-   .. group-tab:: Bash
-
-      .. code-block:: text
-
-         $ export FLASK_APP=yourapplication
-
-   .. group-tab:: Fish
-
-      .. code-block:: text
-
-         $ set -x FLASK_APP yourapplication
-
-   .. group-tab:: CMD
-
-      .. code-block:: text
-
-         > set FLASK_APP=yourapplication
-
-   .. group-tab:: Powershell
-
-      .. code-block:: text
-
-         > $env:FLASK_APP = "yourapplication"
-
-If you are outside of the project directory make sure to provide the exact
-path to your application directory. Similarly you can turn on the
-development features like this:
-
-.. tabs::
-
-   .. group-tab:: Bash
-
-      .. code-block:: text
-
-         $ export FLASK_ENV=development
-
-   .. group-tab:: Fish
-
-      .. code-block:: text
-
-         $ set -x FLASK_ENV development
-
-   .. group-tab:: CMD
-
-      .. code-block:: text
-
-         > set FLASK_ENV=development
-
-   .. group-tab:: Powershell
-
-      .. code-block:: text
+    $ pip install -e .
 
-         > $env:FLASK_ENV = "development"
+To use the ``flask`` command and run your application you need to set
+the ``--app`` option that tells Flask where to find the application
+instance:
 
-In order to install and run the application you need to issue the following
-commands::
+.. code-block:: text
 
-    $ pip install -e .
-    $ flask run
+    $ flask --app yourapplication run
 
 What did we gain from this?  Now we can restructure the application a bit
 into multiple modules.  The only thing you have to remember is the
@@ -173,10 +122,6 @@ You should then end up with something like that::
    ensuring the module is imported and we are doing that at the bottom of
    the file.
 
-   There are still some problems with that approach but if you want to use
-   decorators there is no way around that.  Check out the
-   :doc:`/becomingbig` section for some inspiration how to deal with that.
-
 
 Working with Blueprints
 -----------------------
diff --git a/docs/patterns/sqlite3.rst b/docs/patterns/sqlite3.rst
index 12336fb1..5932589f 100644
--- a/docs/patterns/sqlite3.rst
+++ b/docs/patterns/sqlite3.rst
@@ -30,10 +30,6 @@ or create an application context itself.  At that point the ``get_db``
 function can be used to get the current database connection.  Whenever the
 context is destroyed the database connection will be terminated.
 
-Note: if you use Flask 0.9 or older you need to use
-``flask._app_ctx_stack.top`` instead of ``g`` as the :data:`flask.g`
-object was bound to the request and not application context.
-
 Example::
 
     @app.route('/')
diff --git a/docs/patterns/streaming.rst b/docs/patterns/streaming.rst
index e8571ffd..c9e6ef22 100644
--- a/docs/patterns/streaming.rst
+++ b/docs/patterns/streaming.rst
@@ -20,7 +20,7 @@ data and to then invoke that function and pass it to a response object::
         def generate():
             for row in iter_all_rows():
                 yield f"{','.join(row)}\n"
-        return app.response_class(generate(), mimetype='text/csv')
+        return generate(), {"Content-Type": "text/csv"}
 
 Each ``yield`` expression is directly sent to the browser.  Note though
 that some WSGI middlewares might break streaming, so be careful there in
@@ -29,52 +29,57 @@ debug environments with profilers and other things you might have enabled.
 Streaming from Templates
 ------------------------
 
-The Jinja2 template engine also supports rendering templates piece by
-piece.  This functionality is not directly exposed by Flask because it is
-quite uncommon, but you can easily do it yourself::
-
-    def stream_template(template_name, **context):
-        app.update_template_context(context)
-        t = app.jinja_env.get_template(template_name)
-        rv = t.stream(context)
-        rv.enable_buffering(5)
-        return rv
-
-    @app.route('/my-large-page.html')
-    def render_large_template():
-        rows = iter_all_rows()
-        return app.response_class(stream_template('the_template.html', rows=rows))
-
-The trick here is to get the template object from the Jinja2 environment
-on the application and to call :meth:`~jinja2.Template.stream` instead of
-:meth:`~jinja2.Template.render` which returns a stream object instead of a
-string.  Since we're bypassing the Flask template render functions and
-using the template object itself we have to make sure to update the render
-context ourselves by calling :meth:`~flask.Flask.update_template_context`.
-The template is then evaluated as the stream is iterated over.  Since each
-time you do a yield the server will flush the content to the client you
-might want to buffer up a few items in the template which you can do with
-``rv.enable_buffering(size)``.  ``5`` is a sane default.
+The Jinja2 template engine supports rendering a template piece by
+piece, returning an iterator of strings. Flask provides the
+:func:`~flask.stream_template` and :func:`~flask.stream_template_string`
+functions to make this easier to use.
+
+.. code-block:: python
+
+    from flask import stream_template
+
+    @app.get("/timeline")
+    def timeline():
+        return stream_template("timeline.html")
+
+The parts yielded by the render stream tend to match statement blocks in
+the template.
+
 
 Streaming with Context
 ----------------------
 
-.. versionadded:: 0.9
+The :data:`~flask.request` will not be active while the generator is
+running, because the view has already returned at that point. If you try
+to access ``request``, you'll get a ``RuntimeError``.
 
-Note that when you stream data, the request context is already gone the
-moment the function executes.  Flask 0.9 provides you with a helper that
-can keep the request context around during the execution of the
-generator::
+If your generator function relies on data in ``request``, use the
+:func:`~flask.stream_with_context` wrapper. This will keep the request
+context active during the generator.
+
+.. code-block:: python
 
     from flask import stream_with_context, request
+    from markupsafe import escape
 
     @app.route('/stream')
     def streamed_response():
         def generate():
-            yield 'Hello '
-            yield request.args['name']
-            yield '!'
-        return app.response_class(stream_with_context(generate()))
+            yield '<p>Hello '
+            yield escape(request.args['name'])
+            yield '!</p>'
+        return stream_with_context(generate())
+
+It can also be used as a decorator.
+
+.. code-block:: python
+
+    @stream_with_context
+    def generate():
+        ...
+
+    return generate()
 
-Without the :func:`~flask.stream_with_context` function you would get a
-:class:`RuntimeError` at that point.
+The :func:`~flask.stream_template` and
+:func:`~flask.stream_template_string` functions automatically
+use :func:`~flask.stream_with_context` if a request is active.
diff --git a/docs/quickstart.rst b/docs/quickstart.rst
index a6956c32..ad9e3bc4 100644
--- a/docs/quickstart.rst
+++ b/docs/quickstart.rst
@@ -39,50 +39,20 @@ Save it as :file:`hello.py` or something similar. Make sure to not call
 your application :file:`flask.py` because this would conflict with Flask
 itself.
 
-To run the application, use the :command:`flask` command or
-:command:`python -m flask`. Before you can do that you need
-to tell your terminal the application to work with by exporting the
-``FLASK_APP`` environment variable:
+To run the application, use the ``flask`` command or
+``python -m flask``. You need to tell the Flask where your application
+is with the ``--app`` option.
 
-.. tabs::
-
-   .. group-tab:: Bash
-
-      .. code-block:: text
-
-         $ export FLASK_APP=hello
-         $ flask run
-          * Running on http://127.0.0.1:5000/
-
-   .. group-tab:: Fish
-
-      .. code-block:: text
-
-         $ set -x FLASK_APP hello
-         $ flask run
-          * Running on http://127.0.0.1:5000/
-
-   .. group-tab:: CMD
-
-      .. code-block:: text
-
-         > set FLASK_APP=hello
-         > flask run
-          * Running on http://127.0.0.1:5000/
-
-   .. group-tab:: Powershell
-
-      .. code-block:: text
+.. code-block:: text
 
-         > $env:FLASK_APP = "hello"
-         > flask run
-          * Running on http://127.0.0.1:5000/
+    $ flask --app hello run
+     * Serving Flask app 'hello'
+     * Running on http://127.0.0.1:5000 (Press CTRL+C to quit)
 
 .. admonition:: Application Discovery Behavior
 
     As a shortcut, if the file is named ``app.py`` or ``wsgi.py``, you
-    don't have to set the ``FLASK_APP`` environment variable. See
-    :doc:`/cli` for more details.
+    don't have to use ``--app``. See :doc:`/cli` for more details.
 
 This launches a very simple builtin server, which is good enough for
 testing but probably not what you want to use in production. For
@@ -114,34 +84,6 @@ handle that.
    This tells your operating system to listen on all public IPs.
 
 
-What to do if the Server does not Start
----------------------------------------
-
-In case the :command:`python -m flask` fails or :command:`flask`
-does not exist, there are multiple reasons this might be the case.
-First of all you need to look at the error message.
-
-Old Version of Flask
-````````````````````
-
-Versions of Flask older than 0.11 used to have different ways to start the
-application.  In short, the :command:`flask` command did not exist, and
-neither did :command:`python -m flask`.  In that case you have two options:
-either upgrade to newer Flask versions or have a look at :doc:`/server`
-to see the alternative method for running a server.
-
-Invalid Import Name
-```````````````````
-
-The ``FLASK_APP`` environment variable is the name of the module to import at
-:command:`flask run`. In case that module is incorrectly named you will get an
-import error upon start (or if debug is enabled when you navigate to the
-application). It will tell you what it tried to import and why it failed.
-
-The most common reason is a typo or because you did not actually create an
-``app`` object.
-
-
 Debug Mode
 ----------
 
@@ -162,43 +104,21 @@ error occurs during a request.
     security risk. Do not run the development server or debugger in a
     production environment.
 
-To enable all development features, set the ``FLASK_ENV`` environment
-variable to ``development`` before calling ``flask run``.
-
-.. tabs::
-
-   .. group-tab:: Bash
-
-      .. code-block:: text
-
-         $ export FLASK_ENV=development
-         $ flask run
-
-   .. group-tab:: Fish
+To enable debug mode, use the ``--debug`` option.
 
-      .. code-block:: text
-
-         $ set -x FLASK_ENV development
-         $ flask run
-
-   .. group-tab:: CMD
-
-      .. code-block:: text
-
-         > set FLASK_ENV=development
-         > flask run
-
-   .. group-tab:: Powershell
-
-      .. code-block:: text
+.. code-block:: text
 
-         > $env:FLASK_ENV = "development"
-         > flask run
+    $ flask --app hello run --debug
+     * Serving Flask app 'hello'
+     * Debug mode: on
+     * Running on http://127.0.0.1:5000 (Press CTRL+C to quit)
+     * Restarting with stat
+     * Debugger is active!
+     * Debugger PIN: nnn-nnn-nnn
 
 See also:
 
--   :doc:`/server` and :doc:`/cli` for information about running in
-    development mode.
+-   :doc:`/server` and :doc:`/cli` for information about running in debug mode.
 -   :doc:`/debugging` for information about using the built-in debugger
     and other debuggers.
 -   :doc:`/logging` and :doc:`/errorhandling` to log errors and display
@@ -390,6 +310,24 @@ of the :meth:`~flask.Flask.route` decorator to handle different HTTP methods.
         else:
             return show_the_login_form()
 
+The example above keeps all methods for the route within one function,
+which can be useful if each part uses some common data.
+
+You can also separate views for different methods into different
+functions. Flask provides a shortcut for decorating such routes with
+:meth:`~flask.Flask.get`, :meth:`~flask.Flask.post`, etc. for each
+common HTTP method.
+
+.. code-block:: python
+
+    @app.get('/login')
+    def login_get():
+        return show_the_login_form()
+
+    @app.post('/login')
+    def login_post():
+        return do_the_login()
+
 If ``GET`` is present, Flask automatically adds support for the ``HEAD`` method
 and handles ``HEAD`` requests according to the `HTTP RFC`_. Likewise,
 ``OPTIONS`` is automatically implemented for you.
@@ -419,6 +357,14 @@ cumbersome because you have to do the HTML escaping on your own to keep
 the application secure.  Because of that Flask configures the `Jinja2
 <https://palletsprojects.com/p/jinja/>`_ template engine for you automatically.
 
+Templates can be used to generate any type of text file. For web applications, you'll
+primarily be generating HTML pages, but you can also generate markdown, plain text for
+emails, any anything else.
+
+For a reference to HTML, CSS, and other web APIs, use the `MDN Web Docs`_.
+
+.. _MDN Web Docs: https://developer.mozilla.org/
+
 To render a template you can use the :func:`~flask.render_template`
 method.  All you have to do is provide the name of the template and the
 variables you want to pass to the template engine as keyword arguments.
@@ -740,22 +686,25 @@ The return value from a view function is automatically converted into
 a response object for you. If the return value is a string it's
 converted into a response object with the string as response body, a
 ``200 OK`` status code and a :mimetype:`text/html` mimetype. If the
-return value is a dict, :func:`jsonify` is called to produce a response.
-The logic that Flask applies to converting return values into response
-objects is as follows:
+return value is a dict or list, :func:`jsonify` is called to produce a
+response. The logic that Flask applies to converting return values into
+response objects is as follows:
 
 1.  If a response object of the correct type is returned it's directly
     returned from the view.
 2.  If it's a string, a response object is created with that data and
     the default parameters.
-3.  If it's a dict, a response object is created using ``jsonify``.
-4.  If a tuple is returned the items in the tuple can provide extra
+3.  If it's an iterator or generator returning strings or bytes, it is
+    treated as a streaming response.
+4.  If it's a dict or list, a response object is created using
+    :func:`~flask.json.jsonify`.
+5.  If a tuple is returned the items in the tuple can provide extra
     information. Such tuples have to be in the form
     ``(response, status)``, ``(response, headers)``, or
     ``(response, status, headers)``. The ``status`` value will override
     the status code and ``headers`` can be a list or dictionary of
     additional header values.
-5.  If none of that works, Flask will assume the return value is a
+6.  If none of that works, Flask will assume the return value is a
     valid WSGI application and convert that into a response object.
 
 If you want to get hold of the resulting response object inside the view
@@ -786,8 +735,8 @@ APIs with JSON
 ``````````````
 
 A common response format when writing an API is JSON. It's easy to get
-started writing such an API with Flask. If you return a ``dict`` from a
-view, it will be converted to a JSON response.
+started writing such an API with Flask. If you return a ``dict`` or
+``list`` from a view, it will be converted to a JSON response.
 
 .. code-block:: python
 
@@ -800,20 +749,20 @@ view, it will be converted to a JSON response.
             "image": url_for("user_image", filename=user.image),
         }
 
-Depending on your API design, you may want to create JSON responses for
-types other than ``dict``. In that case, use the
-:func:`~flask.json.jsonify` function, which will serialize any supported
-JSON data type. Or look into Flask community extensions that support
-more complex applications.
-
-.. code-block:: python
-
-    from flask import jsonify
-
     @app.route("/users")
     def users_api():
         users = get_all_users()
-        return jsonify([user.to_json() for user in users])
+        return [user.to_json() for user in users]
+
+This is a shortcut to passing the data to the
+:func:`~flask.json.jsonify` function, which will serialize any supported
+JSON data type. That means that all the data in the dict or list must be
+JSON serializable.
+
+For complex types such as database models, you'll want to use a
+serialization library to convert the data to valid JSON types first.
+There are many serialization libraries and Flask API extensions
+maintained by the community that support more complex applications.
 
 
 .. _sessions:
diff --git a/docs/reqcontext.rst b/docs/reqcontext.rst
index b67745ed..70ea13e3 100644
--- a/docs/reqcontext.rst
+++ b/docs/reqcontext.rst
@@ -37,12 +37,14 @@ context, which also pushes an :doc:`app context </appcontext>`. When the
 request ends it pops the request context then the application context.
 
 The context is unique to each thread (or other worker type).
-:data:`request` cannot be passed to another thread, the other thread
-will have a different context stack and will not know about the request
-the parent thread was pointing to.
+:data:`request` cannot be passed to another thread, the other thread has
+a different context space and will not know about the request the parent
+thread was pointing to.
 
-Context locals are implemented in Werkzeug. See :doc:`werkzeug:local`
-for more information on how this works internally.
+Context locals are implemented using Python's :mod:`contextvars` and
+Werkzeug's :class:`~werkzeug.local.LocalProxy`. Python manages the
+lifetime of context vars automatically, and local proxy wraps that
+low-level interface to make the data easier to work with.
 
 
 Manually Push a Context
@@ -67,11 +69,12 @@ everything that runs in the block will have access to :data:`request`,
 populated with your test data. ::
 
     def generate_report(year):
-        format = request.args.get('format')
+        format = request.args.get("format")
         ...
 
     with app.test_request_context(
-            '/make_report/2017', data={'format': 'short'}):
+        "/make_report/2017", query_string={"format": "short"}
+    ):
         generate_report()
 
 If you see that error somewhere else in your code not related to
@@ -87,10 +90,9 @@ How the Context Works
 
 The :meth:`Flask.wsgi_app` method is called to handle each request. It
 manages the contexts during the request. Internally, the request and
-application contexts work as stacks, :data:`_request_ctx_stack` and
-:data:`_app_ctx_stack`. When contexts are pushed onto the stack, the
+application contexts work like stacks. When contexts are pushed, the
 proxies that depend on them are available and point at information from
-the top context on the stack.
+the top item.
 
 When the request starts, a :class:`~ctx.RequestContext` is created and
 pushed, which creates and pushes an :class:`~ctx.AppContext` first if
@@ -99,10 +101,10 @@ these contexts are pushed, the :data:`current_app`, :data:`g`,
 :data:`request`, and :data:`session` proxies are available to the
 original thread handling the request.
 
-Because the contexts are stacks, other contexts may be pushed to change
-the proxies during a request. While this is not a common pattern, it
-can be used in advanced applications to, for example, do internal
-redirects or chain different applications together.
+Other contexts may be pushed to change the proxies during a request.
+While this is not a common pattern, it can be used in advanced
+applications to, for example, do internal redirects or chain different
+applications together.
 
 After the request is dispatched and a response is generated and sent,
 the request context is popped, which then pops the application context.
@@ -219,25 +221,6 @@ sent:
     :meth:`~Flask.teardown_request` functions are called.
 
 
-Context Preservation on Error
------------------------------
-
-At the end of a request, the request context is popped and all data
-associated with it is destroyed. If an error occurs during development,
-it is useful to delay destroying the data for debugging purposes.
-
-When the development server is running in development mode (the
-``FLASK_ENV`` environment variable is set to ``'development'``), the
-error and data will be preserved and shown in the interactive debugger.
-
-This behavior can be controlled with the
-:data:`PRESERVE_CONTEXT_ON_EXCEPTION` config. As described above, it
-defaults to ``True`` in the development environment.
-
-Do not enable :data:`PRESERVE_CONTEXT_ON_EXCEPTION` in production, as it
-will cause your application to leak memory on exceptions.
-
-
 .. _notes-on-proxies:
 
 Notes On Proxies
diff --git a/docs/server.rst b/docs/server.rst
index f674bcd7..d38aa120 100644
--- a/docs/server.rst
+++ b/docs/server.rst
@@ -3,9 +3,9 @@
 Development Server
 ==================
 
-Flask provides a ``run`` command to run the application with a
-development server. In development mode, this server provides an
-interactive debugger and will reload when code is changed.
+Flask provides a ``run`` command to run the application with a development server. In
+debug mode, this server provides an interactive debugger and will reload when code is
+changed.
 
 .. warning::
 
@@ -18,58 +18,18 @@ interactive debugger and will reload when code is changed.
 Command Line
 ------------
 
-The ``flask run`` command line script is the recommended way to run the
-development server. It requires setting the ``FLASK_APP`` environment
-variable to point to your application, and ``FLASK_ENV=development`` to
-fully enable development mode.
+The ``flask run`` CLI command is the recommended way to run the development server. Use
+the ``--app`` option to point to your application, and the ``--debug`` option to enable
+debug mode.
 
-.. tabs::
-
-   .. group-tab:: Bash
-
-      .. code-block:: text
-
-         $ export FLASK_APP=hello
-         $ export FLASK_ENV=development
-         $ flask run
-
-   .. group-tab:: Fish
-
-      .. code-block:: text
-
-         $ set -x FLASK_APP hello
-         $ export FLASK_ENV=development
-         $ flask run
-
-   .. group-tab:: CMD
-
-      .. code-block:: text
-
-         > set FLASK_APP=hello
-         > set FLASK_ENV=development
-         > flask run
-
-   .. group-tab:: Powershell
-
-      .. code-block:: text
-
-         > $env:FLASK_APP = "hello"
-         > $env:FLASK_ENV = "development"
-         > flask run
-
-This enables the development environment, including the interactive
-debugger and reloader, and then starts the server on
-http://localhost:5000/. Use ``flask run --help`` to see the available
-options, and  :doc:`/cli` for detailed instructions about configuring
-and using the CLI.
+.. code-block:: text
 
-.. note::
+    $ flask --app hello run --debug
 
-    Prior to Flask 1.0 the ``FLASK_ENV`` environment variable was not
-    supported and you needed to enable debug mode by exporting
-    ``FLASK_DEBUG=1``. This can still be used to control debug mode, but
-    you should prefer setting the development environment as shown
-    above.
+This enables debug mode, including the interactive debugger and reloader, and then
+starts the server on http://localhost:5000/. Use ``flask run --help`` to see the
+available options, and :doc:`/cli` for detailed instructions about configuring and using
+the CLI.
 
 
 .. _address-already-in-use:
@@ -120,40 +80,30 @@ macOS Monterey and later automatically starts a service that uses port
 disable "AirPlay Receiver".
 
 
-Lazy or Eager Loading
-~~~~~~~~~~~~~~~~~~~~~
+Deferred Errors on Reload
+~~~~~~~~~~~~~~~~~~~~~~~~~
 
 When using the ``flask run`` command with the reloader, the server will
 continue to run even if you introduce syntax errors or other
 initialization errors into the code. Accessing the site will show the
 interactive debugger for the error, rather than crashing the server.
-This feature is called "lazy loading".
 
 If a syntax error is already present when calling ``flask run``, it will
 fail immediately and show the traceback rather than waiting until the
 site is accessed. This is intended to make errors more visible initially
 while still allowing the server to handle errors on reload.
 
-To override this behavior and always fail immediately, even on reload,
-pass the ``--eager-loading`` option. To always keep the server running,
-even on the initial call, pass ``--lazy-loading``.
-
 
 In Code
 -------
 
-As an alternative to the ``flask run`` command, the development server
-can also be started from Python with the :meth:`Flask.run` method. This
-method takes arguments similar to the CLI options to control the server.
-The main difference from the CLI command is that the server will crash
-if there are errors when reloading.
-
-``debug=True`` can be passed to enable the debugger and reloader, but
-the ``FLASK_ENV=development`` environment variable is still required to
-fully enable development mode.
+The development server can also be started from Python with the :meth:`Flask.run`
+method. This method takes arguments similar to the CLI options to control the server.
+The main difference from the CLI command is that the server will crash if there are
+errors when reloading. ``debug=True`` can be passed to enable debug mode.
 
-Place the call in a main block, otherwise it will interfere when trying
-to import and run the application with a production server later.
+Place the call in a main block, otherwise it will interfere when trying to import and
+run the application with a production server later.
 
 .. code-block:: python
 
diff --git a/docs/templating.rst b/docs/templating.rst
index dcc757c3..f497de73 100644
--- a/docs/templating.rst
+++ b/docs/templating.rst
@@ -18,7 +18,7 @@ Jinja Setup
 Unless customized, Jinja2 is configured by Flask as follows:
 
 -   autoescaping is enabled for all templates ending in ``.html``,
-    ``.htm``, ``.xml`` as well as ``.xhtml`` when using
+    ``.htm``, ``.xml``, ``.xhtml``, as well as ``.svg`` when using
     :func:`~flask.templating.render_template`.
 -   autoescaping is enabled for all strings when using
     :func:`~flask.templating.render_template_string`.
@@ -201,3 +201,29 @@ templates::
 You could also build `format_price` as a template filter (see
 :ref:`registering-filters`), but this demonstrates how to pass functions in a
 context processor.
+
+Streaming
+---------
+
+It can be useful to not render the whole template as one complete
+string, instead render it as a stream, yielding smaller incremental
+strings. This can be used for streaming HTML in chunks to speed up
+initial page load, or to save memory when rendering a very large
+template.
+
+The Jinja2 template engine supports rendering a template piece
+by piece, returning an iterator of strings. Flask provides the
+:func:`~flask.stream_template` and :func:`~flask.stream_template_string`
+functions to make this easier to use.
+
+.. code-block:: python
+
+    from flask import stream_template
+
+    @app.get("/timeline")
+    def timeline():
+        return stream_template("timeline.html")
+
+These functions automatically apply the
+:func:`~flask.stream_with_context` wrapper if a request is active, so
+that it remains available in the template.
diff --git a/docs/testing.rst b/docs/testing.rst
index 6f9d6ee1..8545bd39 100644
--- a/docs/testing.rst
+++ b/docs/testing.rst
@@ -92,7 +92,7 @@ The ``client`` has methods that match the common HTTP request methods,
 such as ``client.get()`` and ``client.post()``. They take many arguments
 for building the request; you can find the full documentation in
 :class:`~werkzeug.test.EnvironBuilder`. Typically you'll use ``path``,
-``query``, ``headers``, and ``data`` or ``json``.
+``query_string``, ``headers``, and ``data`` or ``json``.
 
 To make a request, call the method the request should use with the path
 to the route to test. A :class:`~werkzeug.test.TestResponse` is returned
@@ -108,9 +108,9 @@ provides ``response.text``, or use ``response.get_data(as_text=True)``.
         assert b"<h2>Hello, World!</h2>" in response.data
 
 
-Pass a dict ``query={"key": "value", ...}`` to set arguments in the
-query string (after the ``?`` in the URL). Pass a dict ``headers={}``
-to set request headers.
+Pass a dict ``query_string={"key": "value", ...}`` to set arguments in
+the query string (after the ``?`` in the URL). Pass a dict
+``headers={}`` to set request headers.
 
 To send a request body in a POST or PUT request, pass a value to
 ``data``. If raw bytes are passed, that exact body is used. Usually,
diff --git a/docs/tutorial/database.rst b/docs/tutorial/database.rst
index b094909e..934f6008 100644
--- a/docs/tutorial/database.rst
+++ b/docs/tutorial/database.rst
@@ -40,7 +40,6 @@ response is sent.
 
     import click
     from flask import current_app, g
-    from flask.cli import with_appcontext
 
 
     def get_db():
@@ -128,7 +127,6 @@ Add the Python functions that will run these SQL commands to the
 
 
     @click.command('init-db')
-    @with_appcontext
     def init_db_command():
         """Clear the existing data and create new tables."""
         init_db()
@@ -196,15 +194,13 @@ previous page.
     If you're still running the server from the previous page, you can
     either stop the server, or run this command in a new terminal. If
     you use a new terminal, remember to change to your project directory
-    and activate the env as described in :doc:`/installation`. You'll
-    also need to set ``FLASK_APP`` and ``FLASK_ENV`` as shown on the
-    previous page.
+    and activate the env as described in :doc:`/installation`.
 
 Run the ``init-db`` command:
 
 .. code-block:: none
 
-    $ flask init-db
+    $ flask --app flaskr init-db
     Initialized the database.
 
 There will now be a ``flaskr.sqlite`` file in the ``instance`` folder in
diff --git a/docs/tutorial/deploy.rst b/docs/tutorial/deploy.rst
index 26940240..436ed5e8 100644
--- a/docs/tutorial/deploy.rst
+++ b/docs/tutorial/deploy.rst
@@ -48,35 +48,9 @@ Pip will install your project along with its dependencies.
 Since this is a different machine, you need to run ``init-db`` again to
 create the database in the instance folder.
 
-.. tabs::
+    .. code-block:: text
 
-   .. group-tab:: Bash
-
-      .. code-block:: text
-
-         $ export FLASK_APP=flaskr
-         $ flask init-db
-
-   .. group-tab:: Fish
-
-      .. code-block:: text
-
-         $ set -x FLASK_APP flaskr
-         $ flask init-db
-
-   .. group-tab:: CMD
-
-      .. code-block:: text
-
-         > set FLASK_APP=flaskr
-         > flask init-db
-
-   .. group-tab:: Powershell
-
-      .. code-block:: text
-
-         > $env:FLASK_APP = "flaskr"
-         > flask init-db
+        $ flask --app flaskr init-db
 
 When Flask detects that it's installed (not in editable mode), it uses
 a different directory for the instance folder. You can find it at
@@ -127,7 +101,7 @@ first install it in the virtual environment:
     $ pip install waitress
 
 You need to tell Waitress about your application, but it doesn't use
-``FLASK_APP`` like ``flask run`` does. You need to tell it to import and
+``--app`` like ``flask run`` does. You need to tell it to import and
 call the application factory to get an application object.
 
 .. code-block:: none
diff --git a/docs/tutorial/factory.rst b/docs/tutorial/factory.rst
index 73081874..39febd13 100644
--- a/docs/tutorial/factory.rst
+++ b/docs/tutorial/factory.rst
@@ -127,59 +127,28 @@ Run The Application
 
 Now you can run your application using the ``flask`` command. From the
 terminal, tell Flask where to find your application, then run it in
-development mode. Remember, you should still be in the top-level
+debug mode. Remember, you should still be in the top-level
 ``flask-tutorial`` directory, not the ``flaskr`` package.
 
-Development mode shows an interactive debugger whenever a page raises an
+Debug mode shows an interactive debugger whenever a page raises an
 exception, and restarts the server whenever you make changes to the
 code. You can leave it running and just reload the browser page as you
 follow the tutorial.
 
-.. tabs::
+.. code-block:: text
 
-   .. group-tab:: Bash
-
-      .. code-block:: text
-
-         $ export FLASK_APP=flaskr
-         $ export FLASK_ENV=development
-         $ flask run
-
-   .. group-tab:: Fish
-
-      .. code-block:: text
-
-         $ set -x FLASK_APP flaskr
-         $ set -x FLASK_ENV development
-         $ flask run
-
-   .. group-tab:: CMD
-
-      .. code-block:: text
-
-         > set FLASK_APP=flaskr
-         > set FLASK_ENV=development
-         > flask run
-
-   .. group-tab:: Powershell
-
-      .. code-block:: text
-
-         > $env:FLASK_APP = "flaskr"
-         > $env:FLASK_ENV = "development"
-         > flask run
+    $ flask --app flaskr run --debug
 
 You'll see output similar to this:
 
-.. code-block:: none
+.. code-block:: text
 
      * Serving Flask app "flaskr"
-     * Environment: development
      * Debug mode: on
      * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)
      * Restarting with stat
      * Debugger is active!
-     * Debugger PIN: 855-212-761
+     * Debugger PIN: nnn-nnn-nnn
 
 Visit http://127.0.0.1:5000/hello in a browser and you should see the
 "Hello, World!" message. Congratulations, you're now running your Flask
diff --git a/docs/tutorial/install.rst b/docs/tutorial/install.rst
index 3d7d7c60..f6820ebd 100644
--- a/docs/tutorial/install.rst
+++ b/docs/tutorial/install.rst
@@ -41,7 +41,6 @@ to it.
         version='1.0.0',
         packages=find_packages(),
         include_package_data=True,
-        zip_safe=False,
         install_requires=[
             'flask',
         ],
@@ -67,10 +66,12 @@ This tells Python to copy everything in the ``static`` and ``templates``
 directories, and the ``schema.sql`` file, but to exclude all bytecode
 files.
 
-See the `official packaging guide`_ for another explanation of the files
+See the official `Packaging tutorial <packaging tutorial_>`_ and
+`detailed guide <packaging guide_>`_ for more explanation of the files
 and options used.
 
-.. _official packaging guide: https://packaging.python.org/tutorials/packaging-projects/
+.. _packaging tutorial: https://packaging.python.org/tutorials/packaging-projects/
+.. _packaging guide: https://packaging.python.org/guides/distributing-packages-using-setuptools/
 
 
 Install the Project
@@ -107,7 +108,7 @@ You can observe that the project is now installed with ``pip list``.
     wheel          0.30.0
 
 Nothing changes from how you've been running your project so far.
-``FLASK_APP`` is still set to ``flaskr`` and ``flask run`` still runs
+``--app`` is still set to ``flaskr`` and ``flask run`` still runs
 the application, but you can call it from anywhere, not just the
 ``flask-tutorial`` directory.
 
diff --git a/docs/views.rst b/docs/views.rst
index 63d26c5c..68a3462a 100644
--- a/docs/views.rst
+++ b/docs/views.rst
@@ -1,235 +1,324 @@
-Pluggable Views
-===============
+Class-based Views
+=================
 
-.. versionadded:: 0.7
+.. currentmodule:: flask.views
 
-Flask 0.7 introduces pluggable views inspired by the generic views from
-Django which are based on classes instead of functions.  The main
-intention is that you can replace parts of the implementations and this
-way have customizable pluggable views.
+This page introduces using the :class:`View` and :class:`MethodView`
+classes to write class-based views.
+
+A class-based view is a class that acts as a view function. Because it
+is a class, different instances of the class can be created with
+different arguments, to change the behavior of the view. This is also
+known as generic, reusable, or pluggable views.
+
+An example of where this is useful is defining a class that creates an
+API based on the database model it is initialized with.
+
+For more complex API behavior and customization, look into the various
+API extensions for Flask.
 
-Basic Principle
----------------
 
-Consider you have a function that loads a list of objects from the
-database and renders into a template::
+Basic Reusable View
+-------------------
 
-    @app.route('/users/')
-    def show_users(page):
+Let's walk through an example converting a view function to a view
+class. We start with a view function that queries a list of users then
+renders a template to show the list.
+
+.. code-block:: python
+
+    @app.route("/users/")
+    def user_list():
         users = User.query.all()
-        return render_template('users.html', users=users)
+        return render_template("users.html", users=users)
 
-This is simple and flexible, but if you want to provide this view in a
-generic fashion that can be adapted to other models and templates as well
-you might want more flexibility.  This is where pluggable class-based
-views come into place.  As the first step to convert this into a class
-based view you would do this::
+This works for the user model, but let's say you also had more models
+that needed list pages. You'd need to write another view function for
+each model, even though the only thing that would change is the model
+and template name.
 
+Instead, you can write a :class:`View` subclass that will query a model
+and render a template. As the first step, we'll convert the view to a
+class without any customization.
 
-    from flask.views import View
+.. code-block:: python
 
-    class ShowUsers(View):
+    from flask.views import View
 
+    class UserList(View):
         def dispatch_request(self):
             users = User.query.all()
-            return render_template('users.html', objects=users)
+            return render_template("users.html", objects=users)
 
-    app.add_url_rule('/users/', view_func=ShowUsers.as_view('show_users'))
+    app.add_url_rule("/users/", view_func=UserList.as_view("user_list"))
 
-As you can see what you have to do is to create a subclass of
-:class:`flask.views.View` and implement
-:meth:`~flask.views.View.dispatch_request`.  Then we have to convert that
-class into an actual view function by using the
-:meth:`~flask.views.View.as_view` class method.  The string you pass to
-that function is the name of the endpoint that view will then have.  But
-this by itself is not helpful, so let's refactor the code a bit::
+The :meth:`View.dispatch_request` method is the equivalent of the view
+function. Calling :meth:`View.as_view` method will create a view
+function that can be registered on the app with its
+:meth:`~flask.Flask.add_url_rule` method. The first argument to
+``as_view`` is the name to use to refer to the view with
+:func:`~flask.url_for`.
 
+.. note::
 
-    from flask.views import View
+    You can't decorate the class with ``@app.route()`` the way you'd
+    do with a basic view function.
 
-    class ListView(View):
+Next, we need to be able to register the same view class for different
+models and templates, to make it more useful than the original function.
+The class will take two arguments, the model and template, and store
+them on ``self``. Then ``dispatch_request`` can reference these instead
+of hard-coded values.
 
-        def get_template_name(self):
-            raise NotImplementedError()
+.. code-block:: python
 
-        def render_template(self, context):
-            return render_template(self.get_template_name(), **context)
+    class ListView(View):
+        def __init__(self, model, template):
+            self.model = model
+            self.template = template
 
         def dispatch_request(self):
-            context = {'objects': self.get_objects()}
-            return self.render_template(context)
+            items = self.model.query.all()
+            return render_template(self.template, items=items)
+
+Remember, we create the view function with ``View.as_view()`` instead of
+creating the class directly. Any extra arguments passed to ``as_view``
+are then passed when creating the class. Now we can register the same
+view to handle multiple models.
+
+.. code-block:: python
 
-    class UserView(ListView):
+    app.add_url_rule(
+        "/users/",
+        view_func=ListView.as_view("user_list", User, "users.html"),
+    )
+    app.add_url_rule(
+        "/stories/",
+        view_func=ListView.as_view("story_list", Story, "stories.html"),
+    )
 
-        def get_template_name(self):
-            return 'users.html'
 
-        def get_objects(self):
-            return User.query.all()
+URL Variables
+-------------
+
+Any variables captured by the URL are passed as keyword arguments to the
+``dispatch_request`` method, as they would be for a regular view
+function.
+
+.. code-block:: python
+
+    class DetailView(View):
+        def __init__(self, model):
+            self.model = model
+            self.template = f"{model.__name__.lower()}/detail.html"
+
+        def dispatch_request(self, id)
+            item = self.model.query.get_or_404(id)
+            return render_template(self.template, item=item)
+
+    app.add_url_rule(
+        "/users/<int:id>",
+        view_func=DetailView.as_view("user_detail", User)
+    )
+
+
+View Lifetime and ``self``
+--------------------------
+
+By default, a new instance of the view class is created every time a
+request is handled. This means that it is safe to write other data to
+``self`` during the request, since the next request will not see it,
+unlike other forms of global state.
+
+However, if your view class needs to do a lot of complex initialization,
+doing it for every request is unnecessary and can be inefficient. To
+avoid this, set :attr:`View.init_every_request` to ``False``, which will
+only create one instance of the class and use it for every request. In
+this case, writing to ``self`` is not safe. If you need to store data
+during the request, use :data:`~flask.g` instead.
+
+In the ``ListView`` example, nothing writes to ``self`` during the
+request, so it is more efficient to create a single instance.
+
+.. code-block:: python
+
+    class ListView(View):
+        init_every_request = False
 
-This of course is not that helpful for such a small example, but it's good
-enough to explain the basic principle.  When you have a class-based view
-the question comes up what ``self`` points to.  The way this works is that
-whenever the request is dispatched a new instance of the class is created
-and the :meth:`~flask.views.View.dispatch_request` method is called with
-the parameters from the URL rule.  The class itself is instantiated with
-the parameters passed to the :meth:`~flask.views.View.as_view` function.
-For instance you can write a class like this::
+        def __init__(self, model, template):
+            self.model = model
+            self.template = template
 
-    class RenderTemplateView(View):
-        def __init__(self, template_name):
-            self.template_name = template_name
         def dispatch_request(self):
-            return render_template(self.template_name)
+            items = self.model.query.all()
+            return render_template(self.template, items=items)
 
-And then you can register it like this::
+Different instances will still be created each for each ``as_view``
+call, but not for each request to those views.
+
+
+View Decorators
+---------------
+
+The view class itself is not the view function. View decorators need to
+be applied to the view function returned by ``as_view``, not the class
+itself. Set :attr:`View.decorators` to a list of decorators to apply.
+
+.. code-block:: python
+
+    class UserList(View):
+        decorators = [cache(minutes=2), login_required]
+
+    app.add_url_rule('/users/', view_func=UserList.as_view())
+
+If you didn't set ``decorators``, you could apply them manually instead.
+This is equivalent to:
+
+.. code-block:: python
+
+    view = UserList.as_view("users_list")
+    view = cache(minutes=2)(view)
+    view = login_required(view)
+    app.add_url_rule('/users/', view_func=view)
+
+Keep in mind that order matters. If you're used to ``@decorator`` style,
+this is equivalent to:
+
+.. code-block:: python
+
+    @app.route("/users/")
+    @login_required
+    @cache(minutes=2)
+    def user_list():
+        ...
 
-    app.add_url_rule('/about', view_func=RenderTemplateView.as_view(
-        'about_page', template_name='about.html'))
 
 Method Hints
 ------------
 
-Pluggable views are attached to the application like a regular function by
-either using :func:`~flask.Flask.route` or better
-:meth:`~flask.Flask.add_url_rule`.  That however also means that you would
-have to provide the names of the HTTP methods the view supports when you
-attach this.  In order to move that information to the class you can
-provide a :attr:`~flask.views.View.methods` attribute that has this
-information::
+A common pattern is to register a view with ``methods=["GET", "POST"]``,
+then check ``request.method == "POST"`` to decide what to do. Setting
+:attr:`View.methods` is equivalent to passing the list of methods to
+``add_url_rule`` or ``route``.
+
+.. code-block:: python
 
     class MyView(View):
-        methods = ['GET', 'POST']
+        methods = ["GET", "POST"]
 
         def dispatch_request(self):
-            if request.method == 'POST':
+            if request.method == "POST":
                 ...
             ...
 
-    app.add_url_rule('/myview', view_func=MyView.as_view('myview'))
-
-Method Based Dispatching
-------------------------
+    app.add_url_rule('/my-view', view_func=MyView.as_view('my-view'))
 
-For RESTful APIs it's especially helpful to execute a different function
-for each HTTP method.  With the :class:`flask.views.MethodView` you can
-easily do that.  Each HTTP method maps to a method of the class with the
-same name (just in lowercase)::
+This is equivalent to the following, except further subclasses can
+inherit or change the methods.
 
-    from flask.views import MethodView
+.. code-block:: python
 
-    class UserAPI(MethodView):
+    app.add_url_rule(
+        "/my-view",
+        view_func=MyView.as_view("my-view"),
+        methods=["GET", "POST"],
+    )
 
-        def get(self):
-            users = User.query.all()
-            ...
 
-        def post(self):
-            user = User.from_form_data(request.form)
-            ...
+Method Dispatching and APIs
+---------------------------
 
-    app.add_url_rule('/users/', view_func=UserAPI.as_view('users'))
+For APIs it can be helpful to use a different function for each HTTP
+method. :class:`MethodView` extends the basic :class:`View` to dispatch
+to different methods of the class based on the request method. Each HTTP
+method maps to a method of the class with the same (lowercase) name.
 
-That way you also don't have to provide the
-:attr:`~flask.views.View.methods` attribute.  It's automatically set based
-on the methods defined in the class.
+:class:`MethodView` automatically sets :attr:`View.methods` based on the
+methods defined by the class. It even knows how to handle subclasses
+that override or define other methods.
 
-Decorating Views
-----------------
+We can make a generic ``ItemAPI`` class that provides get (detail),
+patch (edit), and delete methods for a given model. A ``GroupAPI`` can
+provide get (list) and post (create) methods.
 
-Since the view class itself is not the view function that is added to the
-routing system it does not make much sense to decorate the class itself.
-Instead you either have to decorate the return value of
-:meth:`~flask.views.View.as_view` by hand::
+.. code-block:: python
 
-    def user_required(f):
-        """Checks whether user is logged in or raises error 401."""
-        def decorator(*args, **kwargs):
-            if not g.user:
-                abort(401)
-            return f(*args, **kwargs)
-        return decorator
+    from flask.views import MethodView
 
-    view = user_required(UserAPI.as_view('users'))
-    app.add_url_rule('/users/', view_func=view)
+    class ItemAPI(MethodView):
+        init_every_request = False
 
-Starting with Flask 0.8 there is also an alternative way where you can
-specify a list of decorators to apply in the class declaration::
+        def __init__(self, model):
+            self.model
+            self.validator = generate_validator(model)
 
-    class UserAPI(MethodView):
-        decorators = [user_required]
+        def _get_item(self, id):
+            return self.model.query.get_or_404(id)
 
-Due to the implicit self from the caller's perspective you cannot use
-regular view decorators on the individual methods of the view however,
-keep this in mind.
+        def get(self, id):
+            item = self._get_item(id)
+            return jsonify(item.to_json())
 
-Method Views for APIs
----------------------
+        def patch(self, id):
+            item = self._get_item(id)
+            errors = self.validator.validate(item, request.json)
 
-Web APIs are often working very closely with HTTP verbs so it makes a lot
-of sense to implement such an API based on the
-:class:`~flask.views.MethodView`.  That said, you will notice that the API
-will require different URL rules that go to the same method view most of
-the time.  For instance consider that you are exposing a user object on
-the web:
+            if errors:
+                return jsonify(errors), 400
 
-=============== =============== ======================================
-URL             Method          Description
---------------- --------------- --------------------------------------
-``/users/``     ``GET``         Gives a list of all users
-``/users/``     ``POST``        Creates a new user
-``/users/<id>`` ``GET``         Shows a single user
-``/users/<id>`` ``PUT``         Updates a single user
-``/users/<id>`` ``DELETE``      Deletes a single user
-=============== =============== ======================================
+            item.update_from_json(request.json)
+            db.session.commit()
+            return jsonify(item.to_json())
 
-So how would you go about doing that with the
-:class:`~flask.views.MethodView`?  The trick is to take advantage of the
-fact that you can provide multiple rules to the same view.
+        def delete(self, id):
+            item = self._get_item(id)
+            db.session.delete(item)
+            db.session.commit()
+            return "", 204
 
-Let's assume for the moment the view would look like this::
+    class GroupAPI(MethodView):
+        init_every_request = False
 
-    class UserAPI(MethodView):
+        def __init__(self, model):
+            self.model = model
+            self.validator = generate_validator(model, create=True)
 
-        def get(self, user_id):
-            if user_id is None:
-                # return a list of users
-                pass
-            else:
-                # expose a single user
-                pass
+        def get(self):
+            items = self.model.query.all()
+            return jsonify([item.to_json() for item in items])
 
         def post(self):
-            # create a new user
-            pass
-
-        def delete(self, user_id):
-            # delete a single user
-            pass
-
-        def put(self, user_id):
-            # update a single user
-            pass
-
-So how do we hook this up with the routing system?  By adding two rules
-and explicitly mentioning the methods for each::
-
-    user_view = UserAPI.as_view('user_api')
-    app.add_url_rule('/users/', defaults={'user_id': None},
-                     view_func=user_view, methods=['GET',])
-    app.add_url_rule('/users/', view_func=user_view, methods=['POST',])
-    app.add_url_rule('/users/<int:user_id>', view_func=user_view,
-                     methods=['GET', 'PUT', 'DELETE'])
-
-If you have a lot of APIs that look similar you can refactor that
-registration code::
-
-    def register_api(view, endpoint, url, pk='id', pk_type='int'):
-        view_func = view.as_view(endpoint)
-        app.add_url_rule(url, defaults={pk: None},
-                         view_func=view_func, methods=['GET',])
-        app.add_url_rule(url, view_func=view_func, methods=['POST',])
-        app.add_url_rule(f'{url}<{pk_type}:{pk}>', view_func=view_func,
-                         methods=['GET', 'PUT', 'DELETE'])
-
-    register_api(UserAPI, 'user_api', '/users/', pk='user_id')
+            errors = self.validator.validate(request.json)
+
+            if errors:
+                return jsonify(errors), 400
+
+            db.session.add(self.model.from_json(request.json))
+            db.session.commit()
+            return jsonify(item.to_json())
+
+    def register_api(app, model, name):
+        item = ItemAPI.as_view(f"{name}-item", model)
+        group = GroupAPI.as_view(f"{name}-group", model)
+        app.add_url_rule(f"/{name}/<int:id>", view_func=item)
+        app.add_url_rule(f"/{name}/", view_func=group)
+
+    register_api(app, User, "users")
+    register_api(app, Story, "stories")
+
+This produces the following views, a standard REST API!
+
+================= ========== ===================
+URL               Method     Description
+----------------- ---------- -------------------
+``/users/``       ``GET``    List all users
+``/users/``       ``POST``   Create a new user
+``/users/<id>``   ``GET``    Show a single user
+``/users/<id>``   ``PATCH``  Update a user
+``/users/<id>``   ``DELETE`` Delete a user
+``/stories/``     ``GET``    List all stories
+``/stories/``     ``POST``   Create a new story
+``/stories/<id>`` ``GET``    Show a single story
+``/stories/<id>`` ``PATCH``  Update a story
+``/stories/<id>`` ``DELETE`` Delete a story
+================= ========== ===================
diff --git a/examples/celery/README.md b/examples/celery/README.md
new file mode 100644
index 00000000..038eb51e
--- /dev/null
+++ b/examples/celery/README.md
@@ -0,0 +1,27 @@
+Background Tasks with Celery
+============================
+
+This example shows how to configure Celery with Flask, how to set up an API for
+submitting tasks and polling results, and how to use that API with JavaScript. See
+[Flask's documentation about Celery](https://flask.palletsprojects.com/patterns/celery/).
+
+From this directory, create a virtualenv and install the application into it. Then run a
+Celery worker.
+
+```shell
+$ python3 -m venv .venv
+$ . ./.venv/bin/activate
+$ pip install -r requirements.txt && pip install -e .
+$ celery -A make_celery worker --loglevel INFO
+```
+
+In a separate terminal, activate the virtualenv and run the Flask development server.
+
+```shell
+$ . ./.venv/bin/activate
+$ flask -A task_app run --debug
+```
+
+Go to http://localhost:5000/ and use the forms to submit tasks. You can see the polling
+requests in the browser dev tools and the Flask logs. You can see the tasks submitting
+and completing in the Celery logs.
diff --git a/examples/celery/make_celery.py b/examples/celery/make_celery.py
new file mode 100644
index 00000000..f7d138e6
--- /dev/null
+++ b/examples/celery/make_celery.py
@@ -0,0 +1,4 @@
+from task_app import create_app
+
+flask_app = create_app()
+celery_app = flask_app.extensions["celery"]
diff --git a/examples/celery/pyproject.toml b/examples/celery/pyproject.toml
new file mode 100644
index 00000000..88ba6b96
--- /dev/null
+++ b/examples/celery/pyproject.toml
@@ -0,0 +1,11 @@
+[project]
+name = "flask-example-celery"
+version = "1.0.0"
+description = "Example Flask application with Celery background tasks."
+readme = "README.md"
+requires-python = ">=3.7"
+dependencies = ["flask>=2.2.2", "celery[redis]>=5.2.7"]
+
+[build-system]
+requires = ["setuptools"]
+build-backend = "setuptools.build_meta"
diff --git a/examples/celery/requirements.txt b/examples/celery/requirements.txt
new file mode 100644
index 00000000..b2834013
--- /dev/null
+++ b/examples/celery/requirements.txt
@@ -0,0 +1,56 @@
+#
+# This file is autogenerated by pip-compile with Python 3.10
+# by the following command:
+#
+#    pip-compile pyproject.toml
+#
+amqp==5.1.1
+    # via kombu
+async-timeout==4.0.2
+    # via redis
+billiard==3.6.4.0
+    # via celery
+celery[redis]==5.2.7
+    # via flask-example-celery (pyproject.toml)
+click==8.1.3
+    # via
+    #   celery
+    #   click-didyoumean
+    #   click-plugins
+    #   click-repl
+    #   flask
+click-didyoumean==0.3.0
+    # via celery
+click-plugins==1.1.1
+    # via celery
+click-repl==0.2.0
+    # via celery
+flask==2.2.2
+    # via flask-example-celery (pyproject.toml)
+itsdangerous==2.1.2
+    # via flask
+jinja2==3.1.2
+    # via flask
+kombu==5.2.4
+    # via celery
+markupsafe==2.1.2
+    # via
+    #   jinja2
+    #   werkzeug
+prompt-toolkit==3.0.36
+    # via click-repl
+pytz==2022.7.1
+    # via celery
+redis==4.5.1
+    # via celery
+six==1.16.0
+    # via click-repl
+vine==5.0.0
+    # via
+    #   amqp
+    #   celery
+    #   kombu
+wcwidth==0.2.6
+    # via prompt-toolkit
+werkzeug==2.2.2
+    # via flask
diff --git a/examples/celery/src/task_app/__init__.py b/examples/celery/src/task_app/__init__.py
new file mode 100644
index 00000000..dafff8aa
--- /dev/null
+++ b/examples/celery/src/task_app/__init__.py
@@ -0,0 +1,39 @@
+from celery import Celery
+from celery import Task
+from flask import Flask
+from flask import render_template
+
+
+def create_app() -> Flask:
+    app = Flask(__name__)
+    app.config.from_mapping(
+        CELERY=dict(
+            broker_url="redis://localhost",
+            result_backend="redis://localhost",
+            task_ignore_result=True,
+        ),
+    )
+    app.config.from_prefixed_env()
+    celery_init_app(app)
+
+    @app.route("/")
+    def index() -> str:
+        return render_template("index.html")
+
+    from . import views
+
+    app.register_blueprint(views.bp)
+    return app
+
+
+def celery_init_app(app: Flask) -> Celery:
+    class FlaskTask(Task):
+        def __call__(self, *args: object, **kwargs: object) -> object:
+            with app.app_context():
+                return self.run(*args, **kwargs)
+
+    celery_app = Celery(app.name, task_cls=FlaskTask)
+    celery_app.config_from_object(app.config["CELERY"])
+    celery_app.set_default()
+    app.extensions["celery"] = celery_app
+    return celery_app
diff --git a/examples/celery/src/task_app/tasks.py b/examples/celery/src/task_app/tasks.py
new file mode 100644
index 00000000..b6b3595d
--- /dev/null
+++ b/examples/celery/src/task_app/tasks.py
@@ -0,0 +1,23 @@
+import time
+
+from celery import shared_task
+from celery import Task
+
+
+@shared_task(ignore_result=False)
+def add(a: int, b: int) -> int:
+    return a + b
+
+
+@shared_task()
+def block() -> None:
+    time.sleep(5)
+
+
+@shared_task(bind=True, ignore_result=False)
+def process(self: Task, total: int) -> object:
+    for i in range(total):
+        self.update_state(state="PROGRESS", meta={"current": i + 1, "total": total})
+        time.sleep(1)
+
+    return {"current": total, "total": total}
diff --git a/examples/celery/src/task_app/templates/index.html b/examples/celery/src/task_app/templates/index.html
new file mode 100644
index 00000000..4e1145cb
--- /dev/null
+++ b/examples/celery/src/task_app/templates/index.html
@@ -0,0 +1,108 @@
+<!doctype html>
+<html>
+<head>
+  <meta charset=UTF-8>
+  <title>Celery Example</title>
+</head>
+<body>
+<h2>Celery Example</h2>
+Execute background tasks with Celery. Submits tasks and shows results using JavaScript.
+
+<hr>
+<h4>Add</h4>
+<p>Start a task to add two numbers, then poll for the result.
+<form id=add method=post action="{{ url_for("tasks.add") }}">
+  <label>A <input type=number name=a value=4></label><br>
+  <label>B <input type=number name=b value=2></label><br>
+  <input type=submit>
+</form>
+<p>Result: <span id=add-result></span></p>
+
+<hr>
+<h4>Block</h4>
+<p>Start a task that takes 5 seconds. However, the response will return immediately.
+<form id=block method=post action="{{ url_for("tasks.block") }}">
+  <input type=submit>
+</form>
+<p id=block-result></p>
+
+<hr>
+<h4>Process</h4>
+<p>Start a task that counts, waiting one second each time, showing progress.
+<form id=process method=post action="{{ url_for("tasks.process") }}">
+  <label>Total <input type=number name=total value="10"></label><br>
+  <input type=submit>
+</form>
+<p id=process-result></p>
+
+<script>
+  const taskForm = (formName, doPoll, report) => {
+    document.forms[formName].addEventListener("submit", (event) => {
+      event.preventDefault()
+      fetch(event.target.action, {
+        method: "POST",
+        body: new FormData(event.target)
+      })
+        .then(response => response.json())
+        .then(data => {
+          report(null)
+
+          const poll = () => {
+            fetch(`/tasks/result/${data["result_id"]}`)
+              .then(response => response.json())
+              .then(data => {
+                report(data)
+
+                if (!data["ready"]) {
+                  setTimeout(poll, 500)
+                } else if (!data["successful"]) {
+                  console.error(formName, data)
+                }
+              })
+          }
+
+          if (doPoll) {
+            poll()
+          }
+        })
+    })
+  }
+
+  taskForm("add", true, data => {
+    const el = document.getElementById("add-result")
+
+    if (data === null) {
+      el.innerText = "submitted"
+    } else if (!data["ready"]) {
+      el.innerText = "waiting"
+    } else if (!data["successful"]) {
+      el.innerText = "error, check console"
+    } else {
+      el.innerText = data["value"]
+    }
+  })
+
+  taskForm("block", false, data => {
+    document.getElementById("block-result").innerText = (
+      "request finished, check celery log to see task finish in 5 seconds"
+    )
+  })
+
+  taskForm("process", true, data => {
+    const el = document.getElementById("process-result")
+
+    if (data === null) {
+      el.innerText = "submitted"
+    } else if (!data["ready"]) {
+      el.innerText = `${data["value"]["current"]} / ${data["value"]["total"]}`
+    } else if (!data["successful"]) {
+      el.innerText = "error, check console"
+    } else {
+      el.innerText = " done"
+    }
+    console.log(data)
+  })
+
+</script>
+</body>
+</html>
diff --git a/examples/celery/src/task_app/views.py b/examples/celery/src/task_app/views.py
new file mode 100644
index 00000000..99cf92dc
--- /dev/null
+++ b/examples/celery/src/task_app/views.py
@@ -0,0 +1,38 @@
+from celery.result import AsyncResult
+from flask import Blueprint
+from flask import request
+
+from . import tasks
+
+bp = Blueprint("tasks", __name__, url_prefix="/tasks")
+
+
+@bp.get("/result/<id>")
+def result(id: str) -> dict[str, object]:
+    result = AsyncResult(id)
+    ready = result.ready()
+    return {
+        "ready": ready,
+        "successful": result.successful() if ready else None,
+        "value": result.get() if ready else result.result,
+    }
+
+
+@bp.post("/add")
+def add() -> dict[str, object]:
+    a = request.form.get("a", type=int)
+    b = request.form.get("b", type=int)
+    result = tasks.add.delay(a, b)
+    return {"result_id": result.id}
+
+
+@bp.post("/block")
+def block() -> dict[str, object]:
+    result = tasks.block.delay()
+    return {"result_id": result.id}
+
+
+@bp.post("/process")
+def process() -> dict[str, object]:
+    result = tasks.process.delay(total=request.form.get("total", type=int))
+    return {"result_id": result.id}
diff --git a/examples/javascript/README.rst b/examples/javascript/README.rst
index b25bdb4e..23c7ce43 100644
--- a/examples/javascript/README.rst
+++ b/examples/javascript/README.rst
@@ -3,15 +3,15 @@ JavaScript Ajax Example
 
 Demonstrates how to post form data and process a JSON response using
 JavaScript. This allows making requests without navigating away from the
-page. Demonstrates using |XMLHttpRequest|_, |fetch|_, and
-|jQuery.ajax|_. See the `Flask docs`_ about jQuery and Ajax.
-
-.. |XMLHttpRequest| replace:: ``XMLHttpRequest``
-.. _XMLHttpRequest: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest
+page. Demonstrates using |fetch|_, |XMLHttpRequest|_,  and
+|jQuery.ajax|_. See the `Flask docs`_ about JavaScript and Ajax.
 
 .. |fetch| replace:: ``fetch``
 .. _fetch: https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch
 
+.. |XMLHttpRequest| replace:: ``XMLHttpRequest``
+.. _XMLHttpRequest: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest
+
 .. |jQuery.ajax| replace:: ``jQuery.ajax``
 .. _jQuery.ajax: https://api.jquery.com/jQuery.ajax/
 
@@ -21,7 +21,7 @@ page. Demonstrates using |XMLHttpRequest|_, |fetch|_, and
 Install
 -------
 
-::
+.. code-block:: text
 
     $ python3 -m venv venv
     $ . venv/bin/activate
@@ -31,10 +31,9 @@ Install
 Run
 ---
 
-::
+.. code-block:: text
 
-    $ export FLASK_APP=js_example
-    $ flask run
+    $ flask --app js_example run
 
 Open http://127.0.0.1:5000 in a browser.
 
@@ -42,7 +41,7 @@ Open http://127.0.0.1:5000 in a browser.
 Test
 ----
 
-::
+.. code-block:: text
 
     $ pip install -e '.[test]'
     $ coverage run -m pytest
diff --git a/examples/javascript/js_example/__init__.py b/examples/javascript/js_example/__init__.py
index 068b2d98..0ec3ca21 100644
--- a/examples/javascript/js_example/__init__.py
+++ b/examples/javascript/js_example/__init__.py
@@ -2,4 +2,4 @@ from flask import Flask
 
 app = Flask(__name__)
 
-from js_example import views  # noqa: F401
+from js_example import views  # noqa: E402, F401
diff --git a/examples/javascript/js_example/templates/base.html b/examples/javascript/js_example/templates/base.html
index 50ce0e9c..a4d35bd7 100644
--- a/examples/javascript/js_example/templates/base.html
+++ b/examples/javascript/js_example/templates/base.html
@@ -1,7 +1,7 @@
 <!doctype html>
 <title>JavaScript Example</title>
-<link rel="stylesheet" href="https://unpkg.com/sakura.css@1.0.0/css/normalize.css">
-<link rel="stylesheet" href="https://unpkg.com/sakura.css@1.0.0/css/sakura-earthly.css">
+<link rel="stylesheet" href="https://unpkg.com/normalize.css@8.0.1/normalize.css">
+<link rel="stylesheet" href="https://unpkg.com/sakura.css@1.3.1/css/sakura.css">
 <style>
   ul { margin: 0; padding: 0; display: flex; list-style-type: none; }
   li > * { padding: 1em; }
@@ -13,10 +13,10 @@
 </style>
 <ul>
   <li><span>Type:</span>
-  <li class="{% if js == 'plain' %}active{% endif %}">
-    <a href="{{ url_for('index', js='plain') }}">Plain</a>
   <li class="{% if js == 'fetch' %}active{% endif %}">
     <a href="{{ url_for('index', js='fetch') }}">Fetch</a>
+  <li class="{% if js == 'xhr' %}active{% endif %}">
+    <a href="{{ url_for('index', js='xhr') }}">XHR</a>
   <li class="{% if js == 'jquery' %}active{% endif %}">
     <a href="{{ url_for('index', js='jquery') }}">jQuery</a>
 </ul>
diff --git a/examples/javascript/js_example/templates/fetch.html b/examples/javascript/js_example/templates/fetch.html
index 780ecec5..e2944b85 100644
--- a/examples/javascript/js_example/templates/fetch.html
+++ b/examples/javascript/js_example/templates/fetch.html
@@ -2,14 +2,11 @@
 
 {% block intro %}
   <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch"><code>fetch</code></a>
-  is the <em>new</em> plain JavaScript way to make requests. It's
-  supported in all modern browsers except IE, which requires a
-  <a href="https://github.com/github/fetch">polyfill</a>.
+  is the <em>modern</em> plain JavaScript way to make requests. It's
+  supported in all modern browsers.
 {% endblock %}
 
 {% block script %}
-  <script src="https://unpkg.com/promise-polyfill@7.1.2/dist/polyfill.min.js"></script>
-  <script src="https://unpkg.com/whatwg-fetch@2.0.4/fetch.js"></script>
   <script>
     function addSubmit(ev) {
       ev.preventDefault();
diff --git a/examples/javascript/js_example/templates/plain.html b/examples/javascript/js_example/templates/xhr.html
similarity index 79%
rename from examples/javascript/js_example/templates/plain.html
rename to examples/javascript/js_example/templates/xhr.html
index 59a7dd95..1672d4d6 100644
--- a/examples/javascript/js_example/templates/plain.html
+++ b/examples/javascript/js_example/templates/xhr.html
@@ -2,8 +2,9 @@
 
 {% block intro %}
   <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a>
-  is the plain JavaScript way to make requests. It's natively supported
-  by all browsers.
+  is the original JavaScript way to make requests. It's natively supported
+  by all browsers, but has been superseded by
+  <a href="{{ url_for("index", js="fetch") }}"><code>fetch</code></a>.
 {% endblock %}
 
 {% block script %}
diff --git a/examples/javascript/js_example/views.py b/examples/javascript/js_example/views.py
index 6c601a90..0d4b6561 100644
--- a/examples/javascript/js_example/views.py
+++ b/examples/javascript/js_example/views.py
@@ -5,8 +5,8 @@ from flask import request
 from js_example import app
 
 
-@app.route("/", defaults={"js": "plain"})
-@app.route("/<any(plain, jquery, fetch):js>")
+@app.route("/", defaults={"js": "fetch"})
+@app.route("/<any(xhr, jquery, fetch):js>")
 def index(js):
     return render_template(f"{js}.html", js=js)
 
diff --git a/examples/javascript/setup.cfg b/examples/javascript/setup.cfg
index c4a3efad..f509ddfe 100644
--- a/examples/javascript/setup.cfg
+++ b/examples/javascript/setup.cfg
@@ -1,6 +1,6 @@
 [metadata]
 name = js_example
-version = 1.0.0
+version = 1.1.0
 url = https://flask.palletsprojects.com/patterns/jquery/
 license = BSD-3-Clause
 maintainer = Pallets
diff --git a/examples/javascript/tests/test_js_example.py b/examples/javascript/tests/test_js_example.py
index aa0215f1..d155ad5c 100644
--- a/examples/javascript/tests/test_js_example.py
+++ b/examples/javascript/tests/test_js_example.py
@@ -5,8 +5,8 @@ from flask import template_rendered
 @pytest.mark.parametrize(
     ("path", "template_name"),
     (
-        ("/", "plain.html"),
-        ("/plain", "plain.html"),
+        ("/", "xhr.html"),
+        ("/plain", "xhr.html"),
         ("/fetch", "fetch.html"),
         ("/jquery", "jquery.html"),
     ),
diff --git a/examples/tutorial/README.rst b/examples/tutorial/README.rst
index 41f3f6ba..1c745078 100644
--- a/examples/tutorial/README.rst
+++ b/examples/tutorial/README.rst
@@ -45,19 +45,10 @@ installing Flaskr::
 Run
 ---
 
-::
-
-    $ export FLASK_APP=flaskr
-    $ export FLASK_ENV=development
-    $ flask init-db
-    $ flask run
-
-Or on Windows cmd::
+.. code-block:: text
 
-    > set FLASK_APP=flaskr
-    > set FLASK_ENV=development
-    > flask init-db
-    > flask run
+    $ flask --app flaskr init-db
+    $ flask --app flaskr run --debug
 
 Open http://127.0.0.1:5000 in a browser.
 
diff --git a/examples/tutorial/flaskr/db.py b/examples/tutorial/flaskr/db.py
index f1e2dc30..acaa4ae3 100644
--- a/examples/tutorial/flaskr/db.py
+++ b/examples/tutorial/flaskr/db.py
@@ -3,7 +3,6 @@ import sqlite3
 import click
 from flask import current_app
 from flask import g
-from flask.cli import with_appcontext
 
 
 def get_db():
@@ -39,7 +38,6 @@ def init_db():
 
 
 @click.command("init-db")
-@with_appcontext
 def init_db_command():
     """Clear existing data and create new tables."""
     init_db()
diff --git a/requirements/build.in b/requirements/build.in
new file mode 100644
index 00000000..378eac25
--- /dev/null
+++ b/requirements/build.in
@@ -0,0 +1 @@
+build
diff --git a/requirements/build.txt b/requirements/build.txt
new file mode 100644
index 00000000..a735b3d0
--- /dev/null
+++ b/requirements/build.txt
@@ -0,0 +1,17 @@
+# SHA1:80754af91bfb6d1073585b046fe0a474ce868509
+#
+# This file is autogenerated by pip-compile-multi
+# To update, run:
+#
+#    pip-compile-multi
+#
+build==0.9.0
+    # via -r requirements/build.in
+packaging==23.0
+    # via build
+pep517==0.13.0
+    # via build
+tomli==2.0.1
+    # via
+    #   build
+    #   pep517
diff --git a/requirements/dev.txt b/requirements/dev.txt
index 36999074..41b2619c 100644
--- a/requirements/dev.txt
+++ b/requirements/dev.txt
@@ -8,53 +8,57 @@
 -r docs.txt
 -r tests.txt
 -r typing.txt
+build==0.9.0
+    # via pip-tools
+cachetools==5.2.0
+    # via tox
 cfgv==3.3.1
     # via pre-commit
-click==8.1.2
+chardet==5.1.0
+    # via tox
+click==8.1.3
     # via
     #   pip-compile-multi
     #   pip-tools
-distlib==0.3.4
+colorama==0.4.6
+    # via tox
+distlib==0.3.6
     # via virtualenv
-filelock==3.6.0
+filelock==3.8.2
     # via
     #   tox
     #   virtualenv
-greenlet==1.1.2 ; python_version < "3.11"
-    # via -r requirements/tests.in
-identify==2.5.0
+identify==2.5.11
     # via pre-commit
-nodeenv==1.6.0
+nodeenv==1.7.0
     # via pre-commit
-pep517==0.12.0
-    # via pip-tools
-pip-compile-multi==2.4.5
+pep517==0.13.0
+    # via build
+pip-compile-multi==2.6.1
     # via -r requirements/dev.in
-pip-tools==6.6.0
+pip-tools==6.12.1
     # via pip-compile-multi
-platformdirs==2.5.2
-    # via virtualenv
-pre-commit==2.18.1
-    # via -r requirements/dev.in
-pyyaml==6.0
-    # via pre-commit
-six==1.16.0
+platformdirs==2.6.0
     # via
     #   tox
     #   virtualenv
+pre-commit==2.20.0
+    # via -r requirements/dev.in
+pyproject-api==1.2.1
+    # via tox
+pyyaml==6.0
+    # via pre-commit
 toml==0.10.2
-    # via
-    #   pre-commit
-    #   tox
+    # via pre-commit
 toposort==1.7
     # via pip-compile-multi
-tox==3.25.0
+tox==4.0.16
     # via -r requirements/dev.in
-virtualenv==20.14.1
+virtualenv==20.17.1
     # via
     #   pre-commit
     #   tox
-wheel==0.37.1
+wheel==0.38.4
     # via pip-tools
 
 # The following packages are considered to be unsafe in a requirements file:
diff --git a/requirements/docs.in b/requirements/docs.in
index 3ee050af..3a389e2b 100644
--- a/requirements/docs.in
+++ b/requirements/docs.in
@@ -1,5 +1,7 @@
 Pallets-Sphinx-Themes
-Sphinx
+# sphinx 5 introduced error in references from werkzeug in docstrings
+Sphinx < 5
 sphinx-issues
 sphinxcontrib-log-cabinet
-sphinx-tabs
+# sphinx-tabs 3.4 requires docutils 0.18, sphinx < 5 requires < 0.18
+sphinx-tabs < 3.4
diff --git a/requirements/docs.txt b/requirements/docs.txt
index 963d81e9..b1e46bde 100644
--- a/requirements/docs.txt
+++ b/requirements/docs.txt
@@ -1,4 +1,4 @@
-# SHA1:34fd4ca6516e97c7348e6facdd9c4ebb68209d1c
+# SHA1:323f1c1134d78952ea63131c187303def63b56bd
 #
 # This file is autogenerated by pip-compile-multi
 # To update, run:
@@ -7,39 +7,37 @@
 #
 alabaster==0.7.12
     # via sphinx
-babel==2.10.1
+babel==2.11.0
     # via sphinx
-certifi==2021.10.8
+certifi==2022.12.7
     # via requests
-charset-normalizer==2.0.12
+charset-normalizer==2.1.1
     # via requests
 docutils==0.17.1
     # via
     #   sphinx
     #   sphinx-tabs
-idna==3.3
+idna==3.4
     # via requests
-imagesize==1.3.0
+imagesize==1.4.1
     # via sphinx
-jinja2==3.1.1
+jinja2==3.1.2
     # via sphinx
 markupsafe==2.1.1
     # via jinja2
-packaging==21.3
+packaging==22.0
     # via
     #   pallets-sphinx-themes
     #   sphinx
-pallets-sphinx-themes==2.0.2
+pallets-sphinx-themes==2.0.3
     # via -r requirements/docs.in
-pygments==2.12.0
+pygments==2.13.0
     # via
     #   sphinx
     #   sphinx-tabs
-pyparsing==3.0.8
-    # via packaging
-pytz==2022.1
+pytz==2022.7
     # via babel
-requests==2.27.1
+requests==2.28.1
     # via sphinx
 snowballstemmer==2.2.0
     # via sphinx
@@ -68,5 +66,5 @@ sphinxcontrib-qthelp==1.0.3
     # via sphinx
 sphinxcontrib-serializinghtml==1.1.5
     # via sphinx
-urllib3==1.26.9
+urllib3==1.26.13
     # via requests
diff --git a/requirements/tests-pallets-dev.in b/requirements/tests-pallets-dev.in
deleted file mode 100644
index dddbe48a..00000000
--- a/requirements/tests-pallets-dev.in
+++ /dev/null
@@ -1,5 +0,0 @@
-https://github.com/pallets/werkzeug/archive/refs/heads/main.tar.gz
-https://github.com/pallets/jinja/archive/refs/heads/main.tar.gz
-https://github.com/pallets/markupsafe/archive/refs/heads/main.tar.gz
-https://github.com/pallets/itsdangerous/archive/refs/heads/main.tar.gz
-https://github.com/pallets/click/archive/refs/heads/main.tar.gz
diff --git a/requirements/tests-pallets-dev.txt b/requirements/tests-pallets-dev.txt
deleted file mode 100644
index 35d6cadc..00000000
--- a/requirements/tests-pallets-dev.txt
+++ /dev/null
@@ -1,19 +0,0 @@
-# SHA1:692b640e7f835e536628f76de0afff1296524122
-#
-# This file is autogenerated by pip-compile-multi
-# To update, run:
-#
-#    pip-compile-multi
-#
-click @ https://github.com/pallets/click/archive/refs/heads/main.tar.gz
-    # via -r requirements/tests-pallets-dev.in
-itsdangerous @ https://github.com/pallets/itsdangerous/archive/refs/heads/main.tar.gz
-    # via -r requirements/tests-pallets-dev.in
-jinja2 @ https://github.com/pallets/jinja/archive/refs/heads/main.tar.gz
-    # via -r requirements/tests-pallets-dev.in
-markupsafe @ https://github.com/pallets/markupsafe/archive/refs/heads/main.tar.gz
-    # via
-    #   -r requirements/tests-pallets-dev.in
-    #   jinja2
-werkzeug @ https://github.com/pallets/werkzeug/archive/refs/heads/main.tar.gz
-    # via -r requirements/tests-pallets-dev.in
diff --git a/requirements/tests.txt b/requirements/tests.txt
index 7833cabd..aff42de2 100644
--- a/requirements/tests.txt
+++ b/requirements/tests.txt
@@ -5,27 +5,19 @@
 #
 #    pip-compile-multi
 #
-asgiref==3.5.0
+asgiref==3.6.0
     # via -r requirements/tests.in
-attrs==21.4.0
+attrs==22.2.0
     # via pytest
-blinker==1.4
-    # via -r requirements/tests.in
-greenlet==1.1.2 ; python_version < "3.11"
+blinker==1.5
     # via -r requirements/tests.in
 iniconfig==1.1.1
     # via pytest
-packaging==21.3
+packaging==22.0
     # via pytest
 pluggy==1.0.0
     # via pytest
-py==1.11.0
-    # via pytest
-pyparsing==3.0.8
-    # via packaging
-pytest==7.1.2
+pytest==7.2.0
     # via -r requirements/tests.in
-python-dotenv==0.20.0
+python-dotenv==0.21.0
     # via -r requirements/tests.in
-tomli==2.0.1
-    # via pytest
diff --git a/requirements/typing.txt b/requirements/typing.txt
index f1aa5284..ad8dd594 100644
--- a/requirements/typing.txt
+++ b/requirements/typing.txt
@@ -5,23 +5,21 @@
 #
 #    pip-compile-multi
 #
-cffi==1.15.0
+cffi==1.15.1
     # via cryptography
-cryptography==37.0.1
+cryptography==38.0.4
     # via -r requirements/typing.in
-mypy==0.950
+mypy==0.991
     # via -r requirements/typing.in
 mypy-extensions==0.4.3
     # via mypy
 pycparser==2.21
     # via cffi
-tomli==2.0.1
-    # via mypy
-types-contextvars==2.4.5
+types-contextvars==2.4.7
     # via -r requirements/typing.in
-types-dataclasses==0.6.5
+types-dataclasses==0.6.6
     # via -r requirements/typing.in
-types-setuptools==57.4.14
+types-setuptools==65.6.0.2
     # via -r requirements/typing.in
-typing-extensions==4.2.0
+typing-extensions==4.4.0
     # via mypy
diff --git a/setup.cfg b/setup.cfg
index 31a590a4..736bd50f 100644
--- a/setup.cfg
+++ b/setup.cfg
@@ -61,33 +61,8 @@ source =
     src
     */site-packages
 
-[flake8]
-# B = bugbear
-# E = pycodestyle errors
-# F = flake8 pyflakes
-# W = pycodestyle warnings
-# B9 = bugbear opinions
-# ISC = implicit str concat
-select = B, E, F, W, B9, ISC
-ignore =
-    # slice notation whitespace, invalid
-    E203
-    # import at top, too many circular import fixes
-    E402
-    # line length, handled by bugbear B950
-    E501
-    # bare except, handled by bugbear B001
-    E722
-    # bin op line break, invalid
-    W503
-# up to 88 allowed by bugbear B950
-max-line-length = 80
-per-file-ignores =
-    # __init__ exports names
-    src/flask/__init__.py: F401
-
 [mypy]
-files = src/flask
+files = src/flask, tests/typing
 python_version = 3.7
 show_error_codes = True
 allow_redefinition = True
@@ -116,3 +91,6 @@ ignore_missing_imports = True
 
 [mypy-cryptography.*]
 ignore_missing_imports = True
+
+[mypy-importlib_metadata]
+ignore_missing_imports = True
diff --git a/setup.py b/setup.py
index a28763b5..67175467 100644
--- a/setup.py
+++ b/setup.py
@@ -4,7 +4,7 @@ from setuptools import setup
 setup(
     name="Flask",
     install_requires=[
-        "Werkzeug >= 2.0",
+        "Werkzeug >= 2.2.2",
         "Jinja2 >= 3.0",
         "itsdangerous >= 2.0",
         "click >= 8.0",
diff --git a/src/flask/__init__.py b/src/flask/__init__.py
index f684f57a..463f55f2 100644
--- a/src/flask/__init__.py
+++ b/src/flask/__init__.py
@@ -1,7 +1,5 @@
 from markupsafe import escape
 from markupsafe import Markup
-from werkzeug.exceptions import abort as abort
-from werkzeug.utils import redirect as redirect
 
 from . import json as json
 from .app import Flask as Flask
@@ -13,16 +11,16 @@ from .ctx import after_this_request as after_this_request
 from .ctx import copy_current_request_context as copy_current_request_context
 from .ctx import has_app_context as has_app_context
 from .ctx import has_request_context as has_request_context
-from .globals import _app_ctx_stack as _app_ctx_stack
-from .globals import _request_ctx_stack as _request_ctx_stack
 from .globals import current_app as current_app
 from .globals import g as g
 from .globals import request as request
 from .globals import session as session
+from .helpers import abort as abort
 from .helpers import flash as flash
 from .helpers import get_flashed_messages as get_flashed_messages
 from .helpers import get_template_attribute as get_template_attribute
 from .helpers import make_response as make_response
+from .helpers import redirect as redirect
 from .helpers import send_file as send_file
 from .helpers import send_from_directory as send_from_directory
 from .helpers import stream_with_context as stream_with_context
@@ -41,5 +39,33 @@ from .signals import signals_available as signals_available
 from .signals import template_rendered as template_rendered
 from .templating import render_template as render_template
 from .templating import render_template_string as render_template_string
+from .templating import stream_template as stream_template
+from .templating import stream_template_string as stream_template_string
 
-__version__ = "2.1.2"
+__version__ = "2.2.3"
+
+
+def __getattr__(name):
+    if name == "_app_ctx_stack":
+        import warnings
+        from .globals import __app_ctx_stack
+
+        warnings.warn(
+            "'_app_ctx_stack' is deprecated and will be removed in Flask 2.3.",
+            DeprecationWarning,
+            stacklevel=2,
+        )
+        return __app_ctx_stack
+
+    if name == "_request_ctx_stack":
+        import warnings
+        from .globals import __request_ctx_stack
+
+        warnings.warn(
+            "'_request_ctx_stack' is deprecated and will be removed in Flask 2.3.",
+            DeprecationWarning,
+            stacklevel=2,
+        )
+        return __request_ctx_stack
+
+    raise AttributeError(name)
diff --git a/src/flask/app.py b/src/flask/app.py
index 348bc7f7..0ac4bbb5 100644
--- a/src/flask/app.py
+++ b/src/flask/app.py
@@ -1,17 +1,21 @@
 import functools
 import inspect
+import json
 import logging
 import os
 import sys
 import typing as t
 import weakref
+from collections.abc import Iterator as _abc_Iterator
 from datetime import timedelta
 from itertools import chain
 from threading import Lock
 from types import TracebackType
 
+import click
 from werkzeug.datastructures import Headers
 from werkzeug.datastructures import ImmutableDict
+from werkzeug.exceptions import Aborter
 from werkzeug.exceptions import BadRequest
 from werkzeug.exceptions import BadRequestKeyError
 from werkzeug.exceptions import HTTPException
@@ -22,27 +26,31 @@ from werkzeug.routing import MapAdapter
 from werkzeug.routing import RequestRedirect
 from werkzeug.routing import RoutingException
 from werkzeug.routing import Rule
+from werkzeug.serving import is_running_from_reloader
+from werkzeug.urls import url_quote
+from werkzeug.utils import redirect as _wz_redirect
 from werkzeug.wrappers import Response as BaseResponse
 
 from . import cli
-from . import json
+from . import typing as ft
 from .config import Config
 from .config import ConfigAttribute
 from .ctx import _AppCtxGlobals
 from .ctx import AppContext
 from .ctx import RequestContext
-from .globals import _request_ctx_stack
+from .globals import _cv_app
+from .globals import _cv_request
 from .globals import g
 from .globals import request
+from .globals import request_ctx
 from .globals import session
 from .helpers import _split_blueprint_path
 from .helpers import get_debug_flag
-from .helpers import get_env
 from .helpers import get_flashed_messages
 from .helpers import get_load_dotenv
 from .helpers import locked_cached_property
-from .helpers import url_for
-from .json import jsonify
+from .json.provider import DefaultJSONProvider
+from .json.provider import JSONProvider
 from .logging import create_logger
 from .scaffold import _endpoint_from_view_func
 from .scaffold import _sentinel
@@ -58,21 +66,25 @@ from .signals import request_started
 from .signals import request_tearing_down
 from .templating import DispatchingJinjaLoader
 from .templating import Environment
-from .typing import BeforeFirstRequestCallable
-from .typing import ResponseReturnValue
-from .typing import TeardownCallable
-from .typing import TemplateFilterCallable
-from .typing import TemplateGlobalCallable
-from .typing import TemplateTestCallable
 from .wrappers import Request
 from .wrappers import Response
 
-if t.TYPE_CHECKING:
+if t.TYPE_CHECKING:  # pragma: no cover
     import typing_extensions as te
     from .blueprints import Blueprint
     from .testing import FlaskClient
     from .testing import FlaskCliRunner
-    from .typing import ErrorHandlerCallable
+
+T_before_first_request = t.TypeVar(
+    "T_before_first_request", bound=ft.BeforeFirstRequestCallable
+)
+T_shell_context_processor = t.TypeVar(
+    "T_shell_context_processor", bound=ft.ShellContextProcessorCallable
+)
+T_teardown = t.TypeVar("T_teardown", bound=ft.TeardownCallable)
+T_template_filter = t.TypeVar("T_template_filter", bound=ft.TemplateFilterCallable)
+T_template_global = t.TypeVar("T_template_global", bound=ft.TemplateGlobalCallable)
+T_template_test = t.TypeVar("T_template_test", bound=ft.TemplateTestCallable)
 
 if sys.version_info >= (3, 8):
     iscoroutinefunction = inspect.iscoroutinefunction
@@ -88,7 +100,7 @@ else:
         return inspect.iscoroutinefunction(func)
 
 
-def _make_timedelta(value: t.Optional[timedelta]) -> t.Optional[timedelta]:
+def _make_timedelta(value: t.Union[timedelta, int, None]) -> t.Optional[timedelta]:
     if value is None or isinstance(value, timedelta):
         return value
 
@@ -200,6 +212,16 @@ class Flask(Scaffold):
     #: :class:`~flask.Response` for more information.
     response_class = Response
 
+    #: The class of the object assigned to :attr:`aborter`, created by
+    #: :meth:`create_aborter`. That object is called by
+    #: :func:`flask.abort` to raise HTTP errors, and can be
+    #: called directly as well.
+    #:
+    #: Defaults to :class:`werkzeug.exceptions.Aborter`.
+    #:
+    #: .. versionadded:: 2.2
+    aborter_class = Aborter
+
     #: The class that is used for the Jinja environment.
     #:
     #: .. versionadded:: 0.11
@@ -252,11 +274,35 @@ class Flask(Scaffold):
     #: :data:`SECRET_KEY` configuration key. Defaults to ``None``.
     secret_key = ConfigAttribute("SECRET_KEY")
 
-    #: The secure cookie uses this for the name of the session cookie.
-    #:
-    #: This attribute can also be configured from the config with the
-    #: ``SESSION_COOKIE_NAME`` configuration key.  Defaults to ``'session'``
-    session_cookie_name = ConfigAttribute("SESSION_COOKIE_NAME")
+    @property
+    def session_cookie_name(self) -> str:
+        """The name of the cookie set by the session interface.
+
+        .. deprecated:: 2.2
+            Will be removed in Flask 2.3. Use ``app.config["SESSION_COOKIE_NAME"]``
+            instead.
+        """
+        import warnings
+
+        warnings.warn(
+            "'session_cookie_name' is deprecated and will be removed in Flask 2.3. Use"
+            " 'SESSION_COOKIE_NAME' in 'app.config' instead.",
+            DeprecationWarning,
+            stacklevel=2,
+        )
+        return self.config["SESSION_COOKIE_NAME"]
+
+    @session_cookie_name.setter
+    def session_cookie_name(self, value: str) -> None:
+        import warnings
+
+        warnings.warn(
+            "'session_cookie_name' is deprecated and will be removed in Flask 2.3. Use"
+            " 'SESSION_COOKIE_NAME' in 'app.config' instead.",
+            DeprecationWarning,
+            stacklevel=2,
+        )
+        self.config["SESSION_COOKIE_NAME"] = value
 
     #: A :class:`~datetime.timedelta` which is used to set the expiration
     #: date of a permanent session.  The default is 31 days which makes a
@@ -269,39 +315,163 @@ class Flask(Scaffold):
         "PERMANENT_SESSION_LIFETIME", get_converter=_make_timedelta
     )
 
-    #: A :class:`~datetime.timedelta` or number of seconds which is used
-    #: as the default ``max_age`` for :func:`send_file`. The default is
-    #: ``None``, which tells the browser to use conditional requests
-    #: instead of a timed cache.
-    #:
-    #: Configured with the :data:`SEND_FILE_MAX_AGE_DEFAULT`
-    #: configuration key.
-    #:
-    #: .. versionchanged:: 2.0
-    #:     Defaults to ``None`` instead of 12 hours.
-    send_file_max_age_default = ConfigAttribute(
-        "SEND_FILE_MAX_AGE_DEFAULT", get_converter=_make_timedelta
-    )
+    @property
+    def send_file_max_age_default(self) -> t.Optional[timedelta]:
+        """The default value for ``max_age`` for :func:`~flask.send_file`. The default
+        is ``None``, which tells the browser to use conditional requests instead of a
+        timed cache.
 
-    #: Enable this if you want to use the X-Sendfile feature.  Keep in
-    #: mind that the server has to support this.  This only affects files
-    #: sent with the :func:`send_file` method.
-    #:
-    #: .. versionadded:: 0.2
-    #:
-    #: This attribute can also be configured from the config with the
-    #: ``USE_X_SENDFILE`` configuration key.  Defaults to ``False``.
-    use_x_sendfile = ConfigAttribute("USE_X_SENDFILE")
+        .. deprecated:: 2.2
+            Will be removed in Flask 2.3. Use
+            ``app.config["SEND_FILE_MAX_AGE_DEFAULT"]`` instead.
 
-    #: The JSON encoder class to use.  Defaults to :class:`~flask.json.JSONEncoder`.
-    #:
-    #: .. versionadded:: 0.10
-    json_encoder = json.JSONEncoder
+        .. versionchanged:: 2.0
+            Defaults to ``None`` instead of 12 hours.
+        """
+        import warnings
 
-    #: The JSON decoder class to use.  Defaults to :class:`~flask.json.JSONDecoder`.
-    #:
-    #: .. versionadded:: 0.10
-    json_decoder = json.JSONDecoder
+        warnings.warn(
+            "'send_file_max_age_default' is deprecated and will be removed in Flask"
+            " 2.3. Use 'SEND_FILE_MAX_AGE_DEFAULT' in 'app.config' instead.",
+            DeprecationWarning,
+            stacklevel=2,
+        )
+        return _make_timedelta(self.config["SEND_FILE_MAX_AGE_DEFAULT"])
+
+    @send_file_max_age_default.setter
+    def send_file_max_age_default(self, value: t.Union[int, timedelta, None]) -> None:
+        import warnings
+
+        warnings.warn(
+            "'send_file_max_age_default' is deprecated and will be removed in Flask"
+            " 2.3. Use 'SEND_FILE_MAX_AGE_DEFAULT' in 'app.config' instead.",
+            DeprecationWarning,
+            stacklevel=2,
+        )
+        self.config["SEND_FILE_MAX_AGE_DEFAULT"] = _make_timedelta(value)
+
+    @property
+    def use_x_sendfile(self) -> bool:
+        """Enable this to use the ``X-Sendfile`` feature, assuming the server supports
+        it, from :func:`~flask.send_file`.
+
+        .. deprecated:: 2.2
+            Will be removed in Flask 2.3. Use ``app.config["USE_X_SENDFILE"]`` instead.
+        """
+        import warnings
+
+        warnings.warn(
+            "'use_x_sendfile' is deprecated and will be removed in Flask 2.3. Use"
+            " 'USE_X_SENDFILE' in 'app.config' instead.",
+            DeprecationWarning,
+            stacklevel=2,
+        )
+        return self.config["USE_X_SENDFILE"]
+
+    @use_x_sendfile.setter
+    def use_x_sendfile(self, value: bool) -> None:
+        import warnings
+
+        warnings.warn(
+            "'use_x_sendfile' is deprecated and will be removed in Flask 2.3. Use"
+            " 'USE_X_SENDFILE' in 'app.config' instead.",
+            DeprecationWarning,
+            stacklevel=2,
+        )
+        self.config["USE_X_SENDFILE"] = value
+
+    _json_encoder: t.Union[t.Type[json.JSONEncoder], None] = None
+    _json_decoder: t.Union[t.Type[json.JSONDecoder], None] = None
+
+    @property  # type: ignore[override]
+    def json_encoder(self) -> t.Type[json.JSONEncoder]:
+        """The JSON encoder class to use. Defaults to
+        :class:`~flask.json.JSONEncoder`.
+
+        .. deprecated:: 2.2
+             Will be removed in Flask 2.3. Customize
+             :attr:`json_provider_class` instead.
+
+        .. versionadded:: 0.10
+        """
+        import warnings
+
+        warnings.warn(
+            "'app.json_encoder' is deprecated and will be removed in Flask 2.3."
+            " Customize 'app.json_provider_class' or 'app.json' instead.",
+            DeprecationWarning,
+            stacklevel=2,
+        )
+
+        if self._json_encoder is None:
+            from . import json
+
+            return json.JSONEncoder
+
+        return self._json_encoder
+
+    @json_encoder.setter
+    def json_encoder(self, value: t.Type[json.JSONEncoder]) -> None:
+        import warnings
+
+        warnings.warn(
+            "'app.json_encoder' is deprecated and will be removed in Flask 2.3."
+            " Customize 'app.json_provider_class' or 'app.json' instead.",
+            DeprecationWarning,
+            stacklevel=2,
+        )
+        self._json_encoder = value
+
+    @property  # type: ignore[override]
+    def json_decoder(self) -> t.Type[json.JSONDecoder]:
+        """The JSON decoder class to use. Defaults to
+        :class:`~flask.json.JSONDecoder`.
+
+        .. deprecated:: 2.2
+             Will be removed in Flask 2.3. Customize
+             :attr:`json_provider_class` instead.
+
+        .. versionadded:: 0.10
+        """
+        import warnings
+
+        warnings.warn(
+            "'app.json_decoder' is deprecated and will be removed in Flask 2.3."
+            " Customize 'app.json_provider_class' or 'app.json' instead.",
+            DeprecationWarning,
+            stacklevel=2,
+        )
+
+        if self._json_decoder is None:
+            from . import json
+
+            return json.JSONDecoder
+
+        return self._json_decoder
+
+    @json_decoder.setter
+    def json_decoder(self, value: t.Type[json.JSONDecoder]) -> None:
+        import warnings
+
+        warnings.warn(
+            "'app.json_decoder' is deprecated and will be removed in Flask 2.3."
+            " Customize 'app.json_provider_class' or 'app.json' instead.",
+            DeprecationWarning,
+            stacklevel=2,
+        )
+        self._json_decoder = value
+
+    json_provider_class: t.Type[JSONProvider] = DefaultJSONProvider
+    """A subclass of :class:`~flask.json.provider.JSONProvider`. An
+    instance is created and assigned to :attr:`app.json` when creating
+    the app.
+
+    The default, :class:`~flask.json.provider.DefaultJSONProvider`, uses
+    Python's built-in :mod:`json` library. A different provider can use
+    a different JSON library.
+
+    .. versionadded:: 2.2
+    """
 
     #: Options that are passed to the Jinja environment in
     #: :meth:`create_jinja_environment`. Changing these options after
@@ -321,7 +491,6 @@ class Flask(Scaffold):
             "DEBUG": None,
             "TESTING": False,
             "PROPAGATE_EXCEPTIONS": None,
-            "PRESERVE_CONTEXT_ON_EXCEPTION": None,
             "SECRET_KEY": None,
             "PERMANENT_SESSION_LIFETIME": timedelta(days=31),
             "USE_X_SENDFILE": False,
@@ -340,10 +509,10 @@ class Flask(Scaffold):
             "TRAP_HTTP_EXCEPTIONS": False,
             "EXPLAIN_TEMPLATE_LOADING": False,
             "PREFERRED_URL_SCHEME": "http",
-            "JSON_AS_ASCII": True,
-            "JSON_SORT_KEYS": True,
-            "JSONIFY_PRETTYPRINT_REGULAR": False,
-            "JSONIFY_MIMETYPE": "application/json",
+            "JSON_AS_ASCII": None,
+            "JSON_SORT_KEYS": None,
+            "JSONIFY_PRETTYPRINT_REGULAR": None,
+            "JSONIFY_MIMETYPE": None,
             "TEMPLATES_AUTO_RELOAD": None,
             "MAX_COOKIE_SIZE": 4093,
         }
@@ -389,7 +558,7 @@ class Flask(Scaffold):
         static_host: t.Optional[str] = None,
         host_matching: bool = False,
         subdomain_matching: bool = False,
-        template_folder: t.Optional[str] = "templates",
+        template_folder: t.Optional[t.Union[str, os.PathLike]] = "templates",
         instance_path: t.Optional[str] = None,
         instance_relative_config: bool = False,
         root_path: t.Optional[str] = None,
@@ -420,23 +589,52 @@ class Flask(Scaffold):
         #: to load a config from files.
         self.config = self.make_config(instance_relative_config)
 
-        #: A list of functions that are called when :meth:`url_for` raises a
-        #: :exc:`~werkzeug.routing.BuildError`.  Each function registered here
-        #: is called with `error`, `endpoint` and `values`.  If a function
-        #: returns ``None`` or raises a :exc:`BuildError` the next function is
-        #: tried.
+        #: An instance of :attr:`aborter_class` created by
+        #: :meth:`make_aborter`. This is called by :func:`flask.abort`
+        #: to raise HTTP errors, and can be called directly as well.
+        #:
+        #: .. versionadded:: 2.2
+        #:     Moved from ``flask.abort``, which calls this object.
+        self.aborter = self.make_aborter()
+
+        self.json: JSONProvider = self.json_provider_class(self)
+        """Provides access to JSON methods. Functions in ``flask.json``
+        will call methods on this provider when the application context
+        is active. Used for handling JSON requests and responses.
+
+        An instance of :attr:`json_provider_class`. Can be customized by
+        changing that attribute on a subclass, or by assigning to this
+        attribute afterwards.
+
+        The default, :class:`~flask.json.provider.DefaultJSONProvider`,
+        uses Python's built-in :mod:`json` library. A different provider
+        can use a different JSON library.
+
+        .. versionadded:: 2.2
+        """
+
+        #: A list of functions that are called by
+        #: :meth:`handle_url_build_error` when :meth:`.url_for` raises a
+        #: :exc:`~werkzeug.routing.BuildError`. Each function is called
+        #: with ``error``, ``endpoint`` and ``values``. If a function
+        #: returns ``None`` or raises a ``BuildError``, it is skipped.
+        #: Otherwise, its return value is returned by ``url_for``.
         #:
         #: .. versionadded:: 0.9
         self.url_build_error_handlers: t.List[
-            t.Callable[[Exception, str, dict], str]
+            t.Callable[[Exception, str, t.Dict[str, t.Any]], str]
         ] = []
 
         #: A list of functions that will be called at the beginning of the
         #: first request to this instance. To register a function, use the
         #: :meth:`before_first_request` decorator.
         #:
+        #: .. deprecated:: 2.2
+        #:     Will be removed in Flask 2.3. Run setup code when
+        #:     creating the application instead.
+        #:
         #: .. versionadded:: 0.8
-        self.before_first_request_funcs: t.List[BeforeFirstRequestCallable] = []
+        self.before_first_request_funcs: t.List[ft.BeforeFirstRequestCallable] = []
 
         #: A list of functions that are called when the application context
         #: is destroyed.  Since the application context is also torn down
@@ -444,13 +642,13 @@ class Flask(Scaffold):
         #: from databases.
         #:
         #: .. versionadded:: 0.9
-        self.teardown_appcontext_funcs: t.List[TeardownCallable] = []
+        self.teardown_appcontext_funcs: t.List[ft.TeardownCallable] = []
 
         #: A list of shell context processor functions that should be run
         #: when a shell context is created.
         #:
         #: .. versionadded:: 0.11
-        self.shell_context_processors: t.List[t.Callable[[], t.Dict[str, t.Any]]] = []
+        self.shell_context_processors: t.List[ft.ShellContextProcessorCallable] = []
 
         #: Maps registered blueprint names to blueprint objects. The
         #: dict retains the order the blueprints were registered in.
@@ -519,8 +717,17 @@ class Flask(Scaffold):
         # the app's commands to another CLI tool.
         self.cli.name = self.name
 
-    def _is_setup_finished(self) -> bool:
-        return self.debug and self._got_first_request
+    def _check_setup_finished(self, f_name: str) -> None:
+        if self._got_first_request:
+            raise AssertionError(
+                f"The setup method '{f_name}' can no longer be called"
+                " on the application. It has already handled its first"
+                " request, any changes will not be applied"
+                " consistently.\n"
+                "Make sure all imports, decorators, functions, etc."
+                " needed to set up the application are done before"
+                " running it."
+            )
 
     @locked_cached_property
     def name(self) -> str:  # type: ignore
@@ -544,26 +751,23 @@ class Flask(Scaffold):
         """Returns the value of the ``PROPAGATE_EXCEPTIONS`` configuration
         value in case it's set, otherwise a sensible default is returned.
 
+        .. deprecated:: 2.2
+            Will be removed in Flask 2.3.
+
         .. versionadded:: 0.7
         """
+        import warnings
+
+        warnings.warn(
+            "'propagate_exceptions' is deprecated and will be removed in Flask 2.3.",
+            DeprecationWarning,
+            stacklevel=2,
+        )
         rv = self.config["PROPAGATE_EXCEPTIONS"]
         if rv is not None:
             return rv
         return self.testing or self.debug
 
-    @property
-    def preserve_context_on_exception(self) -> bool:
-        """Returns the value of the ``PRESERVE_CONTEXT_ON_EXCEPTION``
-        configuration value in case it's set, otherwise a sensible default
-        is returned.
-
-        .. versionadded:: 0.7
-        """
-        rv = self.config["PRESERVE_CONTEXT_ON_EXCEPTION"]
-        if rv is not None:
-            return rv
-        return self.debug
-
     @locked_cached_property
     def logger(self) -> logging.Logger:
         """A standard Python :class:`~logging.Logger` for the app, with
@@ -623,10 +827,22 @@ class Flask(Scaffold):
         if instance_relative:
             root_path = self.instance_path
         defaults = dict(self.default_config)
-        defaults["ENV"] = get_env()
+        defaults["ENV"] = os.environ.get("FLASK_ENV") or "production"
         defaults["DEBUG"] = get_debug_flag()
         return self.config_class(root_path, defaults)
 
+    def make_aborter(self) -> Aborter:
+        """Create the object to assign to :attr:`aborter`. That object
+        is called by :func:`flask.abort` to raise HTTP errors, and can
+        be called directly as well.
+
+        By default, this creates an instance of :attr:`aborter_class`,
+        which defaults to :class:`werkzeug.exceptions.Aborter`.
+
+        .. versionadded:: 2.2
+        """
+        return self.aborter_class()
+
     def auto_find_instance_path(self) -> str:
         """Tries to locate the instance path if it was not provided to the
         constructor of the application class.  It will basically calculate
@@ -655,20 +871,37 @@ class Flask(Scaffold):
     @property
     def templates_auto_reload(self) -> bool:
         """Reload templates when they are changed. Used by
-        :meth:`create_jinja_environment`.
+        :meth:`create_jinja_environment`. It is enabled by default in debug mode.
 
-        This attribute can be configured with :data:`TEMPLATES_AUTO_RELOAD`. If
-        not set, it will be enabled in debug mode.
+        .. deprecated:: 2.2
+            Will be removed in Flask 2.3. Use ``app.config["TEMPLATES_AUTO_RELOAD"]``
+            instead.
 
         .. versionadded:: 1.0
             This property was added but the underlying config and behavior
             already existed.
         """
+        import warnings
+
+        warnings.warn(
+            "'templates_auto_reload' is deprecated and will be removed in Flask 2.3."
+            " Use 'TEMPLATES_AUTO_RELOAD' in 'app.config' instead.",
+            DeprecationWarning,
+            stacklevel=2,
+        )
         rv = self.config["TEMPLATES_AUTO_RELOAD"]
         return rv if rv is not None else self.debug
 
     @templates_auto_reload.setter
     def templates_auto_reload(self, value: bool) -> None:
+        import warnings
+
+        warnings.warn(
+            "'templates_auto_reload' is deprecated and will be removed in Flask 2.3."
+            " Use 'TEMPLATES_AUTO_RELOAD' in 'app.config' instead.",
+            DeprecationWarning,
+            stacklevel=2,
+        )
         self.config["TEMPLATES_AUTO_RELOAD"] = value
 
     def create_jinja_environment(self) -> Environment:
@@ -689,11 +922,16 @@ class Flask(Scaffold):
             options["autoescape"] = self.select_jinja_autoescape
 
         if "auto_reload" not in options:
-            options["auto_reload"] = self.templates_auto_reload
+            auto_reload = self.config["TEMPLATES_AUTO_RELOAD"]
+
+            if auto_reload is None:
+                auto_reload = self.debug
+
+            options["auto_reload"] = auto_reload
 
         rv = self.jinja_environment(self, **options)
         rv.globals.update(
-            url_for=url_for,
+            url_for=self.url_for,
             get_flashed_messages=get_flashed_messages,
             config=self.config,
             # request, session and g are normally added with the
@@ -703,7 +941,7 @@ class Flask(Scaffold):
             session=session,
             g=g,
         )
-        rv.policies["json.dumps_function"] = json.dumps
+        rv.policies["json.dumps_function"] = self.json.dumps
         return rv
 
     def create_global_jinja_loader(self) -> DispatchingJinjaLoader:
@@ -723,11 +961,14 @@ class Flask(Scaffold):
         """Returns ``True`` if autoescaping should be active for the given
         template name. If no template name is given, returns `True`.
 
+        .. versionchanged:: 2.2
+            Autoescaping is now enabled by default for ``.svg`` files.
+
         .. versionadded:: 0.5
         """
         if filename is None:
             return True
-        return filename.endswith((".html", ".htm", ".xml", ".xhtml"))
+        return filename.endswith((".html", ".htm", ".xml", ".xhtml", ".svg"))
 
     def update_template_context(self, context: dict) -> None:
         """Update the template context with some commonly used variables.
@@ -769,38 +1010,59 @@ class Flask(Scaffold):
             rv.update(processor())
         return rv
 
-    #: What environment the app is running in. Flask and extensions may
-    #: enable behaviors based on the environment, such as enabling debug
-    #: mode. This maps to the :data:`ENV` config key. This is set by the
-    #: :envvar:`FLASK_ENV` environment variable and may not behave as
-    #: expected if set in code.
-    #:
-    #: **Do not enable development when deploying in production.**
-    #:
-    #: Default: ``'production'``
-    env = ConfigAttribute("ENV")
+    @property
+    def env(self) -> str:
+        """What environment the app is running in. This maps to the :data:`ENV` config
+        key.
+
+        **Do not enable development when deploying in production.**
+
+        Default: ``'production'``
+
+        .. deprecated:: 2.2
+            Will be removed in Flask 2.3.
+        """
+        import warnings
+
+        warnings.warn(
+            "'app.env' is deprecated and will be removed in Flask 2.3."
+            " Use 'app.debug' instead.",
+            DeprecationWarning,
+            stacklevel=2,
+        )
+        return self.config["ENV"]
+
+    @env.setter
+    def env(self, value: str) -> None:
+        import warnings
+
+        warnings.warn(
+            "'app.env' is deprecated and will be removed in Flask 2.3."
+            " Use 'app.debug' instead.",
+            DeprecationWarning,
+            stacklevel=2,
+        )
+        self.config["ENV"] = value
 
     @property
     def debug(self) -> bool:
-        """Whether debug mode is enabled. When using ``flask run`` to start
-        the development server, an interactive debugger will be shown for
-        unhandled exceptions, and the server will be reloaded when code
-        changes. This maps to the :data:`DEBUG` config key. This is
-        enabled when :attr:`env` is ``'development'`` and is overridden
-        by the ``FLASK_DEBUG`` environment variable. It may not behave as
-        expected if set in code.
+        """Whether debug mode is enabled. When using ``flask run`` to start the
+        development server, an interactive debugger will be shown for unhandled
+        exceptions, and the server will be reloaded when code changes. This maps to the
+        :data:`DEBUG` config key. It may not behave as expected if set late.
 
         **Do not enable debug mode when deploying in production.**
 
-        Default: ``True`` if :attr:`env` is ``'development'``, or
-        ``False`` otherwise.
+        Default: ``False``
         """
         return self.config["DEBUG"]
 
     @debug.setter
     def debug(self, value: bool) -> None:
         self.config["DEBUG"] = value
-        self.jinja_env.auto_reload = self.templates_auto_reload
+
+        if self.config["TEMPLATES_AUTO_RELOAD"] is None:
+            self.jinja_env.auto_reload = value
 
     def run(
         self,
@@ -857,9 +1119,7 @@ class Flask(Scaffold):
             If installed, python-dotenv will be used to load environment
             variables from :file:`.env` and :file:`.flaskenv` files.
 
-            If set, the :envvar:`FLASK_ENV` and :envvar:`FLASK_DEBUG`
-            environment variables will override :attr:`env` and
-            :attr:`debug`.
+            The :envvar:`FLASK_DEBUG` environment variable will override :attr:`debug`.
 
             Threaded mode is enabled by default.
 
@@ -867,12 +1127,18 @@ class Flask(Scaffold):
             The default port is now picked from the ``SERVER_NAME``
             variable.
         """
-        # Change this into a no-op if the server is invoked from the
-        # command line. Have a look at cli.py for more information.
+        # Ignore this call so that it doesn't start another server if
+        # the 'flask run' command is used.
         if os.environ.get("FLASK_RUN_FROM_CLI") == "true":
-            from .debughelpers import explain_ignored_app_run
+            if not is_running_from_reloader():
+                click.secho(
+                    " * Ignoring a call to 'app.run()' that would block"
+                    " the current 'flask' CLI command.\n"
+                    "   Only call 'app.run()' in an 'if __name__ =="
+                    ' "__main__"\' guard.',
+                    fg="red",
+                )
 
-            explain_ignored_app_run()
             return
 
         if get_load_dotenv(load_dotenv):
@@ -880,7 +1146,12 @@ class Flask(Scaffold):
 
             # if set, let env vars override previous values
             if "FLASK_ENV" in os.environ:
-                self.env = get_env()
+                print(
+                    "'FLASK_ENV' is deprecated and will not be used in"
+                    " Flask 2.3. Use 'FLASK_DEBUG' instead.",
+                    file=sys.stderr,
+                )
+                self.config["ENV"] = os.environ.get("FLASK_ENV") or "production"
                 self.debug = get_debug_flag()
             elif "FLASK_DEBUG" in os.environ:
                 self.debug = get_debug_flag()
@@ -912,7 +1183,7 @@ class Flask(Scaffold):
         options.setdefault("use_debugger", self.debug)
         options.setdefault("threaded", True)
 
-        cli.show_server_banner(self.env, self.debug, self.name, False)
+        cli.show_server_banner(self.debug, self.name)
 
         from werkzeug.serving import run_simple
 
@@ -1039,7 +1310,7 @@ class Flask(Scaffold):
         self,
         rule: str,
         endpoint: t.Optional[str] = None,
-        view_func: t.Optional[t.Callable] = None,
+        view_func: t.Optional[ft.RouteCallable] = None,
         provide_automatic_options: t.Optional[bool] = None,
         **options: t.Any,
     ) -> None:
@@ -1096,7 +1367,7 @@ class Flask(Scaffold):
     @setupmethod
     def template_filter(
         self, name: t.Optional[str] = None
-    ) -> t.Callable[[TemplateFilterCallable], TemplateFilterCallable]:
+    ) -> t.Callable[[T_template_filter], T_template_filter]:
         """A decorator that is used to register custom template filter.
         You can specify a name for the filter, otherwise the function
         name will be used. Example::
@@ -1109,7 +1380,7 @@ class Flask(Scaffold):
                      function name will be used.
         """
 
-        def decorator(f: TemplateFilterCallable) -> TemplateFilterCallable:
+        def decorator(f: T_template_filter) -> T_template_filter:
             self.add_template_filter(f, name=name)
             return f
 
@@ -1117,7 +1388,7 @@ class Flask(Scaffold):
 
     @setupmethod
     def add_template_filter(
-        self, f: TemplateFilterCallable, name: t.Optional[str] = None
+        self, f: ft.TemplateFilterCallable, name: t.Optional[str] = None
     ) -> None:
         """Register a custom template filter.  Works exactly like the
         :meth:`template_filter` decorator.
@@ -1130,7 +1401,7 @@ class Flask(Scaffold):
     @setupmethod
     def template_test(
         self, name: t.Optional[str] = None
-    ) -> t.Callable[[TemplateTestCallable], TemplateTestCallable]:
+    ) -> t.Callable[[T_template_test], T_template_test]:
         """A decorator that is used to register custom template test.
         You can specify a name for the test, otherwise the function
         name will be used. Example::
@@ -1150,7 +1421,7 @@ class Flask(Scaffold):
                      function name will be used.
         """
 
-        def decorator(f: TemplateTestCallable) -> TemplateTestCallable:
+        def decorator(f: T_template_test) -> T_template_test:
             self.add_template_test(f, name=name)
             return f
 
@@ -1158,7 +1429,7 @@ class Flask(Scaffold):
 
     @setupmethod
     def add_template_test(
-        self, f: TemplateTestCallable, name: t.Optional[str] = None
+        self, f: ft.TemplateTestCallable, name: t.Optional[str] = None
     ) -> None:
         """Register a custom template test.  Works exactly like the
         :meth:`template_test` decorator.
@@ -1173,7 +1444,7 @@ class Flask(Scaffold):
     @setupmethod
     def template_global(
         self, name: t.Optional[str] = None
-    ) -> t.Callable[[TemplateGlobalCallable], TemplateGlobalCallable]:
+    ) -> t.Callable[[T_template_global], T_template_global]:
         """A decorator that is used to register a custom template global function.
         You can specify a name for the global function, otherwise the function
         name will be used. Example::
@@ -1188,7 +1459,7 @@ class Flask(Scaffold):
                      function name will be used.
         """
 
-        def decorator(f: TemplateGlobalCallable) -> TemplateGlobalCallable:
+        def decorator(f: T_template_global) -> T_template_global:
             self.add_template_global(f, name=name)
             return f
 
@@ -1196,7 +1467,7 @@ class Flask(Scaffold):
 
     @setupmethod
     def add_template_global(
-        self, f: TemplateGlobalCallable, name: t.Optional[str] = None
+        self, f: ft.TemplateGlobalCallable, name: t.Optional[str] = None
     ) -> None:
         """Register a custom template global function. Works exactly like the
         :meth:`template_global` decorator.
@@ -1209,45 +1480,57 @@ class Flask(Scaffold):
         self.jinja_env.globals[name or f.__name__] = f
 
     @setupmethod
-    def before_first_request(
-        self, f: BeforeFirstRequestCallable
-    ) -> BeforeFirstRequestCallable:
+    def before_first_request(self, f: T_before_first_request) -> T_before_first_request:
         """Registers a function to be run before the first request to this
         instance of the application.
 
         The function will be called without any arguments and its return
         value is ignored.
 
+        .. deprecated:: 2.2
+            Will be removed in Flask 2.3. Run setup code when creating
+            the application instead.
+
         .. versionadded:: 0.8
         """
+        import warnings
+
+        warnings.warn(
+            "'before_first_request' is deprecated and will be removed"
+            " in Flask 2.3. Run setup code while creating the"
+            " application instead.",
+            DeprecationWarning,
+            stacklevel=2,
+        )
         self.before_first_request_funcs.append(f)
         return f
 
     @setupmethod
-    def teardown_appcontext(self, f: TeardownCallable) -> TeardownCallable:
-        """Registers a function to be called when the application context
-        ends.  These functions are typically also called when the request
-        context is popped.
+    def teardown_appcontext(self, f: T_teardown) -> T_teardown:
+        """Registers a function to be called when the application
+        context is popped. The application context is typically popped
+        after the request context for each request, at the end of CLI
+        commands, or after a manually pushed context ends.
 
-        Example::
+        .. code-block:: python
 
-            ctx = app.app_context()
-            ctx.push()
-            ...
-            ctx.pop()
+            with app.app_context():
+                ...
 
-        When ``ctx.pop()`` is executed in the above example, the teardown
-        functions are called just before the app context moves from the
-        stack of active contexts.  This becomes relevant if you are using
-        such constructs in tests.
+        When the ``with`` block exits (or ``ctx.pop()`` is called), the
+        teardown functions are called just before the app context is
+        made inactive. Since a request context typically also manages an
+        application context it would also be called when you pop a
+        request context.
 
-        Since a request context typically also manages an application
-        context it would also be called when you pop a request context.
+        When a teardown function was called because of an unhandled
+        exception it will be passed an error object. If an
+        :meth:`errorhandler` is registered, it will handle the exception
+        and the teardown will not receive it.
 
-        When a teardown function was called because of an unhandled exception
-        it will be passed an error object. If an :meth:`errorhandler` is
-        registered, it will handle the exception and the teardown will not
-        receive it.
+        Teardown functions must avoid raising exceptions. If they
+        execute code that might fail they must surround that code with a
+        ``try``/``except`` block and log any errors.
 
         The return values of teardown functions are ignored.
 
@@ -1257,7 +1540,9 @@ class Flask(Scaffold):
         return f
 
     @setupmethod
-    def shell_context_processor(self, f: t.Callable) -> t.Callable:
+    def shell_context_processor(
+        self, f: T_shell_context_processor
+    ) -> T_shell_context_processor:
         """Registers a shell context processor function.
 
         .. versionadded:: 0.11
@@ -1265,7 +1550,7 @@ class Flask(Scaffold):
         self.shell_context_processors.append(f)
         return f
 
-    def _find_error_handler(self, e: Exception) -> t.Optional["ErrorHandlerCallable"]:
+    def _find_error_handler(self, e: Exception) -> t.Optional[ft.ErrorHandlerCallable]:
         """Return a registered error handler for an exception in this order:
         blueprint handler for a specific code, app handler for a specific code,
         blueprint handler for an exception class, app handler for an exception
@@ -1290,7 +1575,7 @@ class Flask(Scaffold):
 
     def handle_http_exception(
         self, e: HTTPException
-    ) -> t.Union[HTTPException, ResponseReturnValue]:
+    ) -> t.Union[HTTPException, ft.ResponseReturnValue]:
         """Handles an HTTP exception.  By default this will invoke the
         registered error handlers and fall back to returning the
         exception as response.
@@ -1360,7 +1645,7 @@ class Flask(Scaffold):
 
     def handle_user_exception(
         self, e: Exception
-    ) -> t.Union[HTTPException, ResponseReturnValue]:
+    ) -> t.Union[HTTPException, ft.ResponseReturnValue]:
         """This method is called whenever an exception occurs that
         should be handled. A special case is :class:`~werkzeug
         .exceptions.HTTPException` which is forwarded to the
@@ -1420,8 +1705,12 @@ class Flask(Scaffold):
         """
         exc_info = sys.exc_info()
         got_request_exception.send(self, exception=e)
+        propagate = self.config["PROPAGATE_EXCEPTIONS"]
+
+        if propagate is None:
+            propagate = self.testing or self.debug
 
-        if self.propagate_exceptions:
+        if propagate:
             # Re-raise if called with an active exception, otherwise
             # raise the passed in exception.
             if exc_info[1] is e:
@@ -1430,7 +1719,7 @@ class Flask(Scaffold):
             raise e
 
         self.log_exception(exc_info)
-        server_error: t.Union[InternalServerError, ResponseReturnValue]
+        server_error: t.Union[InternalServerError, ft.ResponseReturnValue]
         server_error = InternalServerError(original_exception=e)
         handler = self._find_error_handler(server_error)
 
@@ -1484,7 +1773,7 @@ class Flask(Scaffold):
 
         raise FormDataRoutingRedirect(request)
 
-    def dispatch_request(self) -> ResponseReturnValue:
+    def dispatch_request(self) -> ft.ResponseReturnValue:
         """Does the request dispatching.  Matches the URL and returns the
         return value of the view or error handler.  This does not have to
         be a response object.  In order to convert the return value to a
@@ -1494,10 +1783,10 @@ class Flask(Scaffold):
            This no longer does the exception handling, this code was
            moved to the new :meth:`full_dispatch_request`.
         """
-        req = _request_ctx_stack.top.request
+        req = request_ctx.request
         if req.routing_exception is not None:
             self.raise_routing_exception(req)
-        rule = req.url_rule
+        rule: Rule = req.url_rule  # type: ignore[assignment]
         # if we provide automatic options for this URL and the
         # request came with the OPTIONS method, reply automatically
         if (
@@ -1506,7 +1795,8 @@ class Flask(Scaffold):
         ):
             return self.make_default_options_response()
         # otherwise dispatch to the handler for that endpoint
-        return self.ensure_sync(self.view_functions[rule.endpoint])(**req.view_args)
+        view_args: t.Dict[str, t.Any] = req.view_args  # type: ignore[assignment]
+        return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)
 
     def full_dispatch_request(self) -> Response:
         """Dispatches the request and on top of that performs request
@@ -1515,7 +1805,17 @@ class Flask(Scaffold):
 
         .. versionadded:: 0.7
         """
-        self.try_trigger_before_first_request_functions()
+        # Run before_first_request functions if this is the thread's first request.
+        # Inlined to avoid a method call on subsequent requests.
+        # This is deprecated, will be removed in Flask 2.3.
+        if not self._got_first_request:
+            with self._before_request_lock:
+                if not self._got_first_request:
+                    for func in self.before_first_request_funcs:
+                        self.ensure_sync(func)()
+
+                    self._got_first_request = True
+
         try:
             request_started.send(self)
             rv = self.preprocess_request()
@@ -1527,7 +1827,7 @@ class Flask(Scaffold):
 
     def finalize_request(
         self,
-        rv: t.Union[ResponseReturnValue, HTTPException],
+        rv: t.Union[ft.ResponseReturnValue, HTTPException],
         from_error_handler: bool = False,
     ) -> Response:
         """Given the return value from a view function this finalizes
@@ -1554,22 +1854,6 @@ class Flask(Scaffold):
             )
         return response
 
-    def try_trigger_before_first_request_functions(self) -> None:
-        """Called before each request and will ensure that it triggers
-        the :attr:`before_first_request_funcs` and only exactly once per
-        application instance (which means process usually).
-
-        :internal:
-        """
-        if self._got_first_request:
-            return
-        with self._before_request_lock:
-            if self._got_first_request:
-                return
-            for func in self.before_first_request_funcs:
-                self.ensure_sync(func)()
-            self._got_first_request = True
-
     def make_default_options_response(self) -> Response:
         """This method is called to create the default ``OPTIONS`` response.
         This can be changed through subclassing to change the default
@@ -1577,8 +1861,8 @@ class Flask(Scaffold):
 
         .. versionadded:: 0.7
         """
-        adapter = _request_ctx_stack.top.url_adapter
-        methods = adapter.allowed_methods()
+        adapter = request_ctx.url_adapter
+        methods = adapter.allowed_methods()  # type: ignore[union-attr]
         rv = self.response_class()
         rv.allow.update(methods)
         return rv
@@ -1630,7 +1914,145 @@ class Flask(Scaffold):
 
         return asgiref_async_to_sync(func)
 
-    def make_response(self, rv: ResponseReturnValue) -> Response:
+    def url_for(
+        self,
+        endpoint: str,
+        *,
+        _anchor: t.Optional[str] = None,
+        _method: t.Optional[str] = None,
+        _scheme: t.Optional[str] = None,
+        _external: t.Optional[bool] = None,
+        **values: t.Any,
+    ) -> str:
+        """Generate a URL to the given endpoint with the given values.
+
+        This is called by :func:`flask.url_for`, and can be called
+        directly as well.
+
+        An *endpoint* is the name of a URL rule, usually added with
+        :meth:`@app.route() <route>`, and usually the same name as the
+        view function. A route defined in a :class:`~flask.Blueprint`
+        will prepend the blueprint's name separated by a ``.`` to the
+        endpoint.
+
+        In some cases, such as email messages, you want URLs to include
+        the scheme and domain, like ``https://example.com/hello``. When
+        not in an active request, URLs will be external by default, but
+        this requires setting :data:`SERVER_NAME` so Flask knows what
+        domain to use. :data:`APPLICATION_ROOT` and
+        :data:`PREFERRED_URL_SCHEME` should also be configured as
+        needed. This config is only used when not in an active request.
+
+        Functions can be decorated with :meth:`url_defaults` to modify
+        keyword arguments before the URL is built.
+
+        If building fails for some reason, such as an unknown endpoint
+        or incorrect values, the app's :meth:`handle_url_build_error`
+        method is called. If that returns a string, that is returned,
+        otherwise a :exc:`~werkzeug.routing.BuildError` is raised.
+
+        :param endpoint: The endpoint name associated with the URL to
+            generate. If this starts with a ``.``, the current blueprint
+            name (if any) will be used.
+        :param _anchor: If given, append this as ``#anchor`` to the URL.
+        :param _method: If given, generate the URL associated with this
+            method for the endpoint.
+        :param _scheme: If given, the URL will have this scheme if it
+            is external.
+        :param _external: If given, prefer the URL to be internal
+            (False) or require it to be external (True). External URLs
+            include the scheme and domain. When not in an active
+            request, URLs are external by default.
+        :param values: Values to use for the variable parts of the URL
+            rule. Unknown keys are appended as query string arguments,
+            like ``?a=b&c=d``.
+
+        .. versionadded:: 2.2
+            Moved from ``flask.url_for``, which calls this method.
+        """
+        req_ctx = _cv_request.get(None)
+
+        if req_ctx is not None:
+            url_adapter = req_ctx.url_adapter
+            blueprint_name = req_ctx.request.blueprint
+
+            # If the endpoint starts with "." and the request matches a
+            # blueprint, the endpoint is relative to the blueprint.
+            if endpoint[:1] == ".":
+                if blueprint_name is not None:
+                    endpoint = f"{blueprint_name}{endpoint}"
+                else:
+                    endpoint = endpoint[1:]
+
+            # When in a request, generate a URL without scheme and
+            # domain by default, unless a scheme is given.
+            if _external is None:
+                _external = _scheme is not None
+        else:
+            app_ctx = _cv_app.get(None)
+
+            # If called by helpers.url_for, an app context is active,
+            # use its url_adapter. Otherwise, app.url_for was called
+            # directly, build an adapter.
+            if app_ctx is not None:
+                url_adapter = app_ctx.url_adapter
+            else:
+                url_adapter = self.create_url_adapter(None)
+
+            if url_adapter is None:
+                raise RuntimeError(
+                    "Unable to build URLs outside an active request"
+                    " without 'SERVER_NAME' configured. Also configure"
+                    " 'APPLICATION_ROOT' and 'PREFERRED_URL_SCHEME' as"
+                    " needed."
+                )
+
+            # When outside a request, generate a URL with scheme and
+            # domain by default.
+            if _external is None:
+                _external = True
+
+        # It is an error to set _scheme when _external=False, in order
+        # to avoid accidental insecure URLs.
+        if _scheme is not None and not _external:
+            raise ValueError("When specifying '_scheme', '_external' must be True.")
+
+        self.inject_url_defaults(endpoint, values)
+
+        try:
+            rv = url_adapter.build(  # type: ignore[union-attr]
+                endpoint,
+                values,
+                method=_method,
+                url_scheme=_scheme,
+                force_external=_external,
+            )
+        except BuildError as error:
+            values.update(
+                _anchor=_anchor, _method=_method, _scheme=_scheme, _external=_external
+            )
+            return self.handle_url_build_error(error, endpoint, values)
+
+        if _anchor is not None:
+            rv = f"{rv}#{url_quote(_anchor)}"
+
+        return rv
+
+    def redirect(self, location: str, code: int = 302) -> BaseResponse:
+        """Create a redirect response object.
+
+        This is called by :func:`flask.redirect`, and can be called
+        directly as well.
+
+        :param location: The URL to redirect to.
+        :param code: The status code for the redirect.
+
+        .. versionadded:: 2.2
+            Moved from ``flask.redirect``, which calls this method.
+        """
+        return _wz_redirect(location, code=code, Response=self.response_class)
+
+    def make_response(self, rv: ft.ResponseReturnValue) -> Response:
         """Convert the return value from a view function to an instance of
         :attr:`response_class`.
 
@@ -1649,6 +2071,13 @@ class Flask(Scaffold):
             ``dict``
                 A dictionary that will be jsonify'd before being returned.
 
+            ``list``
+                A list that will be jsonify'd before being returned.
+
+            ``generator`` or ``iterator``
+                A generator that returns ``str`` or ``bytes`` to be
+                streamed as the response.
+
             ``tuple``
                 Either ``(body, status, headers)``, ``(body, status)``, or
                 ``(body, headers)``, where ``body`` is any of the other types
@@ -1668,6 +2097,13 @@ class Flask(Scaffold):
                 The function is called as a WSGI application. The result is
                 used to create a response object.
 
+        .. versionchanged:: 2.2
+            A generator will be converted to a streaming response.
+            A list will be converted to a JSON response.
+
+        .. versionchanged:: 1.1
+            A dict will be converted to a JSON response.
+
         .. versionchanged:: 0.9
            Previously a tuple was interpreted as the arguments for the
            response object.
@@ -1687,7 +2123,7 @@ class Flask(Scaffold):
                 if isinstance(rv[1], (Headers, dict, tuple, list)):
                     rv, headers = rv
                 else:
-                    rv, status = rv  # type: ignore[misc]
+                    rv, status = rv  # type: ignore[assignment,misc]
             # other sized tuples are not allowed
             else:
                 raise TypeError(
@@ -1706,7 +2142,7 @@ class Flask(Scaffold):
 
         # make sure the body is an instance of the response class
         if not isinstance(rv, self.response_class):
-            if isinstance(rv, (str, bytes, bytearray)):
+            if isinstance(rv, (str, bytes, bytearray)) or isinstance(rv, _abc_Iterator):
                 # let the response class set the status and headers instead of
                 # waiting to do it manually, so that the class can handle any
                 # special logic
@@ -1716,26 +2152,30 @@ class Flask(Scaffold):
                     headers=headers,  # type: ignore[arg-type]
                 )
                 status = headers = None
-            elif isinstance(rv, dict):
-                rv = jsonify(rv)
+            elif isinstance(rv, (dict, list)):
+                rv = self.json.response(rv)
             elif isinstance(rv, BaseResponse) or callable(rv):
                 # evaluate a WSGI callable, or coerce a different response
                 # class to the correct type
                 try:
-                    rv = self.response_class.force_type(rv, request.environ)  # type: ignore  # noqa: B950
+                    rv = self.response_class.force_type(
+                        rv, request.environ  # type: ignore[arg-type]
+                    )
                 except TypeError as e:
                     raise TypeError(
                         f"{e}\nThe view function did not return a valid"
                         " response. The return type must be a string,"
-                        " dict, tuple, Response instance, or WSGI"
-                        f" callable, but it was a {type(rv).__name__}."
+                        " dict, list, tuple with headers or status,"
+                        " Response instance, or WSGI callable, but it"
+                        f" was a {type(rv).__name__}."
                     ).with_traceback(sys.exc_info()[2]) from None
             else:
                 raise TypeError(
                     "The view function did not return a valid"
                     " response. The return type must be a string,"
-                    " dict, tuple, Response instance, or WSGI"
-                    f" callable, but it was a {type(rv).__name__}."
+                    " dict, list, tuple with headers or status,"
+                    " Response instance, or WSGI callable, but it was a"
+                    f" {type(rv).__name__}."
                 )
 
         rv = t.cast(Response, rv)
@@ -1816,10 +2256,21 @@ class Flask(Scaffold):
                     func(endpoint, values)
 
     def handle_url_build_error(
-        self, error: Exception, endpoint: str, values: dict
+        self, error: BuildError, endpoint: str, values: t.Dict[str, t.Any]
     ) -> str:
-        """Handle :class:`~werkzeug.routing.BuildError` on
-        :meth:`url_for`.
+        """Called by :meth:`.url_for` if a
+        :exc:`~werkzeug.routing.BuildError` was raised. If this returns
+        a value, it will be returned by ``url_for``, otherwise the error
+        will be re-raised.
+
+        Each function in :attr:`url_build_error_handlers` is called with
+        ``error``, ``endpoint`` and ``values``. If a function returns
+        ``None`` or raises a ``BuildError``, it is skipped. Otherwise,
+        its return value is returned by ``url_for``.
+
+        :param error: The active ``BuildError`` being handled.
+        :param endpoint: The endpoint being built.
+        :param values: The keyword arguments passed to ``url_for``.
         """
         for handler in self.url_build_error_handlers:
             try:
@@ -1838,7 +2289,7 @@ class Flask(Scaffold):
 
         raise error
 
-    def preprocess_request(self) -> t.Optional[ResponseReturnValue]:
+    def preprocess_request(self) -> t.Optional[ft.ResponseReturnValue]:
         """Called before the request is dispatched. Calls
         :attr:`url_value_preprocessors` registered with the app and the
         current blueprint (if any). Then calls :attr:`before_request_funcs`
@@ -1878,7 +2329,7 @@ class Flask(Scaffold):
         :return: a new response object or the same, has to be an
                  instance of :attr:`response_class`.
         """
-        ctx = _request_ctx_stack.top
+        ctx = request_ctx._get_current_object()  # type: ignore[attr-defined]
 
         for func in ctx._after_request_functions:
             response = self.ensure_sync(func)(response)
@@ -2083,9 +2534,14 @@ class Flask(Scaffold):
                 raise
             return response(environ, start_response)
         finally:
-            if self.should_ignore_error(error):
+            if "werkzeug.debug.preserve_context" in environ:
+                environ["werkzeug.debug.preserve_context"](_cv_app.get())
+                environ["werkzeug.debug.preserve_context"](_cv_request.get())
+
+            if error is not None and self.should_ignore_error(error):
                 error = None
-            ctx.auto_pop(error)
+
+            ctx.pop(error)
 
     def __call__(self, environ: dict, start_response: t.Callable) -> t.Any:
         """The WSGI server calls the Flask application object as the
diff --git a/src/flask/blueprints.py b/src/flask/blueprints.py
index 5d3b4e22..eb664235 100644
--- a/src/flask/blueprints.py
+++ b/src/flask/blueprints.py
@@ -1,27 +1,36 @@
+import json
 import os
 import typing as t
 from collections import defaultdict
 from functools import update_wrapper
 
+from . import typing as ft
 from .scaffold import _endpoint_from_view_func
 from .scaffold import _sentinel
 from .scaffold import Scaffold
-from .typing import AfterRequestCallable
-from .typing import BeforeFirstRequestCallable
-from .typing import BeforeRequestCallable
-from .typing import TeardownCallable
-from .typing import TemplateContextProcessorCallable
-from .typing import TemplateFilterCallable
-from .typing import TemplateGlobalCallable
-from .typing import TemplateTestCallable
-from .typing import URLDefaultCallable
-from .typing import URLValuePreprocessorCallable
-
-if t.TYPE_CHECKING:
+from .scaffold import setupmethod
+
+if t.TYPE_CHECKING:  # pragma: no cover
     from .app import Flask
-    from .typing import ErrorHandlerCallable
 
 DeferredSetupFunction = t.Callable[["BlueprintSetupState"], t.Callable]
+T_after_request = t.TypeVar("T_after_request", bound=ft.AfterRequestCallable)
+T_before_first_request = t.TypeVar(
+    "T_before_first_request", bound=ft.BeforeFirstRequestCallable
+)
+T_before_request = t.TypeVar("T_before_request", bound=ft.BeforeRequestCallable)
+T_error_handler = t.TypeVar("T_error_handler", bound=ft.ErrorHandlerCallable)
+T_teardown = t.TypeVar("T_teardown", bound=ft.TeardownCallable)
+T_template_context_processor = t.TypeVar(
+    "T_template_context_processor", bound=ft.TemplateContextProcessorCallable
+)
+T_template_filter = t.TypeVar("T_template_filter", bound=ft.TemplateFilterCallable)
+T_template_global = t.TypeVar("T_template_global", bound=ft.TemplateGlobalCallable)
+T_template_test = t.TypeVar("T_template_test", bound=ft.TemplateTestCallable)
+T_url_defaults = t.TypeVar("T_url_defaults", bound=ft.URLDefaultCallable)
+T_url_value_preprocessor = t.TypeVar(
+    "T_url_value_preprocessor", bound=ft.URLValuePreprocessorCallable
+)
 
 
 class BlueprintSetupState:
@@ -162,15 +171,78 @@ class Blueprint(Scaffold):
     .. versionadded:: 0.7
     """
 
-    warn_on_modifications = False
     _got_registered_once = False
 
-    #: Blueprint local JSON encoder class to use. Set to ``None`` to use
-    #: the app's :class:`~flask.Flask.json_encoder`.
-    json_encoder = None
-    #: Blueprint local JSON decoder class to use. Set to ``None`` to use
-    #: the app's :class:`~flask.Flask.json_decoder`.
-    json_decoder = None
+    _json_encoder: t.Union[t.Type[json.JSONEncoder], None] = None
+    _json_decoder: t.Union[t.Type[json.JSONDecoder], None] = None
+
+    @property
+    def json_encoder(
+        self,
+    ) -> t.Union[t.Type[json.JSONEncoder], None]:
+        """Blueprint-local JSON encoder class to use. Set to ``None`` to use the app's.
+
+        .. deprecated:: 2.2
+             Will be removed in Flask 2.3. Customize
+             :attr:`json_provider_class` instead.
+
+        .. versionadded:: 0.10
+        """
+        import warnings
+
+        warnings.warn(
+            "'bp.json_encoder' is deprecated and will be removed in Flask 2.3."
+            " Customize 'app.json_provider_class' or 'app.json' instead.",
+            DeprecationWarning,
+            stacklevel=2,
+        )
+        return self._json_encoder
+
+    @json_encoder.setter
+    def json_encoder(self, value: t.Union[t.Type[json.JSONEncoder], None]) -> None:
+        import warnings
+
+        warnings.warn(
+            "'bp.json_encoder' is deprecated and will be removed in Flask 2.3."
+            " Customize 'app.json_provider_class' or 'app.json' instead.",
+            DeprecationWarning,
+            stacklevel=2,
+        )
+        self._json_encoder = value
+
+    @property
+    def json_decoder(
+        self,
+    ) -> t.Union[t.Type[json.JSONDecoder], None]:
+        """Blueprint-local JSON decoder class to use. Set to ``None`` to use the app's.
+
+        .. deprecated:: 2.2
+             Will be removed in Flask 2.3. Customize
+             :attr:`json_provider_class` instead.
+
+        .. versionadded:: 0.10
+        """
+        import warnings
+
+        warnings.warn(
+            "'bp.json_decoder' is deprecated and will be removed in Flask 2.3."
+            " Customize 'app.json_provider_class' or 'app.json' instead.",
+            DeprecationWarning,
+            stacklevel=2,
+        )
+        return self._json_decoder
+
+    @json_decoder.setter
+    def json_decoder(self, value: t.Union[t.Type[json.JSONDecoder], None]) -> None:
+        import warnings
+
+        warnings.warn(
+            "'bp.json_decoder' is deprecated and will be removed in Flask 2.3."
+            " Customize 'app.json_provider_class' or 'app.json' instead.",
+            DeprecationWarning,
+            stacklevel=2,
+        )
+        self._json_decoder = value
 
     def __init__(
         self,
@@ -178,7 +250,7 @@ class Blueprint(Scaffold):
         import_name: str,
         static_folder: t.Optional[t.Union[str, os.PathLike]] = None,
         static_url_path: t.Optional[str] = None,
-        template_folder: t.Optional[str] = None,
+        template_folder: t.Optional[t.Union[str, os.PathLike]] = None,
         url_prefix: t.Optional[str] = None,
         subdomain: t.Optional[str] = None,
         url_defaults: t.Optional[dict] = None,
@@ -208,27 +280,33 @@ class Blueprint(Scaffold):
         self.cli_group = cli_group
         self._blueprints: t.List[t.Tuple["Blueprint", dict]] = []
 
-    def _is_setup_finished(self) -> bool:
-        return self.warn_on_modifications and self._got_registered_once
+    def _check_setup_finished(self, f_name: str) -> None:
+        if self._got_registered_once:
+            import warnings
+
+            warnings.warn(
+                f"The setup method '{f_name}' can no longer be called on"
+                f" the blueprint '{self.name}'. It has already been"
+                " registered at least once, any changes will not be"
+                " applied consistently.\n"
+                "Make sure all imports, decorators, functions, etc."
+                " needed to set up the blueprint are done before"
+                " registering it.\n"
+                "This warning will become an exception in Flask 2.3.",
+                UserWarning,
+                stacklevel=3,
+            )
 
+    @setupmethod
     def record(self, func: t.Callable) -> None:
         """Registers a function that is called when the blueprint is
         registered on the application.  This function is called with the
         state as argument as returned by the :meth:`make_setup_state`
         method.
         """
-        if self._got_registered_once and self.warn_on_modifications:
-            from warnings import warn
-
-            warn(
-                Warning(
-                    "The blueprint was already registered once but is"
-                    " getting modified now. These changes will not show"
-                    " up."
-                )
-            )
         self.deferred_functions.append(func)
 
+    @setupmethod
     def record_once(self, func: t.Callable) -> None:
         """Works like :meth:`record` but wraps the function in another
         function that will ensure the function is only called once.  If the
@@ -240,7 +318,7 @@ class Blueprint(Scaffold):
             if state.first_registration:
                 func(state)
 
-        return self.record(update_wrapper(wrapper, func))
+        self.record(update_wrapper(wrapper, func))
 
     def make_setup_state(
         self, app: "Flask", options: dict, first_registration: bool = False
@@ -251,6 +329,7 @@ class Blueprint(Scaffold):
         """
         return BlueprintSetupState(self, app, options, first_registration)
 
+    @setupmethod
     def register_blueprint(self, blueprint: "Blueprint", **options: t.Any) -> None:
         """Register a :class:`~flask.Blueprint` on this blueprint. Keyword
         arguments passed to this method will override the defaults set
@@ -390,16 +469,20 @@ class Blueprint(Scaffold):
             bp_options["name_prefix"] = name
             blueprint.register(app, bp_options)
 
+    @setupmethod
     def add_url_rule(
         self,
         rule: str,
         endpoint: t.Optional[str] = None,
-        view_func: t.Optional[t.Callable] = None,
+        view_func: t.Optional[ft.RouteCallable] = None,
         provide_automatic_options: t.Optional[bool] = None,
         **options: t.Any,
     ) -> None:
-        """Like :meth:`Flask.add_url_rule` but for a blueprint.  The endpoint for
-        the :func:`url_for` function is prefixed with the name of the blueprint.
+        """Register a URL rule with the blueprint. See :meth:`.Flask.add_url_rule` for
+        full documentation.
+
+        The URL rule is prefixed with the blueprint's URL prefix. The endpoint name,
+        used with :func:`url_for`, is prefixed with the blueprint's name.
         """
         if endpoint and "." in endpoint:
             raise ValueError("'endpoint' may not contain a dot '.' character.")
@@ -417,28 +500,30 @@ class Blueprint(Scaffold):
             )
         )
 
+    @setupmethod
     def app_template_filter(
         self, name: t.Optional[str] = None
-    ) -> t.Callable[[TemplateFilterCallable], TemplateFilterCallable]:
-        """Register a custom template filter, available application wide.  Like
-        :meth:`Flask.template_filter` but for a blueprint.
+    ) -> t.Callable[[T_template_filter], T_template_filter]:
+        """Register a template filter, available in any template rendered by the
+        application. Equivalent to :meth:`.Flask.template_filter`.
 
         :param name: the optional name of the filter, otherwise the
                      function name will be used.
         """
 
-        def decorator(f: TemplateFilterCallable) -> TemplateFilterCallable:
+        def decorator(f: T_template_filter) -> T_template_filter:
             self.add_app_template_filter(f, name=name)
             return f
 
         return decorator
 
+    @setupmethod
     def add_app_template_filter(
-        self, f: TemplateFilterCallable, name: t.Optional[str] = None
+        self, f: ft.TemplateFilterCallable, name: t.Optional[str] = None
     ) -> None:
-        """Register a custom template filter, available application wide.  Like
-        :meth:`Flask.add_template_filter` but for a blueprint.  Works exactly
-        like the :meth:`app_template_filter` decorator.
+        """Register a template filter, available in any template rendered by the
+        application. Works like the :meth:`app_template_filter` decorator. Equivalent to
+        :meth:`.Flask.add_template_filter`.
 
         :param name: the optional name of the filter, otherwise the
                      function name will be used.
@@ -449,11 +534,12 @@ class Blueprint(Scaffold):
 
         self.record_once(register_template)
 
+    @setupmethod
     def app_template_test(
         self, name: t.Optional[str] = None
-    ) -> t.Callable[[TemplateTestCallable], TemplateTestCallable]:
-        """Register a custom template test, available application wide.  Like
-        :meth:`Flask.template_test` but for a blueprint.
+    ) -> t.Callable[[T_template_test], T_template_test]:
+        """Register a template test, available in any template rendered by the
+        application. Equivalent to :meth:`.Flask.template_test`.
 
         .. versionadded:: 0.10
 
@@ -461,18 +547,19 @@ class Blueprint(Scaffold):
                      function name will be used.
         """
 
-        def decorator(f: TemplateTestCallable) -> TemplateTestCallable:
+        def decorator(f: T_template_test) -> T_template_test:
             self.add_app_template_test(f, name=name)
             return f
 
         return decorator
 
+    @setupmethod
     def add_app_template_test(
-        self, f: TemplateTestCallable, name: t.Optional[str] = None
+        self, f: ft.TemplateTestCallable, name: t.Optional[str] = None
     ) -> None:
-        """Register a custom template test, available application wide.  Like
-        :meth:`Flask.add_template_test` but for a blueprint.  Works exactly
-        like the :meth:`app_template_test` decorator.
+        """Register a template test, available in any template rendered by the
+        application. Works like the :meth:`app_template_test` decorator. Equivalent to
+        :meth:`.Flask.add_template_test`.
 
         .. versionadded:: 0.10
 
@@ -485,11 +572,12 @@ class Blueprint(Scaffold):
 
         self.record_once(register_template)
 
+    @setupmethod
     def app_template_global(
         self, name: t.Optional[str] = None
-    ) -> t.Callable[[TemplateGlobalCallable], TemplateGlobalCallable]:
-        """Register a custom template global, available application wide.  Like
-        :meth:`Flask.template_global` but for a blueprint.
+    ) -> t.Callable[[T_template_global], T_template_global]:
+        """Register a template global, available in any template rendered by the
+        application. Equivalent to :meth:`.Flask.template_global`.
 
         .. versionadded:: 0.10
 
@@ -497,18 +585,19 @@ class Blueprint(Scaffold):
                      function name will be used.
         """
 
-        def decorator(f: TemplateGlobalCallable) -> TemplateGlobalCallable:
+        def decorator(f: T_template_global) -> T_template_global:
             self.add_app_template_global(f, name=name)
             return f
 
         return decorator
 
+    @setupmethod
     def add_app_template_global(
-        self, f: TemplateGlobalCallable, name: t.Optional[str] = None
+        self, f: ft.TemplateGlobalCallable, name: t.Optional[str] = None
     ) -> None:
-        """Register a custom template global, available application wide.  Like
-        :meth:`Flask.add_template_global` but for a blueprint.  Works exactly
-        like the :meth:`app_template_global` decorator.
+        """Register a template global, available in any template rendered by the
+        application. Works like the :meth:`app_template_global` decorator. Equivalent to
+        :meth:`.Flask.add_template_global`.
 
         .. versionadded:: 0.10
 
@@ -521,76 +610,102 @@ class Blueprint(Scaffold):
 
         self.record_once(register_template)
 
-    def before_app_request(self, f: BeforeRequestCallable) -> BeforeRequestCallable:
-        """Like :meth:`Flask.before_request`.  Such a function is executed
-        before each request, even if outside of a blueprint.
+    @setupmethod
+    def before_app_request(self, f: T_before_request) -> T_before_request:
+        """Like :meth:`before_request`, but before every request, not only those handled
+        by the blueprint. Equivalent to :meth:`.Flask.before_request`.
         """
         self.record_once(
             lambda s: s.app.before_request_funcs.setdefault(None, []).append(f)
         )
         return f
 
+    @setupmethod
     def before_app_first_request(
-        self, f: BeforeFirstRequestCallable
-    ) -> BeforeFirstRequestCallable:
-        """Like :meth:`Flask.before_first_request`.  Such a function is
-        executed before the first request to the application.
+        self, f: T_before_first_request
+    ) -> T_before_first_request:
+        """Register a function to run before the first request to the application is
+        handled by the worker. Equivalent to :meth:`.Flask.before_first_request`.
+
+        .. deprecated:: 2.2
+            Will be removed in Flask 2.3. Run setup code when creating
+            the application instead.
         """
+        import warnings
+
+        warnings.warn(
+            "'before_app_first_request' is deprecated and will be"
+            " removed in Flask 2.3. Use 'record_once' instead to run"
+            " setup code when registering the blueprint.",
+            DeprecationWarning,
+            stacklevel=2,
+        )
         self.record_once(lambda s: s.app.before_first_request_funcs.append(f))
         return f
 
-    def after_app_request(self, f: AfterRequestCallable) -> AfterRequestCallable:
-        """Like :meth:`Flask.after_request` but for a blueprint.  Such a function
-        is executed after each request, even if outside of the blueprint.
+    @setupmethod
+    def after_app_request(self, f: T_after_request) -> T_after_request:
+        """Like :meth:`after_request`, but after every request, not only those handled
+        by the blueprint. Equivalent to :meth:`.Flask.after_request`.
         """
         self.record_once(
             lambda s: s.app.after_request_funcs.setdefault(None, []).append(f)
         )
         return f
 
-    def teardown_app_request(self, f: TeardownCallable) -> TeardownCallable:
-        """Like :meth:`Flask.teardown_request` but for a blueprint.  Such a
-        function is executed when tearing down each request, even if outside of
-        the blueprint.
+    @setupmethod
+    def teardown_app_request(self, f: T_teardown) -> T_teardown:
+        """Like :meth:`teardown_request`, but after every request, not only those
+        handled by the blueprint. Equivalent to :meth:`.Flask.teardown_request`.
         """
         self.record_once(
             lambda s: s.app.teardown_request_funcs.setdefault(None, []).append(f)
         )
         return f
 
+    @setupmethod
     def app_context_processor(
-        self, f: TemplateContextProcessorCallable
-    ) -> TemplateContextProcessorCallable:
-        """Like :meth:`Flask.context_processor` but for a blueprint.  Such a
-        function is executed each request, even if outside of the blueprint.
+        self, f: T_template_context_processor
+    ) -> T_template_context_processor:
+        """Like :meth:`context_processor`, but for templates rendered by every view, not
+        only by the blueprint. Equivalent to :meth:`.Flask.context_processor`.
         """
         self.record_once(
             lambda s: s.app.template_context_processors.setdefault(None, []).append(f)
         )
         return f
 
-    def app_errorhandler(self, code: t.Union[t.Type[Exception], int]) -> t.Callable:
-        """Like :meth:`Flask.errorhandler` but for a blueprint.  This
-        handler is used for all requests, even if outside of the blueprint.
+    @setupmethod
+    def app_errorhandler(
+        self, code: t.Union[t.Type[Exception], int]
+    ) -> t.Callable[[T_error_handler], T_error_handler]:
+        """Like :meth:`errorhandler`, but for every request, not only those handled by
+        the blueprint. Equivalent to :meth:`.Flask.errorhandler`.
         """
 
-        def decorator(f: "ErrorHandlerCallable") -> "ErrorHandlerCallable":
+        def decorator(f: T_error_handler) -> T_error_handler:
             self.record_once(lambda s: s.app.errorhandler(code)(f))
             return f
 
         return decorator
 
+    @setupmethod
     def app_url_value_preprocessor(
-        self, f: URLValuePreprocessorCallable
-    ) -> URLValuePreprocessorCallable:
-        """Same as :meth:`url_value_preprocessor` but application wide."""
+        self, f: T_url_value_preprocessor
+    ) -> T_url_value_preprocessor:
+        """Like :meth:`url_value_preprocessor`, but for every request, not only those
+        handled by the blueprint. Equivalent to :meth:`.Flask.url_value_preprocessor`.
+        """
         self.record_once(
             lambda s: s.app.url_value_preprocessors.setdefault(None, []).append(f)
         )
         return f
 
-    def app_url_defaults(self, f: URLDefaultCallable) -> URLDefaultCallable:
-        """Same as :meth:`url_defaults` but application wide."""
+    @setupmethod
+    def app_url_defaults(self, f: T_url_defaults) -> T_url_defaults:
+        """Like :meth:`url_defaults`, but for every request, not only those handled by
+        the blueprint. Equivalent to :meth:`.Flask.url_defaults`.
+        """
         self.record_once(
             lambda s: s.app.url_default_functions.setdefault(None, []).append(f)
         )
diff --git a/src/flask/cli.py b/src/flask/cli.py
index 36c4f1b6..37a15ff2 100644
--- a/src/flask/cli.py
+++ b/src/flask/cli.py
@@ -1,3 +1,5 @@
+from __future__ import annotations
+
 import ast
 import inspect
 import os
@@ -5,38 +7,22 @@ import platform
 import re
 import sys
 import traceback
+import typing as t
 from functools import update_wrapper
 from operator import attrgetter
-from threading import Lock
-from threading import Thread
 
 import click
+from click.core import ParameterSource
+from werkzeug import run_simple
+from werkzeug.serving import is_running_from_reloader
 from werkzeug.utils import import_string
 
 from .globals import current_app
 from .helpers import get_debug_flag
-from .helpers import get_env
 from .helpers import get_load_dotenv
 
-try:
-    import dotenv
-except ImportError:
-    dotenv = None
-
-try:
-    import ssl
-except ImportError:
-    ssl = None  # type: ignore
-
-if sys.version_info >= (3, 10):
-    from importlib import metadata
-else:
-    # Use a backport on Python < 3.10.
-    #
-    # We technically have importlib.metadata on 3.8+,
-    # but the API changed in 3.10, so use the backport
-    # for consistency.
-    import importlib_metadata as metadata  # type: ignore
+if t.TYPE_CHECKING:
+    from .app import Flask
 
 
 class NoAppException(click.UsageError):
@@ -64,8 +50,8 @@ def find_best_app(module):
     elif len(matches) > 1:
         raise NoAppException(
             "Detected multiple Flask applications in module"
-            f" {module.__name__!r}. Use 'FLASK_APP={module.__name__}:name'"
-            f" to specify the correct one."
+            f" '{module.__name__}'. Use '{module.__name__}:name'"
+            " to specify the correct one."
         )
 
     # Search for app factory functions.
@@ -83,15 +69,15 @@ def find_best_app(module):
                     raise
 
                 raise NoAppException(
-                    f"Detected factory {attr_name!r} in module {module.__name__!r},"
+                    f"Detected factory '{attr_name}' in module '{module.__name__}',"
                     " but could not call it without arguments. Use"
-                    f" \"FLASK_APP='{module.__name__}:{attr_name}(args)'\""
+                    f" '{module.__name__}:{attr_name}(args)'"
                     " to specify arguments."
                 ) from e
 
     raise NoAppException(
         "Failed to find Flask application or factory in module"
-        f" {module.__name__!r}. Use 'FLASK_APP={module.__name__}:name'"
+        f" '{module.__name__}'. Use '{module.__name__}:name'"
         " to specify one."
     )
 
@@ -228,8 +214,6 @@ def prepare_import(path):
 
 
 def locate_app(module_name, app_name, raise_if_not_found=True):
-    __traceback_hide__ = True  # noqa: F841
-
     try:
         __import__(module_name)
     except ImportError:
@@ -271,7 +255,7 @@ def get_version(ctx, param, value):
 
 version_option = click.Option(
     ["--version"],
-    help="Show the flask version",
+    help="Show the Flask version.",
     expose_value=False,
     callback=get_version,
     is_flag=True,
@@ -279,74 +263,6 @@ version_option = click.Option(
 )
 
 
-class DispatchingApp:
-    """Special application that dispatches to a Flask application which
-    is imported by name in a background thread.  If an error happens
-    it is recorded and shown as part of the WSGI handling which in case
-    of the Werkzeug debugger means that it shows up in the browser.
-    """
-
-    def __init__(self, loader, use_eager_loading=None):
-        self.loader = loader
-        self._app = None
-        self._lock = Lock()
-        self._bg_loading_exc = None
-
-        if use_eager_loading is None:
-            use_eager_loading = os.environ.get("WERKZEUG_RUN_MAIN") != "true"
-
-        if use_eager_loading:
-            self._load_unlocked()
-        else:
-            self._load_in_background()
-
-    def _load_in_background(self):
-        # Store the Click context and push it in the loader thread so
-        # script_info is still available.
-        ctx = click.get_current_context(silent=True)
-
-        def _load_app():
-            __traceback_hide__ = True  # noqa: F841
-
-            with self._lock:
-                if ctx is not None:
-                    click.globals.push_context(ctx)
-
-                try:
-                    self._load_unlocked()
-                except Exception as e:
-                    self._bg_loading_exc = e
-
-        t = Thread(target=_load_app, args=())
-        t.start()
-
-    def _flush_bg_loading_exception(self):
-        __traceback_hide__ = True  # noqa: F841
-        exc = self._bg_loading_exc
-
-        if exc is not None:
-            self._bg_loading_exc = None
-            raise exc
-
-    def _load_unlocked(self):
-        __traceback_hide__ = True  # noqa: F841
-        self._app = rv = self.loader()
-        self._bg_loading_exc = None
-        return rv
-
-    def __call__(self, environ, start_response):
-        __traceback_hide__ = True  # noqa: F841
-        if self._app is not None:
-            return self._app(environ, start_response)
-        self._flush_bg_loading_exception()
-        with self._lock:
-            if self._app is not None:
-                rv = self._app
-            else:
-                rv = self._load_unlocked()
-            return rv(environ, start_response)
-
-
 class ScriptInfo:
     """Helper object to deal with Flask applications.  This is usually not
     necessary to interface with as it's used internally in the dispatching
@@ -356,25 +272,28 @@ class ScriptInfo:
     onwards as click object.
     """
 
-    def __init__(self, app_import_path=None, create_app=None, set_debug_flag=True):
+    def __init__(
+        self,
+        app_import_path: str | None = None,
+        create_app: t.Callable[..., Flask] | None = None,
+        set_debug_flag: bool = True,
+    ) -> None:
         #: Optionally the import path for the Flask application.
-        self.app_import_path = app_import_path or os.environ.get("FLASK_APP")
+        self.app_import_path = app_import_path
         #: Optionally a function that is passed the script info to create
         #: the instance of the application.
         self.create_app = create_app
         #: A dictionary with arbitrary data that can be associated with
         #: this script info.
-        self.data = {}
+        self.data: t.Dict[t.Any, t.Any] = {}
         self.set_debug_flag = set_debug_flag
-        self._loaded_app = None
+        self._loaded_app: Flask | None = None
 
-    def load_app(self):
+    def load_app(self) -> Flask:
         """Loads the Flask app (if not yet loaded) and returns it.  Calling
         this multiple times will just result in the already loaded app to
         be returned.
         """
-        __traceback_hide__ = True  # noqa: F841
-
         if self._loaded_app is not None:
             return self._loaded_app
 
@@ -397,9 +316,10 @@ class ScriptInfo:
 
         if not app:
             raise NoAppException(
-                "Could not locate a Flask application. You did not provide "
-                'the "FLASK_APP" environment variable, and a "wsgi.py" or '
-                '"app.py" module was not found in the current directory.'
+                "Could not locate a Flask application. Use the"
+                " 'flask --app' option, 'FLASK_APP' environment"
+                " variable, or a 'wsgi.py' or 'app.py' file in the"
+                " current directory."
             )
 
         if self.set_debug_flag:
@@ -416,15 +336,25 @@ pass_script_info = click.make_pass_decorator(ScriptInfo, ensure=True)
 
 def with_appcontext(f):
     """Wraps a callback so that it's guaranteed to be executed with the
-    script's application context.  If callbacks are registered directly
-    to the ``app.cli`` object then they are wrapped with this function
-    by default unless it's disabled.
+    script's application context.
+
+    Custom commands (and their options) registered under ``app.cli`` or
+    ``blueprint.cli`` will always have an app context available, this
+    decorator is not required in that case.
+
+    .. versionchanged:: 2.2
+        The app context is active for subcommands as well as the
+        decorated callback. The app context is always available to
+        ``app.cli`` command and parameter callbacks.
     """
 
     @click.pass_context
     def decorator(__ctx, *args, **kwargs):
-        with __ctx.ensure_object(ScriptInfo).load_app().app_context():
-            return __ctx.invoke(f, *args, **kwargs)
+        if not current_app:
+            app = __ctx.ensure_object(ScriptInfo).load_app()
+            __ctx.with_resource(app.app_context())
+
+        return __ctx.invoke(f, *args, **kwargs)
 
     return update_wrapper(decorator, f)
 
@@ -460,6 +390,94 @@ class AppGroup(click.Group):
         return click.Group.group(self, *args, **kwargs)
 
 
+def _set_app(ctx: click.Context, param: click.Option, value: str | None) -> str | None:
+    if value is None:
+        return None
+
+    info = ctx.ensure_object(ScriptInfo)
+    info.app_import_path = value
+    return value
+
+
+# This option is eager so the app will be available if --help is given.
+# --help is also eager, so --app must be before it in the param list.
+# no_args_is_help bypasses eager processing, so this option must be
+# processed manually in that case to ensure FLASK_APP gets picked up.
+_app_option = click.Option(
+    ["-A", "--app"],
+    metavar="IMPORT",
+    help=(
+        "The Flask application or factory function to load, in the form 'module:name'."
+        " Module can be a dotted import or file path. Name is not required if it is"
+        " 'app', 'application', 'create_app', or 'make_app', and can be 'name(args)' to"
+        " pass arguments."
+    ),
+    is_eager=True,
+    expose_value=False,
+    callback=_set_app,
+)
+
+
+def _set_debug(ctx: click.Context, param: click.Option, value: bool) -> bool | None:
+    # If the flag isn't provided, it will default to False. Don't use
+    # that, let debug be set by env in that case.
+    source = ctx.get_parameter_source(param.name)  # type: ignore[arg-type]
+
+    if source is not None and source in (
+        ParameterSource.DEFAULT,
+        ParameterSource.DEFAULT_MAP,
+    ):
+        return None
+
+    # Set with env var instead of ScriptInfo.load so that it can be
+    # accessed early during a factory function.
+    os.environ["FLASK_DEBUG"] = "1" if value else "0"
+    return value
+
+
+_debug_option = click.Option(
+    ["--debug/--no-debug"],
+    help="Set debug mode.",
+    expose_value=False,
+    callback=_set_debug,
+)
+
+
+def _env_file_callback(
+    ctx: click.Context, param: click.Option, value: str | None
+) -> str | None:
+    if value is None:
+        return None
+
+    import importlib
+
+    try:
+        importlib.import_module("dotenv")
+    except ImportError:
+        raise click.BadParameter(
+            "python-dotenv must be installed to load an env file.",
+            ctx=ctx,
+            param=param,
+        ) from None
+
+    # Don't check FLASK_SKIP_DOTENV, that only disables automatically
+    # loading .env and .flaskenv files.
+    load_dotenv(value)
+    return value
+
+
+# This option is eager so env vars are loaded as early as possible to be
+# used by other options.
+_env_file_option = click.Option(
+    ["-e", "--env-file"],
+    type=click.Path(exists=True, dir_okay=False),
+    help="Load environment variables from this file. python-dotenv must be installed.",
+    is_eager=True,
+    expose_value=False,
+    callback=_env_file_callback,
+)
+
+
 class FlaskGroup(AppGroup):
     """Special subclass of the :class:`AppGroup` group that supports
     loading more commands from the configured Flask app.  Normally a
@@ -475,8 +493,14 @@ class FlaskGroup(AppGroup):
     :param load_dotenv: Load the nearest :file:`.env` and :file:`.flaskenv`
         files to set environment variables. Will also change the working
         directory to the directory containing the first file found.
-    :param set_debug_flag: Set the app's debug flag based on the active
-        environment
+    :param set_debug_flag: Set the app's debug flag.
+
+    .. versionchanged:: 2.2
+        Added the ``-A/--app``, ``--debug/--no-debug``, ``-e/--env-file`` options.
+
+    .. versionchanged:: 2.2
+        An app context is pushed when running ``app.cli`` commands, so
+        ``@with_appcontext`` is no longer required for those commands.
 
     .. versionchanged:: 1.0
         If installed, python-dotenv will be used to load environment variables
@@ -485,19 +509,30 @@ class FlaskGroup(AppGroup):
 
     def __init__(
         self,
-        add_default_commands=True,
-        create_app=None,
-        add_version_option=True,
-        load_dotenv=True,
-        set_debug_flag=True,
-        **extra,
-    ):
+        add_default_commands: bool = True,
+        create_app: t.Callable[..., Flask] | None = None,
+        add_version_option: bool = True,
+        load_dotenv: bool = True,
+        set_debug_flag: bool = True,
+        **extra: t.Any,
+    ) -> None:
         params = list(extra.pop("params", None) or ())
+        # Processing is done with option callbacks instead of a group
+        # callback. This allows users to make a custom group callback
+        # without losing the behavior. --env-file must come first so
+        # that it is eagerly evaluated before --app.
+        params.extend((_env_file_option, _app_option, _debug_option))
 
         if add_version_option:
             params.append(version_option)
 
-        AppGroup.__init__(self, params=params, **extra)
+        if "context_settings" not in extra:
+            extra["context_settings"] = {}
+
+        extra["context_settings"].setdefault("auto_envvar_prefix", "FLASK")
+
+        super().__init__(params=params, **extra)
+
         self.create_app = create_app
         self.load_dotenv = load_dotenv
         self.set_debug_flag = set_debug_flag
@@ -513,6 +548,14 @@ class FlaskGroup(AppGroup):
         if self._loaded_plugin_commands:
             return
 
+        if sys.version_info >= (3, 10):
+            from importlib import metadata
+        else:
+            # Use a backport on Python < 3.10. We technically have
+            # importlib.metadata on 3.8+, but the API changed in 3.10,
+            # so use the backport for consistency.
+            import importlib_metadata as metadata
+
         for ep in metadata.entry_points(group="flask.commands"):
             self.add_command(ep.load(), ep.name)
 
@@ -532,9 +575,18 @@ class FlaskGroup(AppGroup):
         # Look up commands provided by the app, showing an error and
         # continuing if the app couldn't be loaded.
         try:
-            return info.load_app().cli.get_command(ctx, name)
+            app = info.load_app()
         except NoAppException as e:
             click.secho(f"Error: {e.format_message()}\n", err=True, fg="red")
+            return None
+
+        # Push an app context for the loaded app unless it is already
+        # active somehow. This makes the context available to parameter
+        # and command callbacks without needing @with_appcontext.
+        if not current_app or current_app._get_current_object() is not app:
+            ctx.with_resource(app.app_context())
+
+        return app.cli.get_command(ctx, name)
 
     def list_commands(self, ctx):
         self._load_plugin_commands()
@@ -557,26 +609,39 @@ class FlaskGroup(AppGroup):
 
         return sorted(rv)
 
-    def main(self, *args, **kwargs):
-        # Set a global flag that indicates that we were invoked from the
-        # command line interface. This is detected by Flask.run to make the
-        # call into a no-op. This is necessary to avoid ugly errors when the
-        # script that is loaded here also attempts to start a server.
+    def make_context(
+        self,
+        info_name: str | None,
+        args: list[str],
+        parent: click.Context | None = None,
+        **extra: t.Any,
+    ) -> click.Context:
+        # Set a flag to tell app.run to become a no-op. If app.run was
+        # not in a __name__ == __main__ guard, it would start the server
+        # when importing, blocking whatever command is being called.
         os.environ["FLASK_RUN_FROM_CLI"] = "true"
 
+        # Attempt to load .env and .flask env files. The --env-file
+        # option can cause another file to be loaded.
         if get_load_dotenv(self.load_dotenv):
             load_dotenv()
 
-        obj = kwargs.get("obj")
-
-        if obj is None:
-            obj = ScriptInfo(
+        if "obj" not in extra and "obj" not in self.context_settings:
+            extra["obj"] = ScriptInfo(
                 create_app=self.create_app, set_debug_flag=self.set_debug_flag
             )
 
-        kwargs["obj"] = obj
-        kwargs.setdefault("auto_envvar_prefix", "FLASK")
-        return super().main(*args, **kwargs)
+        return super().make_context(info_name, args, parent=parent, **extra)
+
+    def parse_args(self, ctx: click.Context, args: list[str]) -> list[str]:
+        if not args and self.no_args_is_help:
+            # Attempt to load --env-file and --app early in case they
+            # were given as env vars. Otherwise no_args_is_help will not
+            # see commands from app.cli.
+            _env_file_option.handle_parse_result(ctx, {}, [])
+            _app_option.handle_parse_result(ctx, {}, [])
+
+        return super().parse_args(ctx, args)
 
 
 def _path_is_ancestor(path, other):
@@ -586,7 +651,7 @@ def _path_is_ancestor(path, other):
     return os.path.join(path, other[len(path) :].lstrip(os.sep)) == other
 
 
-def load_dotenv(path=None):
+def load_dotenv(path: str | os.PathLike | None = None) -> bool:
     """Load "dotenv" files in order of precedence to set environment variables.
 
     If an env var is already set it is not overwritten, so earlier files in the
@@ -599,16 +664,22 @@ def load_dotenv(path=None):
     :param path: Load the file at this location instead of searching.
     :return: ``True`` if a file was loaded.
 
-    .. versionchanged:: 1.1.0
-        Returns ``False`` when python-dotenv is not installed, or when
-        the given path isn't a file.
+    .. versionchanged:: 2.0
+        The current directory is not changed to the location of the
+        loaded file.
 
     .. versionchanged:: 2.0
         When loading the env files, set the default encoding to UTF-8.
 
+    .. versionchanged:: 1.1.0
+        Returns ``False`` when python-dotenv is not installed, or when
+        the given path isn't a file.
+
     .. versionadded:: 1.0
     """
-    if dotenv is None:
+    try:
+        import dotenv
+    except ImportError:
         if path or os.path.isfile(".env") or os.path.isfile(".flaskenv"):
             click.secho(
                 " * Tip: There are .env or .flaskenv files present."
@@ -619,15 +690,15 @@ def load_dotenv(path=None):
 
         return False
 
-    # if the given path specifies the actual file then return True,
-    # else False
+    # Always return after attempting to load a given path, don't load
+    # the default files.
     if path is not None:
         if os.path.isfile(path):
             return dotenv.load_dotenv(path, encoding="utf-8")
 
         return False
 
-    new_dir = None
+    loaded = False
 
     for name in (".env", ".flaskenv"):
         path = dotenv.find_dotenv(name, usecwd=True)
@@ -635,38 +706,21 @@ def load_dotenv(path=None):
         if not path:
             continue
 
-        if new_dir is None:
-            new_dir = os.path.dirname(path)
-
         dotenv.load_dotenv(path, encoding="utf-8")
+        loaded = True
 
-    return new_dir is not None  # at least one file was located and loaded
+    return loaded  # True if at least one file was located and loaded.
 
 
-def show_server_banner(env, debug, app_import_path, eager_loading):
+def show_server_banner(debug, app_import_path):
     """Show extra startup messages the first time the server is run,
     ignoring the reloader.
     """
-    if os.environ.get("WERKZEUG_RUN_MAIN") == "true":
+    if is_running_from_reloader():
         return
 
     if app_import_path is not None:
-        message = f" * Serving Flask app {app_import_path!r}"
-
-        if not eager_loading:
-            message += " (lazy loading)"
-
-        click.echo(message)
-
-    click.echo(f" * Environment: {env}")
-
-    if env == "production":
-        click.secho(
-            "   WARNING: This is a development server. Do not use it in"
-            " a production deployment.",
-            fg="red",
-        )
-        click.secho("   Use a production WSGI server instead.", dim=True)
+        click.echo(f" * Serving Flask app '{app_import_path}'")
 
     if debug is not None:
         click.echo(f" * Debug mode: {'on' if debug else 'off'}")
@@ -684,12 +738,14 @@ class CertParamType(click.ParamType):
         self.path_type = click.Path(exists=True, dir_okay=False, resolve_path=True)
 
     def convert(self, value, param, ctx):
-        if ssl is None:
+        try:
+            import ssl
+        except ImportError:
             raise click.BadParameter(
                 'Using "--cert" requires Python to be compiled with SSL support.',
                 ctx,
                 param,
-            )
+            ) from None
 
         try:
             return self.path_type(value, param, ctx)
@@ -722,7 +778,13 @@ def _validate_key(ctx, param, value):
     """
     cert = ctx.params.get("cert")
     is_adhoc = cert == "adhoc"
-    is_context = ssl and isinstance(cert, ssl.SSLContext)
+
+    try:
+        import ssl
+    except ImportError:
+        is_context = False
+    else:
+        is_context = isinstance(cert, ssl.SSLContext)
 
     if value is not None:
         if is_adhoc:
@@ -787,12 +849,6 @@ class SeparatedPathType(click.Path):
     help="Enable or disable the debugger. By default the debugger "
     "is active if debug is enabled.",
 )
-@click.option(
-    "--eager-loading/--lazy-loading",
-    default=None,
-    help="Enable or disable eager loading. By default eager "
-    "loading is enabled if the reloader is disabled.",
-)
 @click.option(
     "--with-threads/--without-threads",
     default=True,
@@ -824,7 +880,6 @@ def run_command(
     port,
     reload,
     debugger,
-    eager_loading,
     with_threads,
     cert,
     extra_files,
@@ -835,9 +890,26 @@ def run_command(
     This server is for development purposes only. It does not provide
     the stability, security, or performance of production WSGI servers.
 
-    The reloader and debugger are enabled by default if
-    FLASK_ENV=development or FLASK_DEBUG=1.
+    The reloader and debugger are enabled by default with the '--debug'
+    option.
     """
+    try:
+        app = info.load_app()
+    except Exception as e:
+        if is_running_from_reloader():
+            # When reloading, print out the error immediately, but raise
+            # it later so the debugger or server can handle it.
+            traceback.print_exc()
+            err = e
+
+            def app(environ, start_response):
+                raise err from None
+
+        else:
+            # When not reloading, raise the error immediately so the
+            # command fails.
+            raise e from None
+
     debug = get_debug_flag()
 
     if reload is None:
@@ -846,10 +918,7 @@ def run_command(
     if debugger is None:
         debugger = debug
 
-    show_server_banner(get_env(), debug, info.app_import_path, eager_loading)
-    app = DispatchingApp(info.load_app, use_eager_loading=eager_loading)
-
-    from werkzeug.serving import run_simple
+    show_server_banner(debug, info.app_import_path)
 
     run_simple(
         host,
@@ -864,6 +933,9 @@ def run_command(
     )
 
 
+run_command.params.insert(0, _debug_option)
+
+
 @click.command("shell", short_help="Run a shell in the app context.")
 @with_appcontext
 def shell_command() -> None:
@@ -875,13 +947,11 @@ def shell_command() -> None:
     without having to manually configure the application.
     """
     import code
-    from .globals import _app_ctx_stack
 
-    app = _app_ctx_stack.top.app
     banner = (
         f"Python {sys.version} on {sys.platform}\n"
-        f"App: {app.import_name} [{app.env}]\n"
-        f"Instance: {app.instance_path}"
+        f"App: {current_app.import_name}\n"
+        f"Instance: {current_app.instance_path}"
     )
     ctx: dict = {}
 
@@ -892,7 +962,7 @@ def shell_command() -> None:
         with open(startup) as f:
             eval(compile(f.read(), startup, "exec"), ctx)
 
-    ctx.update(app.make_shell_context())
+    ctx.update(current_app.make_shell_context())
 
     # Site, customize, or startup script can set a hook to call when
     # entering interactive mode. The default one sets up readline with
@@ -965,22 +1035,14 @@ def routes_command(sort: str, all_methods: bool) -> None:
 
 
 cli = FlaskGroup(
+    name="flask",
     help="""\
 A general utility script for Flask applications.
 
-Provides commands from Flask, extensions, and the application. Loads the
-application defined in the FLASK_APP environment variable, or from a wsgi.py
-file. Setting the FLASK_ENV environment variable to 'development' will enable
-debug mode.
-
-\b
-  {prefix}{cmd} FLASK_APP=hello.py
-  {prefix}{cmd} FLASK_ENV=development
-  {prefix}flask run
-""".format(
-        cmd="export" if os.name == "posix" else "set",
-        prefix="$ " if os.name == "posix" else "> ",
-    )
+An application to load must be given with the '--app' option,
+'FLASK_APP' environment variable, or with a 'wsgi.py' or 'app.py' file
+in the current directory.
+""",
 )
 
 
diff --git a/src/flask/config.py b/src/flask/config.py
index 7b6a137a..d4fc310f 100644
--- a/src/flask/config.py
+++ b/src/flask/config.py
@@ -275,8 +275,9 @@ class Config(dict):
     def from_mapping(
         self, mapping: t.Optional[t.Mapping[str, t.Any]] = None, **kwargs: t.Any
     ) -> bool:
-        """Updates the config like :meth:`update` ignoring items with non-upper
-        keys.
+        """Updates the config like :meth:`update` ignoring items with
+        non-upper keys.
+
         :return: Always returns ``True``.
 
         .. versionadded:: 0.11
diff --git a/src/flask/ctx.py b/src/flask/ctx.py
index 3ed8fd3a..c79c26dc 100644
--- a/src/flask/ctx.py
+++ b/src/flask/ctx.py
@@ -1,3 +1,4 @@
+import contextvars
 import sys
 import typing as t
 from functools import update_wrapper
@@ -5,13 +6,13 @@ from types import TracebackType
 
 from werkzeug.exceptions import HTTPException
 
-from .globals import _app_ctx_stack
-from .globals import _request_ctx_stack
+from . import typing as ft
+from .globals import _cv_app
+from .globals import _cv_request
 from .signals import appcontext_popped
 from .signals import appcontext_pushed
-from .typing import AfterRequestCallable
 
-if t.TYPE_CHECKING:
+if t.TYPE_CHECKING:  # pragma: no cover
     from .app import Flask
     from .sessions import SessionMixin
     from .wrappers import Request
@@ -103,13 +104,13 @@ class _AppCtxGlobals:
         return iter(self.__dict__)
 
     def __repr__(self) -> str:
-        top = _app_ctx_stack.top
-        if top is not None:
-            return f"<flask.g of {top.app.name!r}>"
+        ctx = _cv_app.get(None)
+        if ctx is not None:
+            return f"<flask.g of '{ctx.app.name}'>"
         return object.__repr__(self)
 
 
-def after_this_request(f: AfterRequestCallable) -> AfterRequestCallable:
+def after_this_request(f: ft.AfterRequestCallable) -> ft.AfterRequestCallable:
     """Executes a function after this request.  This is useful to modify
     response objects.  The function is passed the response object and has
     to return the same or a new one.
@@ -130,15 +131,15 @@ def after_this_request(f: AfterRequestCallable) -> AfterRequestCallable:
 
     .. versionadded:: 0.9
     """
-    top = _request_ctx_stack.top
+    ctx = _cv_request.get(None)
 
-    if top is None:
+    if ctx is None:
         raise RuntimeError(
-            "This decorator can only be used when a request context is"
-            " active, such as within a view function."
+            "'after_this_request' can only be used when a request"
+            " context is active, such as in a view function."
         )
 
-    top._after_request_functions.append(f)
+    ctx._after_request_functions.append(f)
     return f
 
 
@@ -166,19 +167,19 @@ def copy_current_request_context(f: t.Callable) -> t.Callable:
 
     .. versionadded:: 0.10
     """
-    top = _request_ctx_stack.top
+    ctx = _cv_request.get(None)
 
-    if top is None:
+    if ctx is None:
         raise RuntimeError(
-            "This decorator can only be used when a request context is"
-            " active, such as within a view function."
+            "'copy_current_request_context' can only be used when a"
+            " request context is active, such as in a view function."
         )
 
-    reqctx = top.copy()
+    ctx = ctx.copy()
 
     def wrapper(*args, **kwargs):
-        with reqctx:
-            return reqctx.app.ensure_sync(f)(*args, **kwargs)
+        with ctx:
+            return ctx.app.ensure_sync(f)(*args, **kwargs)
 
     return update_wrapper(wrapper, f)
 
@@ -212,7 +213,7 @@ def has_request_context() -> bool:
 
     .. versionadded:: 0.7
     """
-    return _request_ctx_stack.top is not None
+    return _cv_request.get(None) is not None
 
 
 def has_app_context() -> bool:
@@ -222,44 +223,43 @@ def has_app_context() -> bool:
 
     .. versionadded:: 0.9
     """
-    return _app_ctx_stack.top is not None
+    return _cv_app.get(None) is not None
 
 
 class AppContext:
-    """The application context binds an application object implicitly
-    to the current thread or greenlet, similar to how the
-    :class:`RequestContext` binds request information.  The application
-    context is also implicitly created if a request context is created
-    but the application is not on top of the individual application
-    context.
+    """The app context contains application-specific information. An app
+    context is created and pushed at the beginning of each request if
+    one is not already active. An app context is also pushed when
+    running CLI commands.
     """
 
     def __init__(self, app: "Flask") -> None:
         self.app = app
         self.url_adapter = app.create_url_adapter(None)
-        self.g = app.app_ctx_globals_class()
-
-        # Like request context, app contexts can be pushed multiple times
-        # but there a basic "refcount" is enough to track them.
-        self._refcnt = 0
+        self.g: _AppCtxGlobals = app.app_ctx_globals_class()
+        self._cv_tokens: t.List[contextvars.Token] = []
 
     def push(self) -> None:
         """Binds the app context to the current context."""
-        self._refcnt += 1
-        _app_ctx_stack.push(self)
+        self._cv_tokens.append(_cv_app.set(self))
         appcontext_pushed.send(self.app)
 
     def pop(self, exc: t.Optional[BaseException] = _sentinel) -> None:  # type: ignore
         """Pops the app context."""
         try:
-            self._refcnt -= 1
-            if self._refcnt <= 0:
+            if len(self._cv_tokens) == 1:
                 if exc is _sentinel:
                     exc = sys.exc_info()[1]
                 self.app.do_teardown_appcontext(exc)
         finally:
-            rv = _app_ctx_stack.pop()
-        assert rv is self, f"Popped wrong app context.  ({rv!r} instead of {self!r})"
+            ctx = _cv_app.get()
+            _cv_app.reset(self._cv_tokens.pop())
+
+        if ctx is not self:
+            raise AssertionError(
+                f"Popped wrong app context. ({ctx!r} instead of {self!r})"
+            )
+
         appcontext_popped.send(self.app)
 
     def __enter__(self) -> "AppContext":
@@ -276,10 +276,10 @@ class AppContext:
 
 
 class RequestContext:
-    """The request context contains all request relevant information.  It is
-    created at the beginning of the request and pushed to the
-    `_request_ctx_stack` and removed at the end of it.  It will create the
-    URL adapter and request object for the WSGI environment provided.
+    """The request context contains per-request information. The Flask
+    app creates and pushes it at the beginning of the request, then pops
+    it at the end of the request. It will create the URL adapter and
+    request object for the WSGI environment provided.
 
     Do not attempt to use this class directly, instead use
     :meth:`~flask.Flask.test_request_context` and
@@ -289,20 +289,12 @@ class RequestContext:
     functions registered on the application for teardown execution
     (:meth:`~flask.Flask.teardown_request`).
 
-    The request context is automatically popped at the end of the request
-    for you.  In debug mode the request context is kept around if
-    exceptions happen so that interactive debuggers have a chance to
-    introspect the data.  With 0.4 this can also be forced for requests
-    that did not fail and outside of ``DEBUG`` mode.  By setting
-    ``'flask._preserve_context'`` to ``True`` on the WSGI environment the
-    context will not pop itself at the end of the request.  This is used by
-    the :meth:`~flask.Flask.test_client` for example to implement the
-    deferred cleanup functionality.
-
-    You might find this helpful for unittests where you need the
-    information from the context local around for a little longer.  Make
-    sure to properly :meth:`~werkzeug.LocalStack.pop` the stack yourself in
-    that situation, otherwise your unittests will leak memory.
+    The request context is automatically popped at the end of the
+    request. When using the interactive debugger, the context will be
+    restored so ``request`` is still accessible. Similarly, the test
+    client can preserve the context after the request ends. However,
+    teardown functions may already have closed some resources such as
+    database connections.
     """
 
     def __init__(
@@ -315,59 +307,21 @@ class RequestContext:
         self.app = app
         if request is None:
             request = app.request_class(environ)
-        self.request = request
+            request.json_module = app.json
+        self.request: Request = request
         self.url_adapter = None
         try:
             self.url_adapter = app.create_url_adapter(self.request)
         except HTTPException as e:
             self.request.routing_exception = e
-        self.flashes = None
-        self.session = session
-
-        # Request contexts can be pushed multiple times and interleaved with
-        # other request contexts.  Now only if the last level is popped we
-        # get rid of them.  Additionally if an application context is missing
-        # one is created implicitly so for each level we add this information
-        self._implicit_app_ctx_stack: t.List[t.Optional["AppContext"]] = []
-
-        # indicator if the context was preserved.  Next time another context
-        # is pushed the preserved context is popped.
-        self.preserved = False
-
-        # remembers the exception for pop if there is one in case the context
-        # preservation kicks in.
-        self._preserved_exc = None
-
+        self.flashes: t.Optional[t.List[t.Tuple[str, str]]] = None
+        self.session: t.Optional["SessionMixin"] = session
         # Functions that should be executed after the request on the response
         # object.  These will be called before the regular "after_request"
         # functions.
-        self._after_request_functions: t.List[AfterRequestCallable] = []
-
-    @property
-    def g(self) -> _AppCtxGlobals:
-        import warnings
-
-        warnings.warn(
-            "Accessing 'g' on the request context is deprecated and"
-            " will be removed in Flask 2.2. Access `g` directly or from"
-            "the application context instead.",
-            DeprecationWarning,
-            stacklevel=2,
-        )
-        return _app_ctx_stack.top.g
-
-    @g.setter
-    def g(self, value: _AppCtxGlobals) -> None:
-        import warnings
-
-        warnings.warn(
-            "Setting 'g' on the request context is deprecated and"
-            " will be removed in Flask 2.2. Set it on the application"
-            " context instead.",
-            DeprecationWarning,
-            stacklevel=2,
-        )
-        _app_ctx_stack.top.g = value
+        self._after_request_functions: t.List[ft.AfterRequestCallable] = []
+
+        self._cv_tokens: t.List[t.Tuple[contextvars.Token, t.Optional[AppContext]]] = []
 
     def copy(self) -> "RequestContext":
         """Creates a copy of this request context with the same request object.
@@ -400,30 +354,17 @@ class RequestContext:
             self.request.routing_exception = e
 
     def push(self) -> None:
-        """Binds the request context to the current context."""
-        # If an exception occurs in debug mode or if context preservation is
-        # activated under exception situations exactly one context stays
-        # on the stack.  The rationale is that you want to access that
-        # information under debug situations.  However if someone forgets to
-        # pop that context again we want to make sure that on the next push
-        # it's invalidated, otherwise we run at risk that something leaks
-        # memory.  This is usually only a problem in test suite since this
-        # functionality is not active in production environments.
-        top = _request_ctx_stack.top
-        if top is not None and top.preserved:
-            top.pop(top._preserved_exc)
-
         # Before we push the request context we have to ensure that there
         # is an application context.
-        app_ctx = _app_ctx_stack.top
-        if app_ctx is None or app_ctx.app != self.app:
+        app_ctx = _cv_app.get(None)
+
+        if app_ctx is None or app_ctx.app is not self.app:
             app_ctx = self.app.app_context()
             app_ctx.push()
-            self._implicit_app_ctx_stack.append(app_ctx)
         else:
-            self._implicit_app_ctx_stack.append(None)
+            app_ctx = None
 
-        _request_ctx_stack.push(self)
+        self._cv_tokens.append((_cv_request.set(self), app_ctx))
 
         # Open the session at the moment that the request context is available.
         # This allows a custom open_session method to use the request context.
@@ -449,13 +390,10 @@ class RequestContext:
         .. versionchanged:: 0.9
            Added the `exc` argument.
         """
-        app_ctx = self._implicit_app_ctx_stack.pop()
-        clear_request = False
+        clear_request = len(self._cv_tokens) == 1
 
         try:
-            if not self._implicit_app_ctx_stack:
-                self.preserved = False
-                self._preserved_exc = None
+            if clear_request:
                 if exc is _sentinel:
                     exc = sys.exc_info()[1]
                 self.app.do_teardown_request(exc)
@@ -463,31 +401,23 @@ class RequestContext:
                 request_close = getattr(self.request, "close", None)
                 if request_close is not None:
                     request_close()
-                clear_request = True
         finally:
-            rv = _request_ctx_stack.pop()
+            ctx = _cv_request.get()
+            token, app_ctx = self._cv_tokens.pop()
+            _cv_request.reset(token)
 
             # get rid of circular dependencies at the end of the request
             # so that we don't require the GC to be active.
             if clear_request:
-                rv.request.environ["werkzeug.request"] = None
+                ctx.request.environ["werkzeug.request"] = None
 
-            # Get rid of the app as well if necessary.
             if app_ctx is not None:
                 app_ctx.pop(exc)
 
-            assert (
-                rv is self
-            ), f"Popped wrong request context. ({rv!r} instead of {self!r})"
-
-    def auto_pop(self, exc: t.Optional[BaseException]) -> None:
-        if self.request.environ.get("flask._preserve_context") or (
-            exc is not None and self.app.preserve_context_on_exception
-        ):
-            self.preserved = True
-            self._preserved_exc = exc  # type: ignore
-        else:
-            self.pop(exc)
+            if ctx is not self:
+                raise AssertionError(
+                    f"Popped wrong request context. ({ctx!r} instead of {self!r})"
+                )
 
     def __enter__(self) -> "RequestContext":
         self.push()
@@ -499,12 +429,7 @@ class RequestContext:
         exc_value: t.Optional[BaseException],
         tb: t.Optional[TracebackType],
     ) -> None:
-        # do not pop the request stack if we are in debug mode and an
-        # exception happened.  This will allow the debugger to still
-        # access the request object in the interactive shell.  Furthermore
-        # the context can be force kept alive for the test client.
-        # See flask.testing for how this works.
-        self.auto_pop(exc_value)
+        self.pop(exc_value)
 
     def __repr__(self) -> str:
         return (
diff --git a/src/flask/debughelpers.py b/src/flask/debughelpers.py
index 27d378c2..b0639892 100644
--- a/src/flask/debughelpers.py
+++ b/src/flask/debughelpers.py
@@ -1,10 +1,8 @@
-import os
 import typing as t
-from warnings import warn
 
 from .app import Flask
 from .blueprints import Blueprint
-from .globals import _request_ctx_stack
+from .globals import request_ctx
 
 
 class UnexpectedUnicodeError(AssertionError, UnicodeError):
@@ -118,9 +116,8 @@ def explain_template_loading_attempts(app: Flask, template, attempts) -> None:
     info = [f"Locating template {template!r}:"]
     total_found = 0
     blueprint = None
-    reqctx = _request_ctx_stack.top
-    if reqctx is not None and reqctx.request.blueprint is not None:
-        blueprint = reqctx.request.blueprint
+    if request_ctx and request_ctx.request.blueprint is not None:
+        blueprint = request_ctx.request.blueprint
 
     for idx, (loader, srcobj, triple) in enumerate(attempts):
         if isinstance(srcobj, Flask):
@@ -159,16 +156,3 @@ def explain_template_loading_attempts(app: Flask, template, attempts) -> None:
         info.append("  See https://flask.palletsprojects.com/blueprints/#templates")
 
     app.logger.info("\n".join(info))
-
-
-def explain_ignored_app_run() -> None:
-    if os.environ.get("WERKZEUG_RUN_MAIN") != "true":
-        warn(
-            Warning(
-                "Silently ignoring app.run() because the application is"
-                " run from the flask command line executable. Consider"
-                ' putting app.run() behind an if __name__ == "__main__"'
-                " guard to silence this warning."
-            ),
-            stacklevel=3,
-        )
diff --git a/src/flask/globals.py b/src/flask/globals.py
index 6d91c75e..254da42b 100644
--- a/src/flask/globals.py
+++ b/src/flask/globals.py
@@ -1,59 +1,107 @@
 import typing as t
-from functools import partial
+from contextvars import ContextVar
 
 from werkzeug.local import LocalProxy
-from werkzeug.local import LocalStack
 
-if t.TYPE_CHECKING:
+if t.TYPE_CHECKING:  # pragma: no cover
     from .app import Flask
     from .ctx import _AppCtxGlobals
+    from .ctx import AppContext
+    from .ctx import RequestContext
     from .sessions import SessionMixin
     from .wrappers import Request
 
-_request_ctx_err_msg = """\
-Working outside of request context.
 
-This typically means that you attempted to use functionality that needed
-an active HTTP request.  Consult the documentation on testing for
-information about how to avoid this problem.\
-"""
-_app_ctx_err_msg = """\
+class _FakeStack:
+    def __init__(self, name: str, cv: ContextVar[t.Any]) -> None:
+        self.name = name
+        self.cv = cv
+
+    def _warn(self):
+        import warnings
+
+        warnings.warn(
+            f"'_{self.name}_ctx_stack' is deprecated and will be"
+            " removed in Flask 2.3. Use 'g' to store data, or"
+            f" '{self.name}_ctx' to access the current context.",
+            DeprecationWarning,
+            stacklevel=3,
+        )
+
+    def push(self, obj: t.Any) -> None:
+        self._warn()
+        self.cv.set(obj)
+
+    def pop(self) -> t.Any:
+        self._warn()
+        ctx = self.cv.get(None)
+        self.cv.set(None)
+        return ctx
+
+    @property
+    def top(self) -> t.Optional[t.Any]:
+        self._warn()
+        return self.cv.get(None)
+
+
+_no_app_msg = """\
 Working outside of application context.
 
 This typically means that you attempted to use functionality that needed
-to interface with the current application object in some way. To solve
-this, set up an application context with app.app_context().  See the
-documentation for more information.\
+the current application. To solve this, set up an application context
+with app.app_context(). See the documentation for more information.\
 """
+_cv_app: ContextVar["AppContext"] = ContextVar("flask.app_ctx")
+__app_ctx_stack = _FakeStack("app", _cv_app)
+app_ctx: "AppContext" = LocalProxy(  # type: ignore[assignment]
+    _cv_app, unbound_message=_no_app_msg
+)
+current_app: "Flask" = LocalProxy(  # type: ignore[assignment]
+    _cv_app, "app", unbound_message=_no_app_msg
+)
+g: "_AppCtxGlobals" = LocalProxy(  # type: ignore[assignment]
+    _cv_app, "g", unbound_message=_no_app_msg
+)
 
+_no_req_msg = """\
+Working outside of request context.
 
-def _lookup_req_object(name):
-    top = _request_ctx_stack.top
-    if top is None:
-        raise RuntimeError(_request_ctx_err_msg)
-    return getattr(top, name)
+This typically means that you attempted to use functionality that needed
+an active HTTP request. Consult the documentation on testing for
+information about how to avoid this problem.\
+"""
+_cv_request: ContextVar["RequestContext"] = ContextVar("flask.request_ctx")
+__request_ctx_stack = _FakeStack("request", _cv_request)
+request_ctx: "RequestContext" = LocalProxy(  # type: ignore[assignment]
+    _cv_request, unbound_message=_no_req_msg
+)
+request: "Request" = LocalProxy(  # type: ignore[assignment]
+    _cv_request, "request", unbound_message=_no_req_msg
+)
+session: "SessionMixin" = LocalProxy(  # type: ignore[assignment]
+    _cv_request, "session", unbound_message=_no_req_msg
+)
 
 
-def _lookup_app_object(name):
-    top = _app_ctx_stack.top
-    if top is None:
-        raise RuntimeError(_app_ctx_err_msg)
-    return getattr(top, name)
+def __getattr__(name: str) -> t.Any:
+    if name == "_app_ctx_stack":
+        import warnings
 
+        warnings.warn(
+            "'_app_ctx_stack' is deprecated and will be removed in Flask 2.3.",
+            DeprecationWarning,
+            stacklevel=2,
+        )
+        return __app_ctx_stack
 
-def _find_app():
-    top = _app_ctx_stack.top
-    if top is None:
-        raise RuntimeError(_app_ctx_err_msg)
-    return top.app
+    if name == "_request_ctx_stack":
+        import warnings
 
+        warnings.warn(
+            "'_request_ctx_stack' is deprecated and will be removed in Flask 2.3.",
+            DeprecationWarning,
+            stacklevel=2,
+        )
+        return __request_ctx_stack
 
-# context locals
-_request_ctx_stack = LocalStack()
-_app_ctx_stack = LocalStack()
-current_app: "Flask" = LocalProxy(_find_app)  # type: ignore
-request: "Request" = LocalProxy(partial(_lookup_req_object, "request"))  # type: ignore
-session: "SessionMixin" = LocalProxy(  # type: ignore
-    partial(_lookup_req_object, "session")
-)
-g: "_AppCtxGlobals" = LocalProxy(partial(_lookup_app_object, "g"))  # type: ignore
+    raise AttributeError(name)
diff --git a/src/flask/helpers.py b/src/flask/helpers.py
index fe47500e..3833cb8a 100644
--- a/src/flask/helpers.py
+++ b/src/flask/helpers.py
@@ -3,53 +3,73 @@ import pkgutil
 import socket
 import sys
 import typing as t
-import warnings
 from datetime import datetime
 from functools import lru_cache
 from functools import update_wrapper
 from threading import RLock
 
 import werkzeug.utils
-from werkzeug.routing import BuildError
-from werkzeug.urls import url_quote
+from werkzeug.exceptions import abort as _wz_abort
+from werkzeug.utils import redirect as _wz_redirect
 
-from .globals import _app_ctx_stack
-from .globals import _request_ctx_stack
+from .globals import _cv_request
 from .globals import current_app
 from .globals import request
+from .globals import request_ctx
 from .globals import session
 from .signals import message_flashed
 
-if t.TYPE_CHECKING:
+if t.TYPE_CHECKING:  # pragma: no cover
+    from werkzeug.wrappers import Response as BaseResponse
     from .wrappers import Response
+    import typing_extensions as te
 
 
 def get_env() -> str:
     """Get the environment the app is running in, indicated by the
     :envvar:`FLASK_ENV` environment variable. The default is
     ``'production'``.
+
+    .. deprecated:: 2.2
+        Will be removed in Flask 2.3.
     """
+    import warnings
+
+    warnings.warn(
+        "'FLASK_ENV' and 'get_env' are deprecated and will be removed"
+        " in Flask 2.3. Use 'FLASK_DEBUG' instead.",
+        DeprecationWarning,
+        stacklevel=2,
+    )
     return os.environ.get("FLASK_ENV") or "production"
 
 
 def get_debug_flag() -> bool:
-    """Get whether debug mode should be enabled for the app, indicated
-    by the :envvar:`FLASK_DEBUG` environment variable. The default is
-    ``True`` if :func:`.get_env` returns ``'development'``, or ``False``
-    otherwise.
+    """Get whether debug mode should be enabled for the app, indicated by the
+    :envvar:`FLASK_DEBUG` environment variable. The default is ``False``.
     """
     val = os.environ.get("FLASK_DEBUG")
 
     if not val:
-        return get_env() == "development"
+        env = os.environ.get("FLASK_ENV")
+
+        if env is not None:
+            print(
+                "'FLASK_ENV' is deprecated and will not be used in"
+                " Flask 2.3. Use 'FLASK_DEBUG' instead.",
+                file=sys.stderr,
+            )
+            return env == "development"
 
-    return val.lower() not in ("0", "false", "no")
+        return False
+
+    return val.lower() not in {"0", "false", "no"}
 
 
 def get_load_dotenv(default: bool = True) -> bool:
-    """Get whether the user has disabled loading dotenv files by setting
-    :envvar:`FLASK_SKIP_DOTENV`. The default is ``True``, load the
-    files.
+    """Get whether the user has disabled loading default dotenv files by
+    setting :envvar:`FLASK_SKIP_DOTENV`. The default is ``True``, load
+    the files.
 
     :param default: What to return if the env var isn't set.
     """
@@ -110,11 +130,11 @@ def stream_with_context(
         return update_wrapper(decorator, generator_or_function)  # type: ignore
 
     def generator() -> t.Generator:
-        ctx = _request_ctx_stack.top
+        ctx = _cv_request.get(None)
         if ctx is None:
             raise RuntimeError(
-                "Attempted to stream with context but "
-                "there was no context in the first place to keep around."
+                "'stream_with_context' can only be used when a request"
+                " context is active, such as in a view function."
             )
         with ctx:
             # Dummy sentinel.  Has to be inside the context block or we're
@@ -129,7 +149,7 @@ def stream_with_context(
                 yield from gen
             finally:
                 if hasattr(gen, "close"):
-                    gen.close()  # type: ignore
+                    gen.close()
 
     # The trick is to start the generator.  Then the code execution runs until
     # the first dummy None is yielded at which point the context was already
@@ -189,155 +209,107 @@ def make_response(*args: t.Any) -> "Response":
     return current_app.make_response(args)  # type: ignore
 
 
-def url_for(endpoint: str, **values: t.Any) -> str:
-    """Generates a URL to the given endpoint with the method provided.
-
-    Variable arguments that are unknown to the target endpoint are appended
-    to the generated URL as query arguments.  If the value of a query argument
-    is ``None``, the whole pair is skipped.  In case blueprints are active
-    you can shortcut references to the same blueprint by prefixing the
-    local endpoint with a dot (``.``).
-
-    This will reference the index function local to the current blueprint::
-
-        url_for('.index')
-
-    See :ref:`url-building`.
-
-    Configuration values ``APPLICATION_ROOT`` and ``SERVER_NAME`` are only used when
-    generating URLs outside of a request context.
-
-    To integrate applications, :class:`Flask` has a hook to intercept URL build
-    errors through :attr:`Flask.url_build_error_handlers`.  The `url_for`
-    function results in a :exc:`~werkzeug.routing.BuildError` when the current
-    app does not have a URL for the given endpoint and values.  When it does, the
-    :data:`~flask.current_app` calls its :attr:`~Flask.url_build_error_handlers` if
-    it is not ``None``, which can return a string to use as the result of
-    `url_for` (instead of `url_for`'s default to raise the
-    :exc:`~werkzeug.routing.BuildError` exception) or re-raise the exception.
-    An example::
-
-        def external_url_handler(error, endpoint, values):
-            "Looks up an external URL when `url_for` cannot build a URL."
-            # This is an example of hooking the build_error_handler.
-            # Here, lookup_url is some utility function you've built
-            # which looks up the endpoint in some external URL registry.
-            url = lookup_url(endpoint, **values)
-            if url is None:
-                # External lookup did not have a URL.
-                # Re-raise the BuildError, in context of original traceback.
-                exc_type, exc_value, tb = sys.exc_info()
-                if exc_value is error:
-                    raise exc_type(exc_value).with_traceback(tb)
-                else:
-                    raise error
-            # url_for will use this result, instead of raising BuildError.
-            return url
-
-        app.url_build_error_handlers.append(external_url_handler)
-
-    Here, `error` is the instance of :exc:`~werkzeug.routing.BuildError`, and
-    `endpoint` and `values` are the arguments passed into `url_for`.  Note
-    that this is for building URLs outside the current application, and not for
-    handling 404 NotFound errors.
-
-    .. versionadded:: 0.10
-       The `_scheme` parameter was added.
+def url_for(
+    endpoint: str,
+    *,
+    _anchor: t.Optional[str] = None,
+    _method: t.Optional[str] = None,
+    _scheme: t.Optional[str] = None,
+    _external: t.Optional[bool] = None,
+    **values: t.Any,
+) -> str:
+    """Generate a URL to the given endpoint with the given values.
+
+    This requires an active request or application context, and calls
+    :meth:`current_app.url_for() <flask.Flask.url_for>`. See that method
+    for full documentation.
+
+    :param endpoint: The endpoint name associated with the URL to
+        generate. If this starts with a ``.``, the current blueprint
+        name (if any) will be used.
+    :param _anchor: If given, append this as ``#anchor`` to the URL.
+    :param _method: If given, generate the URL associated with this
+        method for the endpoint.
+    :param _scheme: If given, the URL will have this scheme if it is
+        external.
+    :param _external: If given, prefer the URL to be internal (False) or
+        require it to be external (True). External URLs include the
+        scheme and domain. When not in an active request, URLs are
+        external by default.
+    :param values: Values to use for the variable parts of the URL rule.
+        Unknown keys are appended as query string arguments, like
+        ``?a=b&c=d``.
+
+    .. versionchanged:: 2.2
+        Calls ``current_app.url_for``, allowing an app to override the
+        behavior.
+
+    .. versionchanged:: 0.10
+       The ``_scheme`` parameter was added.
 
-    .. versionadded:: 0.9
-       The `_anchor` and `_method` parameters were added.
+    .. versionchanged:: 0.9
+       The ``_anchor`` and ``_method`` parameters were added.
 
-    .. versionadded:: 0.9
-       Calls :meth:`Flask.handle_build_error` on
-       :exc:`~werkzeug.routing.BuildError`.
-
-    :param endpoint: the endpoint of the URL (name of the function)
-    :param values: the variable arguments of the URL rule
-    :param _external: if set to ``True``, an absolute URL is generated. Server
-      address can be changed via ``SERVER_NAME`` configuration variable which
-      falls back to the `Host` header, then to the IP and port of the request.
-    :param _scheme: a string specifying the desired URL scheme. The `_external`
-      parameter must be set to ``True`` or a :exc:`ValueError` is raised. The default
-      behavior uses the same scheme as the current request, or
-      :data:`PREFERRED_URL_SCHEME` if no request context is available.
-      This also can be set to an empty string to build protocol-relative
-      URLs.
-    :param _anchor: if provided this is added as anchor to the URL.
-    :param _method: if provided this explicitly specifies an HTTP method.
+    .. versionchanged:: 0.9
+       Calls ``app.handle_url_build_error`` on build errors.
     """
-    appctx = _app_ctx_stack.top
-    reqctx = _request_ctx_stack.top
-
-    if appctx is None:
-        raise RuntimeError(
-            "Attempted to generate a URL without the application context being"
-            " pushed. This has to be executed when application context is"
-            " available."
-        )
+    return current_app.url_for(
+        endpoint,
+        _anchor=_anchor,
+        _method=_method,
+        _scheme=_scheme,
+        _external=_external,
+        **values,
+    )
 
-    # If request specific information is available we have some extra
-    # features that support "relative" URLs.
-    if reqctx is not None:
-        url_adapter = reqctx.url_adapter
-        blueprint_name = request.blueprint
 
-        if endpoint[:1] == ".":
-            if blueprint_name is not None:
-                endpoint = f"{blueprint_name}{endpoint}"
-            else:
-                endpoint = endpoint[1:]
+def redirect(
+    location: str, code: int = 302, Response: t.Optional[t.Type["BaseResponse"]] = None
+) -> "BaseResponse":
+    """Create a redirect response object.
 
-        external = values.pop("_external", False)
+    If :data:`~flask.current_app` is available, it will use its
+    :meth:`~flask.Flask.redirect` method, otherwise it will use
+    :func:`werkzeug.utils.redirect`.
 
-    # Otherwise go with the url adapter from the appctx and make
-    # the URLs external by default.
-    else:
-        url_adapter = appctx.url_adapter
+    :param location: The URL to redirect to.
+    :param code: The status code for the redirect.
+    :param Response: The response class to use. Not used when
+        ``current_app`` is active, which uses ``app.response_class``.
 
-        if url_adapter is None:
-            raise RuntimeError(
-                "Application was not able to create a URL adapter for request"
-                " independent URL generation. You might be able to fix this by"
-                " setting the SERVER_NAME config variable."
-            )
+    .. versionadded:: 2.2
+        Calls ``current_app.redirect`` if available instead of always
+        using Werkzeug's default ``redirect``.
+    """
+    if current_app:
+        return current_app.redirect(location, code=code)
 
-        external = values.pop("_external", True)
+    return _wz_redirect(location, code=code, Response=Response)
 
-    anchor = values.pop("_anchor", None)
-    method = values.pop("_method", None)
-    scheme = values.pop("_scheme", None)
-    appctx.app.inject_url_defaults(endpoint, values)
 
-    # This is not the best way to deal with this but currently the
-    # underlying Werkzeug router does not support overriding the scheme on
-    # a per build call basis.
-    old_scheme = None
-    if scheme is not None:
-        if not external:
-            raise ValueError("When specifying _scheme, _external must be True")
-        old_scheme = url_adapter.url_scheme
-        url_adapter.url_scheme = scheme
+def abort(
+    code: t.Union[int, "BaseResponse"], *args: t.Any, **kwargs: t.Any
+) -> "te.NoReturn":
+    """Raise an :exc:`~werkzeug.exceptions.HTTPException` for the given
+    status code.
 
-    try:
-        try:
-            rv = url_adapter.build(
-                endpoint, values, method=method, force_external=external
-            )
-        finally:
-            if old_scheme is not None:
-                url_adapter.url_scheme = old_scheme
-    except BuildError as error:
-        # We need to inject the values again so that the app callback can
-        # deal with that sort of stuff.
-        values["_external"] = external
-        values["_anchor"] = anchor
-        values["_method"] = method
-        values["_scheme"] = scheme
-        return appctx.app.handle_url_build_error(error, endpoint, values)
-
-    if anchor is not None:
-        rv += f"#{url_quote(anchor)}"
-    return rv
+    If :data:`~flask.current_app` is available, it will call its
+    :attr:`~flask.Flask.aborter` object, otherwise it will use
+    :func:`werkzeug.exceptions.abort`.
+
+    :param code: The status code for the exception, which must be
+        registered in ``app.aborter``.
+    :param args: Passed to the exception.
+    :param kwargs: Passed to the exception.
+
+    .. versionadded:: 2.2
+        Calls ``current_app.aborter`` if available instead of always
+        using Werkzeug's default ``abort``.
+    """
+    if current_app:
+        current_app.aborter(code, *args, **kwargs)
+
+    _wz_abort(code, *args, **kwargs)
 
 
 def get_template_attribute(template_name: str, attribute: str) -> t.Any:
@@ -425,11 +397,10 @@ def get_flashed_messages(
     :param category_filter: filter of categories to limit return values.  Only
                             categories in the list will be returned.
     """
-    flashes = _request_ctx_stack.top.flashes
+    flashes = request_ctx.flashes
     if flashes is None:
-        _request_ctx_stack.top.flashes = flashes = (
-            session.pop("_flashes") if "_flashes" in session else []
-        )
+        flashes = session.pop("_flashes") if "_flashes" in session else []
+        request_ctx.flashes = flashes
     if category_filter:
         flashes = list(filter(lambda f: f[0] in category_filter, flashes))
     if not with_categories:
@@ -437,54 +408,13 @@ def get_flashed_messages(
     return flashes
 
 
-def _prepare_send_file_kwargs(
-    download_name: t.Optional[str] = None,
-    attachment_filename: t.Optional[str] = None,
-    etag: t.Optional[t.Union[bool, str]] = None,
-    add_etags: t.Optional[t.Union[bool]] = None,
-    max_age: t.Optional[
-        t.Union[int, t.Callable[[t.Optional[str]], t.Optional[int]]]
-    ] = None,
-    cache_timeout: t.Optional[int] = None,
-    **kwargs: t.Any,
-) -> t.Dict[str, t.Any]:
-    if attachment_filename is not None:
-        warnings.warn(
-            "The 'attachment_filename' parameter has been renamed to"
-            " 'download_name'. The old name will be removed in Flask"
-            " 2.2.",
-            DeprecationWarning,
-            stacklevel=3,
-        )
-        download_name = attachment_filename
-
-    if cache_timeout is not None:
-        warnings.warn(
-            "The 'cache_timeout' parameter has been renamed to"
-            " 'max_age'. The old name will be removed in Flask 2.2.",
-            DeprecationWarning,
-            stacklevel=3,
-        )
-        max_age = cache_timeout
-
-    if add_etags is not None:
-        warnings.warn(
-            "The 'add_etags' parameter has been renamed to 'etag'. The"
-            " old name will be removed in Flask 2.2.",
-            DeprecationWarning,
-            stacklevel=3,
-        )
-        etag = add_etags
-
-    if max_age is None:
-        max_age = current_app.get_send_file_max_age
+def _prepare_send_file_kwargs(**kwargs: t.Any) -> t.Dict[str, t.Any]:
+    if kwargs.get("max_age") is None:
+        kwargs["max_age"] = current_app.get_send_file_max_age
 
     kwargs.update(
         environ=request.environ,
-        download_name=download_name,
-        etag=etag,
-        max_age=max_age,
-        use_x_sendfile=current_app.use_x_sendfile,
+        use_x_sendfile=current_app.config["USE_X_SENDFILE"],
         response_class=current_app.response_class,
         _root_path=current_app.root_path,  # type: ignore
     )
@@ -496,16 +426,13 @@ def send_file(
     mimetype: t.Optional[str] = None,
     as_attachment: bool = False,
     download_name: t.Optional[str] = None,
-    attachment_filename: t.Optional[str] = None,
     conditional: bool = True,
     etag: t.Union[bool, str] = True,
-    add_etags: t.Optional[bool] = None,
     last_modified: t.Optional[t.Union[datetime, int, float]] = None,
     max_age: t.Optional[
         t.Union[int, t.Callable[[t.Optional[str]], t.Optional[int]]]
     ] = None,
-    cache_timeout: t.Optional[int] = None,
-):
+) -> "Response":
     """Send the contents of a file to the client.
 
     The first argument can be a file path or a file-like object. Paths
@@ -607,20 +534,17 @@ def send_file(
 
     .. versionadded:: 0.2
     """
-    return werkzeug.utils.send_file(
+    return werkzeug.utils.send_file(  # type: ignore[return-value]
         **_prepare_send_file_kwargs(
             path_or_file=path_or_file,
             environ=request.environ,
             mimetype=mimetype,
             as_attachment=as_attachment,
             download_name=download_name,
-            attachment_filename=attachment_filename,
             conditional=conditional,
             etag=etag,
-            add_etags=add_etags,
             last_modified=last_modified,
             max_age=max_age,
-            cache_timeout=cache_timeout,
         )
     )
 
@@ -628,7 +552,6 @@ def send_file(
 def send_from_directory(
     directory: t.Union[os.PathLike, str],
     path: t.Union[os.PathLike, str],
-    filename: t.Optional[str] = None,
     **kwargs: t.Any,
 ) -> "Response":
     """Send a file from within a directory using :func:`send_file`.
@@ -649,7 +572,8 @@ def send_from_directory(
     If the final path does not point to an existing regular file,
     raises a 404 :exc:`~werkzeug.exceptions.NotFound` error.
 
-    :param directory: The directory that ``path`` must be located under.
+    :param directory: The directory that ``path`` must be located under,
+        relative to the current application's root path.
     :param path: The path to the file to send, relative to
         ``directory``.
     :param kwargs: Arguments to pass to :func:`send_file`.
@@ -663,16 +587,7 @@ def send_from_directory(
 
     .. versionadded:: 0.5
     """
-    if filename is not None:
-        warnings.warn(
-            "The 'filename' parameter has been renamed to 'path'. The"
-            " old name will be removed in Flask 2.2.",
-            DeprecationWarning,
-            stacklevel=2,
-        )
-        path = filename
-
-    return werkzeug.utils.send_from_directory(  # type: ignore
+    return werkzeug.utils.send_from_directory(  # type: ignore[return-value]
         directory, path, **_prepare_send_file_kwargs(**kwargs)
     )
 
@@ -702,7 +617,7 @@ def get_root_path(import_name: str) -> str:
         return os.getcwd()
 
     if hasattr(loader, "get_filename"):
-        filepath = loader.get_filename(import_name)  # type: ignore
+        filepath = loader.get_filename(import_name)
     else:
         # Fall back to imports.
         __import__(import_name)
diff --git a/src/flask/json/__init__.py b/src/flask/json/__init__.py
index edc9793d..65d8829a 100644
--- a/src/flask/json/__init__.py
+++ b/src/flask/json/__init__.py
@@ -1,17 +1,14 @@
-import dataclasses
-import decimal
+from __future__ import annotations
+
 import json as _json
 import typing as t
-import uuid
-from datetime import date
 
 from jinja2.utils import htmlsafe_json_dumps as _jinja_htmlsafe_dumps
-from werkzeug.http import http_date
 
 from ..globals import current_app
-from ..globals import request
+from .provider import _default
 
-if t.TYPE_CHECKING:
+if t.TYPE_CHECKING:  # pragma: no cover
     from ..app import Flask
     from ..wrappers import Response
 
@@ -23,6 +20,7 @@ class JSONEncoder(_json.JSONEncoder):
     -   :class:`datetime.datetime` and :class:`datetime.date` are
         serialized to :rfc:`822` strings. This is the same as the HTTP
         date format.
+    -   :class:`decimal.Decimal` is serialized to a string.
     -   :class:`uuid.UUID` is serialized to a string.
     -   :class:`dataclasses.dataclass` is passed to
         :func:`dataclasses.asdict`.
@@ -31,23 +29,30 @@ class JSONEncoder(_json.JSONEncoder):
 
     Assign a subclass of this to :attr:`flask.Flask.json_encoder` or
     :attr:`flask.Blueprint.json_encoder` to override the default.
+
+    .. deprecated:: 2.2
+        Will be removed in Flask 2.3. Use ``app.json`` instead.
     """
 
+    def __init__(self, **kwargs) -> None:
+        import warnings
+
+        warnings.warn(
+            "'JSONEncoder' is deprecated and will be removed in"
+            " Flask 2.3. Use 'Flask.json' to provide an alternate"
+            " JSON implementation instead.",
+            DeprecationWarning,
+            stacklevel=3,
+        )
+        super().__init__(**kwargs)
+
     def default(self, o: t.Any) -> t.Any:
         """Convert ``o`` to a JSON serializable type. See
         :meth:`json.JSONEncoder.default`. Python does not support
         overriding how basic types like ``str`` or ``list`` are
         serialized, they are handled before this method.
         """
-        if isinstance(o, date):
-            return http_date(o)
-        if isinstance(o, (decimal.Decimal, uuid.UUID)):
-            return str(o)
-        if dataclasses and dataclasses.is_dataclass(o):
-            return dataclasses.asdict(o)
-        if hasattr(o, "__html__"):
-            return str(o.__html__())
-        return super().default(o)
+        return _default(o)
 
 
 class JSONDecoder(_json.JSONDecoder):
@@ -58,144 +63,193 @@ class JSONDecoder(_json.JSONDecoder):
 
     Assign a subclass of this to :attr:`flask.Flask.json_decoder` or
     :attr:`flask.Blueprint.json_decoder` to override the default.
-    """
-
-
-def _dump_arg_defaults(
-    kwargs: t.Dict[str, t.Any], app: t.Optional["Flask"] = None
-) -> None:
-    """Inject default arguments for dump functions."""
-    if app is None:
-        app = current_app
 
-    if app:
-        cls = app.json_encoder
-        bp = app.blueprints.get(request.blueprint) if request else None  # type: ignore
-        if bp is not None and bp.json_encoder is not None:
-            cls = bp.json_encoder
-
-        # Only set a custom encoder if it has custom behavior. This is
-        # faster on PyPy.
-        if cls is not _json.JSONEncoder:
-            kwargs.setdefault("cls", cls)
-
-        kwargs.setdefault("cls", cls)
-        kwargs.setdefault("ensure_ascii", app.config["JSON_AS_ASCII"])
-        kwargs.setdefault("sort_keys", app.config["JSON_SORT_KEYS"])
-    else:
-        kwargs.setdefault("sort_keys", True)
-        kwargs.setdefault("cls", JSONEncoder)
+    .. deprecated:: 2.2
+        Will be removed in Flask 2.3. Use ``app.json`` instead.
+    """
 
+    def __init__(self, **kwargs) -> None:
+        import warnings
 
-def _load_arg_defaults(
-    kwargs: t.Dict[str, t.Any], app: t.Optional["Flask"] = None
-) -> None:
-    """Inject default arguments for load functions."""
-    if app is None:
-        app = current_app
+        warnings.warn(
+            "'JSONDecoder' is deprecated and will be removed in"
+            " Flask 2.3. Use 'Flask.json' to provide an alternate"
+            " JSON implementation instead.",
+            DeprecationWarning,
+            stacklevel=3,
+        )
+        super().__init__(**kwargs)
 
-    if app:
-        cls = app.json_decoder
-        bp = app.blueprints.get(request.blueprint) if request else None  # type: ignore
-        if bp is not None and bp.json_decoder is not None:
-            cls = bp.json_decoder
 
-        # Only set a custom decoder if it has custom behavior. This is
-        # faster on PyPy.
-        if cls not in {JSONDecoder, _json.JSONDecoder}:
-            kwargs.setdefault("cls", cls)
+def dumps(obj: t.Any, *, app: Flask | None = None, **kwargs: t.Any) -> str:
+    """Serialize data as JSON.
 
+    If :data:`~flask.current_app` is available, it will use its
+    :meth:`app.json.dumps() <flask.json.provider.JSONProvider.dumps>`
+    method, otherwise it will use :func:`json.dumps`.
 
-def dumps(obj: t.Any, app: t.Optional["Flask"] = None, **kwargs: t.Any) -> str:
-    """Serialize an object to a string of JSON.
+    :param obj: The data to serialize.
+    :param kwargs: Arguments passed to the ``dumps`` implementation.
 
-    Takes the same arguments as the built-in :func:`json.dumps`, with
-    some defaults from application configuration.
+    .. versionchanged:: 2.2
+        Calls ``current_app.json.dumps``, allowing an app to override
+        the behavior.
 
-    :param obj: Object to serialize to JSON.
-    :param app: Use this app's config instead of the active app context
-        or defaults.
-    :param kwargs: Extra arguments passed to :func:`json.dumps`.
+    .. versionchanged:: 2.2
+        The ``app`` parameter will be removed in Flask 2.3.
 
     .. versionchanged:: 2.0.2
         :class:`decimal.Decimal` is supported by converting to a string.
 
     .. versionchanged:: 2.0
-        ``encoding`` is deprecated and will be removed in Flask 2.1.
+        ``encoding`` will be removed in Flask 2.1.
 
     .. versionchanged:: 1.0.3
         ``app`` can be passed directly, rather than requiring an app
         context for configuration.
     """
-    _dump_arg_defaults(kwargs, app=app)
+    if app is not None:
+        import warnings
+
+        warnings.warn(
+            "The 'app' parameter is deprecated and will be removed in"
+            " Flask 2.3. Call 'app.json.dumps' directly instead.",
+            DeprecationWarning,
+            stacklevel=2,
+        )
+    else:
+        app = current_app
+
+    if app:
+        return app.json.dumps(obj, **kwargs)
+
+    kwargs.setdefault("default", _default)
     return _json.dumps(obj, **kwargs)
 
 
 def dump(
-    obj: t.Any, fp: t.IO[str], app: t.Optional["Flask"] = None, **kwargs: t.Any
+    obj: t.Any, fp: t.IO[str], *, app: Flask | None = None, **kwargs: t.Any
 ) -> None:
-    """Serialize an object to JSON written to a file object.
+    """Serialize data as JSON and write to a file.
+
+    If :data:`~flask.current_app` is available, it will use its
+    :meth:`app.json.dump() <flask.json.provider.JSONProvider.dump>`
+    method, otherwise it will use :func:`json.dump`.
 
-    Takes the same arguments as the built-in :func:`json.dump`, with
-    some defaults from application configuration.
+    :param obj: The data to serialize.
+    :param fp: A file opened for writing text. Should use the UTF-8
+        encoding to be valid JSON.
+    :param kwargs: Arguments passed to the ``dump`` implementation.
 
-    :param obj: Object to serialize to JSON.
-    :param fp: File object to write JSON to.
-    :param app: Use this app's config instead of the active app context
-        or defaults.
-    :param kwargs: Extra arguments passed to :func:`json.dump`.
+    .. versionchanged:: 2.2
+        Calls ``current_app.json.dump``, allowing an app to override
+        the behavior.
+
+    .. versionchanged:: 2.2
+        The ``app`` parameter will be removed in Flask 2.3.
 
     .. versionchanged:: 2.0
-        Writing to a binary file, and the ``encoding`` argument, is
-        deprecated and will be removed in Flask 2.1.
+        Writing to a binary file, and the ``encoding`` argument, will be
+        removed in Flask 2.1.
     """
-    _dump_arg_defaults(kwargs, app=app)
-    _json.dump(obj, fp, **kwargs)
+    if app is not None:
+        import warnings
+
+        warnings.warn(
+            "The 'app' parameter is deprecated and will be removed in"
+            " Flask 2.3. Call 'app.json.dump' directly instead.",
+            DeprecationWarning,
+            stacklevel=2,
+        )
+    else:
+        app = current_app
+
+    if app:
+        app.json.dump(obj, fp, **kwargs)
+    else:
+        kwargs.setdefault("default", _default)
+        _json.dump(obj, fp, **kwargs)
+
 
+def loads(s: str | bytes, *, app: Flask | None = None, **kwargs: t.Any) -> t.Any:
+    """Deserialize data as JSON.
 
-def loads(
-    s: t.Union[str, bytes],
-    app: t.Optional["Flask"] = None,
-    **kwargs: t.Any,
-) -> t.Any:
-    """Deserialize an object from a string of JSON.
+    If :data:`~flask.current_app` is available, it will use its
+    :meth:`app.json.loads() <flask.json.provider.JSONProvider.loads>`
+    method, otherwise it will use :func:`json.loads`.
 
-    Takes the same arguments as the built-in :func:`json.loads`, with
-    some defaults from application configuration.
+    :param s: Text or UTF-8 bytes.
+    :param kwargs: Arguments passed to the ``loads`` implementation.
 
-    :param s: JSON string to deserialize.
-    :param app: Use this app's config instead of the active app context
-        or defaults.
-    :param kwargs: Extra arguments passed to :func:`json.loads`.
+    .. versionchanged:: 2.2
+        Calls ``current_app.json.loads``, allowing an app to override
+        the behavior.
+
+    .. versionchanged:: 2.2
+        The ``app`` parameter will be removed in Flask 2.3.
 
     .. versionchanged:: 2.0
-        ``encoding`` is deprecated and will be removed in Flask 2.1. The
-        data must be a string or UTF-8 bytes.
+        ``encoding`` will be removed in Flask 2.1. The data must be a
+        string or UTF-8 bytes.
 
     .. versionchanged:: 1.0.3
         ``app`` can be passed directly, rather than requiring an app
         context for configuration.
     """
-    _load_arg_defaults(kwargs, app=app)
+    if app is not None:
+        import warnings
+
+        warnings.warn(
+            "The 'app' parameter is deprecated and will be removed in"
+            " Flask 2.3. Call 'app.json.loads' directly instead.",
+            DeprecationWarning,
+            stacklevel=2,
+        )
+    else:
+        app = current_app
+
+    if app:
+        return app.json.loads(s, **kwargs)
+
     return _json.loads(s, **kwargs)
 
 
-def load(fp: t.IO[str], app: t.Optional["Flask"] = None, **kwargs: t.Any) -> t.Any:
-    """Deserialize an object from JSON read from a file object.
+def load(fp: t.IO[t.AnyStr], *, app: Flask | None = None, **kwargs: t.Any) -> t.Any:
+    """Deserialize data as JSON read from a file.
+
+    If :data:`~flask.current_app` is available, it will use its
+    :meth:`app.json.load() <flask.json.provider.JSONProvider.load>`
+    method, otherwise it will use :func:`json.load`.
 
-    Takes the same arguments as the built-in :func:`json.load`, with
-    some defaults from application configuration.
+    :param fp: A file opened for reading text or UTF-8 bytes.
+    :param kwargs: Arguments passed to the ``load`` implementation.
 
-    :param fp: File object to read JSON from.
-    :param app: Use this app's config instead of the active app context
-        or defaults.
-    :param kwargs: Extra arguments passed to :func:`json.load`.
+    .. versionchanged:: 2.2
+        Calls ``current_app.json.load``, allowing an app to override
+        the behavior.
+
+    .. versionchanged:: 2.2
+        The ``app`` parameter will be removed in Flask 2.3.
 
     .. versionchanged:: 2.0
-        ``encoding`` is deprecated and will be removed in Flask 2.1. The
-        file must be text mode, or binary mode with UTF-8 bytes.
+        ``encoding`` will be removed in Flask 2.1. The file must be text
+        mode, or binary mode with UTF-8 bytes.
     """
-    _load_arg_defaults(kwargs, app=app)
+    if app is not None:
+        import warnings
+
+        warnings.warn(
+            "The 'app' parameter is deprecated and will be removed in"
+            " Flask 2.3. Call 'app.json.load' directly instead.",
+            DeprecationWarning,
+            stacklevel=2,
+        )
+    else:
+        app = current_app
+
+    if app:
+        return app.json.load(fp, **kwargs)
+
     return _json.load(fp, **kwargs)
 
 
@@ -211,6 +265,9 @@ def htmlsafe_dumps(obj: t.Any, **kwargs: t.Any) -> str:
     double quoted; either use single quotes or the ``|forceescape``
     filter.
 
+    .. deprecated:: 2.2
+        Will be removed in Flask 2.3. This is built-in to Jinja now.
+
     .. versionchanged:: 2.0
         Uses :func:`jinja2.utils.htmlsafe_json_dumps`. The returned
         value is marked safe by wrapping in :class:`~markupsafe.Markup`.
@@ -220,6 +277,14 @@ def htmlsafe_dumps(obj: t.Any, **kwargs: t.Any) -> str:
         ``<script>`` tags, and single-quoted attributes without further
         escaping.
     """
+    import warnings
+
+    warnings.warn(
+        "'htmlsafe_dumps' is deprecated and will be removed in Flask"
+        " 2.3. Use 'jinja2.utils.htmlsafe_json_dumps' instead.",
+        DeprecationWarning,
+        stacklevel=2,
+    )
     return _jinja_htmlsafe_dumps(obj, dumps=dumps, **kwargs)
 
 
@@ -227,77 +292,51 @@ def htmlsafe_dump(obj: t.Any, fp: t.IO[str], **kwargs: t.Any) -> None:
     """Serialize an object to JSON written to a file object, replacing
     HTML-unsafe characters with Unicode escapes. See
     :func:`htmlsafe_dumps` and :func:`dumps`.
-    """
-    fp.write(htmlsafe_dumps(obj, **kwargs))
 
+    .. deprecated:: 2.2
+        Will be removed in Flask 2.3.
+    """
+    import warnings
 
-def jsonify(*args: t.Any, **kwargs: t.Any) -> "Response":
-    """Serialize data to JSON and wrap it in a :class:`~flask.Response`
-    with the :mimetype:`application/json` mimetype.
-
-    Uses :func:`dumps` to serialize the data, but ``args`` and
-    ``kwargs`` are treated as data rather than arguments to
-    :func:`json.dumps`.
-
-    1.  Single argument: Treated as a single value.
-    2.  Multiple arguments: Treated as a list of values.
-        ``jsonify(1, 2, 3)`` is the same as ``jsonify([1, 2, 3])``.
-    3.  Keyword arguments: Treated as a dict of values.
-        ``jsonify(data=data, errors=errors)`` is the same as
-        ``jsonify({"data": data, "errors": errors})``.
-    4.  Passing both arguments and keyword arguments is not allowed as
-        it's not clear what should happen.
+    warnings.warn(
+        "'htmlsafe_dump' is deprecated and will be removed in Flask"
+        " 2.3. Use 'jinja2.utils.htmlsafe_json_dumps' instead.",
+        DeprecationWarning,
+        stacklevel=2,
+    )
+    fp.write(htmlsafe_dumps(obj, **kwargs))
 
-    .. code-block:: python
 
-        from flask import jsonify
+def jsonify(*args: t.Any, **kwargs: t.Any) -> Response:
+    """Serialize the given arguments as JSON, and return a
+    :class:`~flask.Response` object with the ``application/json``
+    mimetype. A dict or list returned from a view will be converted to a
+    JSON response automatically without needing to call this.
 
-        @app.route("/users/me")
-        def get_current_user():
-            return jsonify(
-                username=g.user.username,
-                email=g.user.email,
-                id=g.user.id,
-            )
+    This requires an active request or application context, and calls
+    :meth:`app.json.response() <flask.json.provider.JSONProvider.response>`.
 
-    Will return a JSON response like this:
+    In debug mode, the output is formatted with indentation to make it
+    easier to read. This may also be controlled by the provider.
 
-    .. code-block:: javascript
+    Either positional or keyword arguments can be given, not both.
+    If no arguments are given, ``None`` is serialized.
 
-        {
-          "username": "admin",
-          "email": "admin@localhost",
-          "id": 42
-        }
+    :param args: A single value to serialize, or multiple values to
+        treat as a list to serialize.
+    :param kwargs: Treat as a dict to serialize.
 
-    The default output omits indents and spaces after separators. In
-    debug mode or if :data:`JSONIFY_PRETTYPRINT_REGULAR` is ``True``,
-    the output will be formatted to be easier to read.
+    .. versionchanged:: 2.2
+        Calls ``current_app.json.response``, allowing an app to override
+        the behavior.
 
     .. versionchanged:: 2.0.2
         :class:`decimal.Decimal` is supported by converting to a string.
 
     .. versionchanged:: 0.11
-        Added support for serializing top-level arrays. This introduces
-        a security risk in ancient browsers. See :ref:`security-json`.
+        Added support for serializing top-level arrays. This was a
+        security risk in ancient browsers. See :ref:`security-json`.
 
     .. versionadded:: 0.2
     """
-    indent = None
-    separators = (",", ":")
-
-    if current_app.config["JSONIFY_PRETTYPRINT_REGULAR"] or current_app.debug:
-        indent = 2
-        separators = (", ", ": ")
-
-    if args and kwargs:
-        raise TypeError("jsonify() behavior undefined when passed both args and kwargs")
-    elif len(args) == 1:  # single args are passed directly to dumps()
-        data = args[0]
-    else:
-        data = args or kwargs
-
-    return current_app.response_class(
-        f"{dumps(data, indent=indent, separators=separators)}\n",
-        mimetype=current_app.config["JSONIFY_MIMETYPE"],
-    )
+    return current_app.json.response(*args, **kwargs)
diff --git a/src/flask/json/provider.py b/src/flask/json/provider.py
new file mode 100644
index 00000000..cb6aae80
--- /dev/null
+++ b/src/flask/json/provider.py
@@ -0,0 +1,310 @@
+from __future__ import annotations
+
+import dataclasses
+import decimal
+import json
+import typing as t
+import uuid
+import weakref
+from datetime import date
+
+from werkzeug.http import http_date
+
+from ..globals import request
+
+if t.TYPE_CHECKING:  # pragma: no cover
+    from ..app import Flask
+    from ..wrappers import Response
+
+
+class JSONProvider:
+    """A standard set of JSON operations for an application. Subclasses
+    of this can be used to customize JSON behavior or use different
+    JSON libraries.
+
+    To implement a provider for a specific library, subclass this base
+    class and implement at least :meth:`dumps` and :meth:`loads`. All
+    other methods have default implementations.
+
+    To use a different provider, either subclass ``Flask`` and set
+    :attr:`~flask.Flask.json_provider_class` to a provider class, or set
+    :attr:`app.json <flask.Flask.json>` to an instance of the class.
+
+    :param app: An application instance. This will be stored as a
+        :class:`weakref.proxy` on the :attr:`_app` attribute.
+
+    .. versionadded:: 2.2
+    """
+
+    def __init__(self, app: Flask) -> None:
+        self._app = weakref.proxy(app)
+
+    def dumps(self, obj: t.Any, **kwargs: t.Any) -> str:
+        """Serialize data as JSON.
+
+        :param obj: The data to serialize.
+        :param kwargs: May be passed to the underlying JSON library.
+        """
+        raise NotImplementedError
+
+    def dump(self, obj: t.Any, fp: t.IO[str], **kwargs: t.Any) -> None:
+        """Serialize data as JSON and write to a file.
+
+        :param obj: The data to serialize.
+        :param fp: A file opened for writing text. Should use the UTF-8
+            encoding to be valid JSON.
+        :param kwargs: May be passed to the underlying JSON library.
+        """
+        fp.write(self.dumps(obj, **kwargs))
+
+    def loads(self, s: str | bytes, **kwargs: t.Any) -> t.Any:
+        """Deserialize data as JSON.
+
+        :param s: Text or UTF-8 bytes.
+        :param kwargs: May be passed to the underlying JSON library.
+        """
+        raise NotImplementedError
+
+    def load(self, fp: t.IO[t.AnyStr], **kwargs: t.Any) -> t.Any:
+        """Deserialize data as JSON read from a file.
+
+        :param fp: A file opened for reading text or UTF-8 bytes.
+        :param kwargs: May be passed to the underlying JSON library.
+        """
+        return self.loads(fp.read(), **kwargs)
+
+    def _prepare_response_obj(
+        self, args: t.Tuple[t.Any, ...], kwargs: t.Dict[str, t.Any]
+    ) -> t.Any:
+        if args and kwargs:
+            raise TypeError("app.json.response() takes either args or kwargs, not both")
+
+        if not args and not kwargs:
+            return None
+
+        if len(args) == 1:
+            return args[0]
+
+        return args or kwargs
+
+    def response(self, *args: t.Any, **kwargs: t.Any) -> Response:
+        """Serialize the given arguments as JSON, and return a
+        :class:`~flask.Response` object with the ``application/json``
+        mimetype.
+
+        The :func:`~flask.json.jsonify` function calls this method for
+        the current application.
+
+        Either positional or keyword arguments can be given, not both.
+        If no arguments are given, ``None`` is serialized.
+
+        :param args: A single value to serialize, or multiple values to
+            treat as a list to serialize.
+        :param kwargs: Treat as a dict to serialize.
+        """
+        obj = self._prepare_response_obj(args, kwargs)
+        return self._app.response_class(self.dumps(obj), mimetype="application/json")
+
+
+def _default(o: t.Any) -> t.Any:
+    if isinstance(o, date):
+        return http_date(o)
+
+    if isinstance(o, (decimal.Decimal, uuid.UUID)):
+        return str(o)
+
+    if dataclasses and dataclasses.is_dataclass(o):
+        return dataclasses.asdict(o)
+
+    if hasattr(o, "__html__"):
+        return str(o.__html__())
+
+    raise TypeError(f"Object of type {type(o).__name__} is not JSON serializable")
+
+
+class DefaultJSONProvider(JSONProvider):
+    """Provide JSON operations using Python's built-in :mod:`json`
+    library. Serializes the following additional data types:
+
+    -   :class:`datetime.datetime` and :class:`datetime.date` are
+        serialized to :rfc:`822` strings. This is the same as the HTTP
+        date format.
+    -   :class:`uuid.UUID` is serialized to a string.
+    -   :class:`dataclasses.dataclass` is passed to
+        :func:`dataclasses.asdict`.
+    -   :class:`~markupsafe.Markup` (or any object with a ``__html__``
+        method) will call the ``__html__`` method to get a string.
+    """
+
+    default: t.Callable[[t.Any], t.Any] = staticmethod(
+        _default
+    )  # type: ignore[assignment]
+    """Apply this function to any object that :meth:`json.dumps` does
+    not know how to serialize. It should return a valid JSON type or
+    raise a ``TypeError``.
+    """
+
+    ensure_ascii = True
+    """Replace non-ASCII characters with escape sequences. This may be
+    more compatible with some clients, but can be disabled for better
+    performance and size.
+    """
+
+    sort_keys = True
+    """Sort the keys in any serialized dicts. This may be useful for
+    some caching situations, but can be disabled for better performance.
+    When enabled, keys must all be strings, they are not converted
+    before sorting.
+    """
+
+    compact: bool | None = None
+    """If ``True``, or ``None`` out of debug mode, the :meth:`response`
+    output will not add indentation, newlines, or spaces. If ``False``,
+    or ``None`` in debug mode, it will use a non-compact representation.
+    """
+
+    mimetype = "application/json"
+    """The mimetype set in :meth:`response`."""
+
+    def dumps(self, obj: t.Any, **kwargs: t.Any) -> str:
+        """Serialize data as JSON to a string.
+
+        Keyword arguments are passed to :func:`json.dumps`. Sets some
+        parameter defaults from the :attr:`default`,
+        :attr:`ensure_ascii`, and :attr:`sort_keys` attributes.
+
+        :param obj: The data to serialize.
+        :param kwargs: Passed to :func:`json.dumps`.
+        """
+        cls = self._app._json_encoder
+        bp = self._app.blueprints.get(request.blueprint) if request else None
+
+        if bp is not None and bp._json_encoder is not None:
+            cls = bp._json_encoder
+
+        if cls is not None:
+            import warnings
+
+            warnings.warn(
+                "Setting 'json_encoder' on the app or a blueprint is"
+                " deprecated and will be removed in Flask 2.3."
+                " Customize 'app.json' instead.",
+                DeprecationWarning,
+            )
+            kwargs.setdefault("cls", cls)
+
+            if "default" not in cls.__dict__:
+                kwargs.setdefault("default", self.default)
+        else:
+            kwargs.setdefault("default", self.default)
+
+        ensure_ascii = self._app.config["JSON_AS_ASCII"]
+        sort_keys = self._app.config["JSON_SORT_KEYS"]
+
+        if ensure_ascii is not None:
+            import warnings
+
+            warnings.warn(
+                "The 'JSON_AS_ASCII' config key is deprecated and will"
+                " be removed in Flask 2.3. Set 'app.json.ensure_ascii'"
+                " instead.",
+                DeprecationWarning,
+            )
+        else:
+            ensure_ascii = self.ensure_ascii
+
+        if sort_keys is not None:
+            import warnings
+
+            warnings.warn(
+                "The 'JSON_SORT_KEYS' config key is deprecated and will"
+                " be removed in Flask 2.3. Set 'app.json.sort_keys'"
+                " instead.",
+                DeprecationWarning,
+            )
+        else:
+            sort_keys = self.sort_keys
+
+        kwargs.setdefault("ensure_ascii", ensure_ascii)
+        kwargs.setdefault("sort_keys", sort_keys)
+        return json.dumps(obj, **kwargs)
+
+    def loads(self, s: str | bytes, **kwargs: t.Any) -> t.Any:
+        """Deserialize data as JSON from a string or bytes.
+
+        :param s: Text or UTF-8 bytes.
+        :param kwargs: Passed to :func:`json.loads`.
+        """
+        cls = self._app._json_decoder
+        bp = self._app.blueprints.get(request.blueprint) if request else None
+
+        if bp is not None and bp._json_decoder is not None:
+            cls = bp._json_decoder
+
+        if cls is not None:
+            import warnings
+
+            warnings.warn(
+                "Setting 'json_decoder' on the app or a blueprint is"
+                " deprecated and will be removed in Flask 2.3."
+                " Customize 'app.json' instead.",
+                DeprecationWarning,
+            )
+            kwargs.setdefault("cls", cls)
+
+        return json.loads(s, **kwargs)
+
+    def response(self, *args: t.Any, **kwargs: t.Any) -> Response:
+        """Serialize the given arguments as JSON, and return a
+        :class:`~flask.Response` object with it. The response mimetype
+        will be "application/json" and can be changed with
+        :attr:`mimetype`.
+
+        If :attr:`compact` is ``False`` or debug mode is enabled, the
+        output will be formatted to be easier to read.
+
+        Either positional or keyword arguments can be given, not both.
+        If no arguments are given, ``None`` is serialized.
+
+        :param args: A single value to serialize, or multiple values to
+            treat as a list to serialize.
+        :param kwargs: Treat as a dict to serialize.
+        """
+        obj = self._prepare_response_obj(args, kwargs)
+        dump_args: t.Dict[str, t.Any] = {}
+        pretty = self._app.config["JSONIFY_PRETTYPRINT_REGULAR"]
+        mimetype = self._app.config["JSONIFY_MIMETYPE"]
+
+        if pretty is not None:
+            import warnings
+
+            warnings.warn(
+                "The 'JSONIFY_PRETTYPRINT_REGULAR' config key is"
+                " deprecated and will be removed in Flask 2.3. Set"
+                " 'app.json.compact' instead.",
+                DeprecationWarning,
+            )
+            compact: bool | None = not pretty
+        else:
+            compact = self.compact
+
+        if (compact is None and self._app.debug) or compact is False:
+            dump_args.setdefault("indent", 2)
+        else:
+            dump_args.setdefault("separators", (",", ":"))
+
+        if mimetype is not None:
+            import warnings
+
+            warnings.warn(
+                "The 'JSONIFY_MIMETYPE' config key is deprecated and"
+                " will be removed in Flask 2.3. Set 'app.json.mimetype'"
+                " instead.",
+                DeprecationWarning,
+            )
+        else:
+            mimetype = self.mimetype
+
+        return self._app.response_class(
+            f"{self.dumps(obj, **dump_args)}\n", mimetype=mimetype
+        )
diff --git a/src/flask/logging.py b/src/flask/logging.py
index 48a5b7ff..8981b820 100644
--- a/src/flask/logging.py
+++ b/src/flask/logging.py
@@ -6,7 +6,7 @@ from werkzeug.local import LocalProxy
 
 from .globals import request
 
-if t.TYPE_CHECKING:
+if t.TYPE_CHECKING:  # pragma: no cover
     from .app import Flask
 
 
diff --git a/src/flask/scaffold.py b/src/flask/scaffold.py
index acf8708b..7277b33a 100644
--- a/src/flask/scaffold.py
+++ b/src/flask/scaffold.py
@@ -1,58 +1,52 @@
 import importlib.util
+import json
 import os
+import pathlib
 import pkgutil
 import sys
 import typing as t
 from collections import defaultdict
+from datetime import timedelta
 from functools import update_wrapper
-from json import JSONDecoder
-from json import JSONEncoder
 
 from jinja2 import FileSystemLoader
 from werkzeug.exceptions import default_exceptions
 from werkzeug.exceptions import HTTPException
 
+from . import typing as ft
 from .cli import AppGroup
 from .globals import current_app
 from .helpers import get_root_path
 from .helpers import locked_cached_property
 from .helpers import send_from_directory
 from .templating import _default_template_ctx_processor
-from .typing import AfterRequestCallable
-from .typing import AppOrBlueprintKey
-from .typing import BeforeRequestCallable
-from .typing import TeardownCallable
-from .typing import TemplateContextProcessorCallable
-from .typing import URLDefaultCallable
-from .typing import URLValuePreprocessorCallable
-
-if t.TYPE_CHECKING:
+
+if t.TYPE_CHECKING:  # pragma: no cover
     from .wrappers import Response
-    from .typing import ErrorHandlerCallable
 
 # a singleton sentinel value for parameter defaults
 _sentinel = object()
 
 F = t.TypeVar("F", bound=t.Callable[..., t.Any])
+T_after_request = t.TypeVar("T_after_request", bound=ft.AfterRequestCallable)
+T_before_request = t.TypeVar("T_before_request", bound=ft.BeforeRequestCallable)
+T_error_handler = t.TypeVar("T_error_handler", bound=ft.ErrorHandlerCallable)
+T_teardown = t.TypeVar("T_teardown", bound=ft.TeardownCallable)
+T_template_context_processor = t.TypeVar(
+    "T_template_context_processor", bound=ft.TemplateContextProcessorCallable
+)
+T_url_defaults = t.TypeVar("T_url_defaults", bound=ft.URLDefaultCallable)
+T_url_value_preprocessor = t.TypeVar(
+    "T_url_value_preprocessor", bound=ft.URLValuePreprocessorCallable
+)
+T_route = t.TypeVar("T_route", bound=ft.RouteCallable)
 
 
 def setupmethod(f: F) -> F:
-    """Wraps a method so that it performs a check in debug mode if the
-    first request was already handled.
-    """
+    f_name = f.__name__
 
     def wrapper_func(self, *args: t.Any, **kwargs: t.Any) -> t.Any:
-        if self._is_setup_finished():
-            raise AssertionError(
-                "A setup function was called after the first request "
-                "was handled. This usually indicates a bug in the"
-                " application where a module was not imported and"
-                " decorators or other functionality was called too"
-                " late.\nTo fix this make sure to import all your view"
-                " modules, database models, and everything related at a"
-                " central place before the application starts serving"
-                " requests."
-            )
+        self._check_setup_finished(f_name)
         return f(self, *args, **kwargs)
 
     return t.cast(F, update_wrapper(wrapper_func, f))
@@ -82,18 +76,24 @@ class Scaffold:
 
     #: JSON encoder class used by :func:`flask.json.dumps`. If a
     #: blueprint sets this, it will be used instead of the app's value.
-    json_encoder: t.Optional[t.Type[JSONEncoder]] = None
+    #:
+    #: .. deprecated:: 2.2
+    #:      Will be removed in Flask 2.3.
+    json_encoder: t.Union[t.Type[json.JSONEncoder], None] = None
 
     #: JSON decoder class used by :func:`flask.json.loads`. If a
     #: blueprint sets this, it will be used instead of the app's value.
-    json_decoder: t.Optional[t.Type[JSONDecoder]] = None
+    #:
+    #: .. deprecated:: 2.2
+    #:      Will be removed in Flask 2.3.
+    json_decoder: t.Union[t.Type[json.JSONDecoder], None] = None
 
     def __init__(
         self,
         import_name: str,
         static_folder: t.Optional[t.Union[str, os.PathLike]] = None,
         static_url_path: t.Optional[str] = None,
-        template_folder: t.Optional[str] = None,
+        template_folder: t.Optional[t.Union[str, os.PathLike]] = None,
         root_path: t.Optional[str] = None,
     ):
         #: The name of the package or module that this object belongs
@@ -130,7 +130,7 @@ class Scaffold:
         self.view_functions: t.Dict[str, t.Callable] = {}
 
         #: A data structure of registered error handlers, in the format
-        #: ``{scope: {code: {class: handler}}}```. The ``scope`` key is
+        #: ``{scope: {code: {class: handler}}}``. The ``scope`` key is
         #: the name of a blueprint the handlers are active for, or
         #: ``None`` for all requests. The ``code`` key is the HTTP
         #: status code for ``HTTPException``, or ``None`` for
@@ -143,8 +143,8 @@ class Scaffold:
         #: This data structure is internal. It should not be modified
         #: directly and its format may change at any time.
         self.error_handler_spec: t.Dict[
-            AppOrBlueprintKey,
-            t.Dict[t.Optional[int], t.Dict[t.Type[Exception], "ErrorHandlerCallable"]],
+            ft.AppOrBlueprintKey,
+            t.Dict[t.Optional[int], t.Dict[t.Type[Exception], ft.ErrorHandlerCallable]],
         ] = defaultdict(lambda: defaultdict(dict))
 
         #: A data structure of functions to call at the beginning of
@@ -158,7 +158,7 @@ class Scaffold:
         #: This data structure is internal. It should not be modified
         #: directly and its format may change at any time.
         self.before_request_funcs: t.Dict[
-            AppOrBlueprintKey, t.List[BeforeRequestCallable]
+            ft.AppOrBlueprintKey, t.List[ft.BeforeRequestCallable]
         ] = defaultdict(list)
 
         #: A data structure of functions to call at the end of each
@@ -172,7 +172,7 @@ class Scaffold:
         #: This data structure is internal. It should not be modified
         #: directly and its format may change at any time.
         self.after_request_funcs: t.Dict[
-            AppOrBlueprintKey, t.List[AfterRequestCallable]
+            ft.AppOrBlueprintKey, t.List[ft.AfterRequestCallable]
         ] = defaultdict(list)
 
         #: A data structure of functions to call at the end of each
@@ -187,7 +187,7 @@ class Scaffold:
         #: This data structure is internal. It should not be modified
         #: directly and its format may change at any time.
         self.teardown_request_funcs: t.Dict[
-            AppOrBlueprintKey, t.List[TeardownCallable]
+            ft.AppOrBlueprintKey, t.List[ft.TeardownCallable]
         ] = defaultdict(list)
 
         #: A data structure of functions to call to pass extra context
@@ -202,7 +202,7 @@ class Scaffold:
         #: This data structure is internal. It should not be modified
         #: directly and its format may change at any time.
         self.template_context_processors: t.Dict[
-            AppOrBlueprintKey, t.List[TemplateContextProcessorCallable]
+            ft.AppOrBlueprintKey, t.List[ft.TemplateContextProcessorCallable]
         ] = defaultdict(list, {None: [_default_template_ctx_processor]})
 
         #: A data structure of functions to call to modify the keyword
@@ -217,8 +217,8 @@ class Scaffold:
         #: This data structure is internal. It should not be modified
         #: directly and its format may change at any time.
         self.url_value_preprocessors: t.Dict[
-            AppOrBlueprintKey,
-            t.List[URLValuePreprocessorCallable],
+            ft.AppOrBlueprintKey,
+            t.List[ft.URLValuePreprocessorCallable],
         ] = defaultdict(list)
 
         #: A data structure of functions to call to modify the keyword
@@ -233,13 +233,13 @@ class Scaffold:
         #: This data structure is internal. It should not be modified
         #: directly and its format may change at any time.
         self.url_default_functions: t.Dict[
-            AppOrBlueprintKey, t.List[URLDefaultCallable]
+            ft.AppOrBlueprintKey, t.List[ft.URLDefaultCallable]
         ] = defaultdict(list)
 
     def __repr__(self) -> str:
         return f"<{type(self).__name__} {self.name!r}>"
 
-    def _is_setup_finished(self) -> bool:
+    def _check_setup_finished(self, f_name: str) -> None:
         raise NotImplementedError
 
     @property
@@ -304,12 +304,15 @@ class Scaffold:
 
         .. versionadded:: 0.9
         """
-        value = current_app.send_file_max_age_default
+        value = current_app.config["SEND_FILE_MAX_AGE_DEFAULT"]
 
         if value is None:
             return None
 
-        return int(value.total_seconds())
+        if isinstance(value, timedelta):
+            return int(value.total_seconds())
+
+        return value
 
     def send_static_file(self, filename: str) -> "Response":
         """The view function used to serve files from
@@ -370,48 +373,54 @@ class Scaffold:
         method: str,
         rule: str,
         options: dict,
-    ) -> t.Callable[[F], F]:
+    ) -> t.Callable[[T_route], T_route]:
         if "methods" in options:
             raise TypeError("Use the 'route' decorator to use the 'methods' argument.")
 
         return self.route(rule, methods=[method], **options)
 
-    def get(self, rule: str, **options: t.Any) -> t.Callable[[F], F]:
+    @setupmethod
+    def get(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:
         """Shortcut for :meth:`route` with ``methods=["GET"]``.
 
         .. versionadded:: 2.0
         """
         return self._method_route("GET", rule, options)
 
-    def post(self, rule: str, **options: t.Any) -> t.Callable[[F], F]:
+    @setupmethod
+    def post(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:
         """Shortcut for :meth:`route` with ``methods=["POST"]``.
 
         .. versionadded:: 2.0
         """
         return self._method_route("POST", rule, options)
 
-    def put(self, rule: str, **options: t.Any) -> t.Callable[[F], F]:
+    @setupmethod
+    def put(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:
         """Shortcut for :meth:`route` with ``methods=["PUT"]``.
 
         .. versionadded:: 2.0
         """
         return self._method_route("PUT", rule, options)
 
-    def delete(self, rule: str, **options: t.Any) -> t.Callable[[F], F]:
+    @setupmethod
+    def delete(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:
         """Shortcut for :meth:`route` with ``methods=["DELETE"]``.
 
         .. versionadded:: 2.0
         """
         return self._method_route("DELETE", rule, options)
 
-    def patch(self, rule: str, **options: t.Any) -> t.Callable[[F], F]:
+    @setupmethod
+    def patch(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:
         """Shortcut for :meth:`route` with ``methods=["PATCH"]``.
 
         .. versionadded:: 2.0
         """
         return self._method_route("PATCH", rule, options)
 
-    def route(self, rule: str, **options: t.Any) -> t.Callable[[F], F]:
+    @setupmethod
+    def route(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:
         """Decorate a view function to register it with the given URL
         rule and options. Calls :meth:`add_url_rule`, which has more
         details about the implementation.
@@ -435,7 +444,7 @@ class Scaffold:
             :class:`~werkzeug.routing.Rule` object.
         """
 
-        def decorator(f: F) -> F:
+        def decorator(f: T_route) -> T_route:
             endpoint = options.pop("endpoint", None)
             self.add_url_rule(rule, endpoint, f, **options)
             return f
@@ -447,7 +456,7 @@ class Scaffold:
         self,
         rule: str,
         endpoint: t.Optional[str] = None,
-        view_func: t.Optional[t.Callable] = None,
+        view_func: t.Optional[ft.RouteCallable] = None,
         provide_automatic_options: t.Optional[bool] = None,
         **options: t.Any,
     ) -> None:
@@ -510,7 +519,8 @@ class Scaffold:
         """
         raise NotImplementedError
 
-    def endpoint(self, endpoint: str) -> t.Callable:
+    @setupmethod
+    def endpoint(self, endpoint: str) -> t.Callable[[F], F]:
         """Decorate a view function to register it for the given
         endpoint. Used if a rule is added without a ``view_func`` with
         :meth:`add_url_rule`.
@@ -527,14 +537,14 @@ class Scaffold:
             function.
         """
 
-        def decorator(f):
+        def decorator(f: F) -> F:
             self.view_functions[endpoint] = f
             return f
 
         return decorator
 
     @setupmethod
-    def before_request(self, f: BeforeRequestCallable) -> BeforeRequestCallable:
+    def before_request(self, f: T_before_request) -> T_before_request:
         """Register a function to run before each request.
 
         For example, this can be used to open a database connection, or
@@ -551,12 +561,17 @@ class Scaffold:
         a non-``None`` value, the value is handled as if it was the
         return value from the view, and further request handling is
         stopped.
+
+        This is available on both app and blueprint objects. When used on an app, this
+        executes before every request. When used on a blueprint, this executes before
+        every request that the blueprint handles. To register with a blueprint and
+        execute before every request, use :meth:`.Blueprint.before_app_request`.
         """
         self.before_request_funcs.setdefault(None, []).append(f)
         return f
 
     @setupmethod
-    def after_request(self, f: AfterRequestCallable) -> AfterRequestCallable:
+    def after_request(self, f: T_after_request) -> T_after_request:
         """Register a function to run after each request to this object.
 
         The function is called with the response object, and must return
@@ -567,61 +582,71 @@ class Scaffold:
         ``after_request`` functions will not be called. Therefore, this
         should not be used for actions that must execute, such as to
         close resources. Use :meth:`teardown_request` for that.
+
+        This is available on both app and blueprint objects. When used on an app, this
+        executes after every request. When used on a blueprint, this executes after
+        every request that the blueprint handles. To register with a blueprint and
+        execute after every request, use :meth:`.Blueprint.after_app_request`.
         """
         self.after_request_funcs.setdefault(None, []).append(f)
         return f
 
     @setupmethod
-    def teardown_request(self, f: TeardownCallable) -> TeardownCallable:
-        """Register a function to be run at the end of each request,
-        regardless of whether there was an exception or not.  These functions
-        are executed when the request context is popped, even if not an
-        actual request was performed.
+    def teardown_request(self, f: T_teardown) -> T_teardown:
+        """Register a function to be called when the request context is
+        popped. Typically this happens at the end of each request, but
+        contexts may be pushed manually as well during testing.
 
-        Example::
+        .. code-block:: python
 
-            ctx = app.test_request_context()
-            ctx.push()
-            ...
-            ctx.pop()
+            with app.test_request_context():
+                ...
 
-        When ``ctx.pop()`` is executed in the above example, the teardown
-        functions are called just before the request context moves from the
-        stack of active contexts.  This becomes relevant if you are using
-        such constructs in tests.
+        When the ``with`` block exits (or ``ctx.pop()`` is called), the
+        teardown functions are called just before the request context is
+        made inactive.
 
-        Teardown functions must avoid raising exceptions. If
-        they execute code that might fail they
-        will have to surround the execution of that code with try/except
-        statements and log any errors.
+        When a teardown function was called because of an unhandled
+        exception it will be passed an error object. If an
+        :meth:`errorhandler` is registered, it will handle the exception
+        and the teardown will not receive it.
 
-        When a teardown function was called because of an exception it will
-        be passed an error object.
+        Teardown functions must avoid raising exceptions. If they
+        execute code that might fail they must surround that code with a
+        ``try``/``except`` block and log any errors.
 
         The return values of teardown functions are ignored.
 
-        .. admonition:: Debug Note
-
-           In debug mode Flask will not tear down a request on an exception
-           immediately.  Instead it will keep it alive so that the interactive
-           debugger can still access it.  This behavior can be controlled
-           by the ``PRESERVE_CONTEXT_ON_EXCEPTION`` configuration variable.
+        This is available on both app and blueprint objects. When used on an app, this
+        executes after every request. When used on a blueprint, this executes after
+        every request that the blueprint handles. To register with a blueprint and
+        execute after every request, use :meth:`.Blueprint.teardown_app_request`.
         """
         self.teardown_request_funcs.setdefault(None, []).append(f)
         return f
 
     @setupmethod
     def context_processor(
-        self, f: TemplateContextProcessorCallable
-    ) -> TemplateContextProcessorCallable:
-        """Registers a template context processor function."""
+        self,
+        f: T_template_context_processor,
+    ) -> T_template_context_processor:
+        """Registers a template context processor function. These functions run before
+        rendering a template. The keys of the returned dict are added as variables
+        available in the template.
+
+        This is available on both app and blueprint objects. When used on an app, this
+        is called for every rendered template. When used on a blueprint, this is called
+        for templates rendered from the blueprint's views. To register with a blueprint
+        and affect every template, use :meth:`.Blueprint.app_context_processor`.
+        """
         self.template_context_processors[None].append(f)
         return f
 
     @setupmethod
     def url_value_preprocessor(
-        self, f: URLValuePreprocessorCallable
-    ) -> URLValuePreprocessorCallable:
+        self,
+        f: T_url_value_preprocessor,
+    ) -> T_url_value_preprocessor:
         """Register a URL value preprocessor function for all view
         functions in the application. These functions will be called before the
         :meth:`before_request` functions.
@@ -633,15 +658,25 @@ class Scaffold:
 
         The function is passed the endpoint name and values dict. The return
         value is ignored.
+
+        This is available on both app and blueprint objects. When used on an app, this
+        is called for every request. When used on a blueprint, this is called for
+        requests that the blueprint handles. To register with a blueprint and affect
+        every request, use :meth:`.Blueprint.app_url_value_preprocessor`.
         """
         self.url_value_preprocessors[None].append(f)
         return f
 
     @setupmethod
-    def url_defaults(self, f: URLDefaultCallable) -> URLDefaultCallable:
+    def url_defaults(self, f: T_url_defaults) -> T_url_defaults:
         """Callback function for URL defaults for all view functions of the
         application.  It's called with the endpoint and values and should
         update the values passed in place.
+
+        This is available on both app and blueprint objects. When used on an app, this
+        is called for every request. When used on a blueprint, this is called for
+        requests that the blueprint handles. To register with a blueprint and affect
+        every request, use :meth:`.Blueprint.app_url_defaults`.
         """
         self.url_default_functions[None].append(f)
         return f
@@ -649,7 +684,7 @@ class Scaffold:
     @setupmethod
     def errorhandler(
         self, code_or_exception: t.Union[t.Type[Exception], int]
-    ) -> t.Callable[["ErrorHandlerCallable"], "ErrorHandlerCallable"]:
+    ) -> t.Callable[[T_error_handler], T_error_handler]:
         """Register a function to handle errors by code or exception class.
 
         A decorator that is used to register a function given an
@@ -665,6 +700,11 @@ class Scaffold:
             def special_exception_handler(error):
                 return 'Database connection failed', 500
 
+        This is available on both app and blueprint objects. When used on an app, this
+        can handle errors from every request. When used on a blueprint, this can handle
+        errors from requests that the blueprint handles. To register with a blueprint
+        and affect every request, use :meth:`.Blueprint.app_errorhandler`.
+
         .. versionadded:: 0.7
             Use :meth:`register_error_handler` instead of modifying
             :attr:`error_handler_spec` directly, for application wide error
@@ -679,7 +719,7 @@ class Scaffold:
                                   an arbitrary exception
         """
 
-        def decorator(f: "ErrorHandlerCallable") -> "ErrorHandlerCallable":
+        def decorator(f: T_error_handler) -> T_error_handler:
             self.register_error_handler(code_or_exception, f)
             return f
 
@@ -689,7 +729,7 @@ class Scaffold:
     def register_error_handler(
         self,
         code_or_exception: t.Union[t.Type[Exception], int],
-        f: "ErrorHandlerCallable",
+        f: ft.ErrorHandlerCallable,
     ) -> None:
         """Alternative error attach function to the :meth:`errorhandler`
         decorator that is more straightforward to use for non decorator
@@ -697,22 +737,7 @@ class Scaffold:
 
         .. versionadded:: 0.7
         """
-        if isinstance(code_or_exception, HTTPException):  # old broken behavior
-            raise ValueError(
-                "Tried to register a handler for an exception instance"
-                f" {code_or_exception!r}. Handlers can only be"
-                " registered for exception classes or HTTP error codes."
-            )
-
-        try:
-            exc_class, code = self._get_exc_class_and_code(code_or_exception)
-        except KeyError:
-            raise KeyError(
-                f"'{code_or_exception}' is not a recognized HTTP error"
-                " code. Use a subclass of HTTPException with that code"
-                " instead."
-            ) from None
-
+        exc_class, code = self._get_exc_class_and_code(code_or_exception)
         self.error_handler_spec[None][code][exc_class] = f
 
     @staticmethod
@@ -727,14 +752,32 @@ class Scaffold:
             code as an integer.
         """
         exc_class: t.Type[Exception]
+
         if isinstance(exc_class_or_code, int):
-            exc_class = default_exceptions[exc_class_or_code]
+            try:
+                exc_class = default_exceptions[exc_class_or_code]
+            except KeyError:
+                raise ValueError(
+                    f"'{exc_class_or_code}' is not a recognized HTTP"
+                    " error code. Use a subclass of HTTPException with"
+                    " that code instead."
+                ) from None
         else:
             exc_class = exc_class_or_code
 
-        assert issubclass(
-            exc_class, Exception
-        ), "Custom exceptions must be subclasses of Exception."
+        if isinstance(exc_class, Exception):
+            raise TypeError(
+                f"{exc_class!r} is an instance, not a class. Handlers"
+                " can only be registered for Exception classes or HTTP"
+                " error codes."
+            )
+
+        if not issubclass(exc_class, Exception):
+            raise ValueError(
+                f"'{exc_class.__name__}' is not a subclass of Exception."
+                " Handlers can only be registered for Exception classes"
+                " or HTTP error codes."
+            )
 
         if issubclass(exc_class, HTTPException):
             return exc_class, exc_class.code
@@ -775,30 +818,55 @@ def _matching_loader_thinks_module_is_package(loader, mod_name):
     )
 
 
-def _find_package_path(root_mod_name):
+def _path_is_relative_to(path: pathlib.PurePath, base: str) -> bool:
+    # Path.is_relative_to doesn't exist until Python 3.9
+    try:
+        path.relative_to(base)
+        return True
+    except ValueError:
+        return False
+
+
+def _find_package_path(import_name):
     """Find the path that contains the package or module."""
+    root_mod_name, _, _ = import_name.partition(".")
+
     try:
-        spec = importlib.util.find_spec(root_mod_name)
+        root_spec = importlib.util.find_spec(root_mod_name)
 
-        if spec is None:
+        if root_spec is None:
             raise ValueError("not found")
     # ImportError: the machinery told us it does not exist
     # ValueError:
     #    - the module name was invalid
     #    - the module name is __main__
-    #    - *we* raised `ValueError` due to `spec` being `None`
+    #    - *we* raised `ValueError` due to `root_spec` being `None`
     except (ImportError, ValueError):
         pass  # handled below
     else:
         # namespace package
-        if spec.origin in {"namespace", None}:
-            return os.path.dirname(next(iter(spec.submodule_search_locations)))
+        if root_spec.origin in {"namespace", None}:
+            package_spec = importlib.util.find_spec(import_name)
+            if package_spec is not None and package_spec.submodule_search_locations:
+                # Pick the path in the namespace that contains the submodule.
+                package_path = pathlib.Path(
+                    os.path.commonpath(package_spec.submodule_search_locations)
+                )
+                search_locations = (
+                    location
+                    for location in root_spec.submodule_search_locations
+                    if _path_is_relative_to(package_path, location)
+                )
+            else:
+                # Pick the first path.
+                search_locations = iter(root_spec.submodule_search_locations)
+            return os.path.dirname(next(search_locations))
         # a package (with __init__.py)
-        elif spec.submodule_search_locations:
-            return os.path.dirname(os.path.dirname(spec.origin))
+        elif root_spec.submodule_search_locations:
+            return os.path.dirname(os.path.dirname(root_spec.origin))
         # just a normal module
         else:
-            return os.path.dirname(spec.origin)
+            return os.path.dirname(root_spec.origin)
 
     # we were unable to find the `package_path` using PEP 451 loaders
     loader = pkgutil.get_loader(root_mod_name)
@@ -840,12 +908,11 @@ def find_package(import_name: str):
     for import. If the package is not installed, it's assumed that the
     package was imported from the current working directory.
     """
-    root_mod_name, _, _ = import_name.partition(".")
-    package_path = _find_package_path(root_mod_name)
+    package_path = _find_package_path(import_name)
     py_prefix = os.path.abspath(sys.prefix)
 
     # installed to the system
-    if package_path.startswith(py_prefix):
+    if _path_is_relative_to(pathlib.PurePath(package_path), py_prefix):
         return py_prefix, package_path
 
     site_parent, site_folder = os.path.split(package_path)
diff --git a/src/flask/sessions.py b/src/flask/sessions.py
index 4e19270e..02b8cf76 100644
--- a/src/flask/sessions.py
+++ b/src/flask/sessions.py
@@ -3,6 +3,7 @@ import typing as t
 import warnings
 from collections.abc import MutableMapping
 from datetime import datetime
+from datetime import timezone
 
 from itsdangerous import BadSignature
 from itsdangerous import URLSafeTimedSerializer
@@ -11,7 +12,7 @@ from werkzeug.datastructures import CallbackDict
 from .helpers import is_ip
 from .json.tag import TaggedJSONSerializer
 
-if t.TYPE_CHECKING:
+if t.TYPE_CHECKING:  # pragma: no cover
     import typing_extensions as te
     from .app import Flask
     from .wrappers import Request, Response
@@ -176,11 +177,8 @@ class SessionInterface:
         return isinstance(obj, self.null_session_class)
 
     def get_cookie_name(self, app: "Flask") -> str:
-        """Returns the name of the session cookie.
-
-        Uses ``app.session_cookie_name`` which is set to ``SESSION_COOKIE_NAME``
-        """
-        return app.session_cookie_name
+        """The name of the session cookie. Uses``app.config["SESSION_COOKIE_NAME"]``."""
+        return app.config["SESSION_COOKIE_NAME"]
 
     def get_cookie_domain(self, app: "Flask") -> t.Optional[str]:
         """Returns the domain that should be set for the session cookie.
@@ -277,7 +275,7 @@ class SessionInterface:
         lifetime configured on the application.
         """
         if session.permanent:
-            return datetime.utcnow() + app.permanent_session_lifetime
+            return datetime.now(timezone.utc) + app.permanent_session_lifetime
         return None
 
     def should_set_cookie(self, app: "Flask", session: SessionMixin) -> bool:
diff --git a/src/flask/templating.py b/src/flask/templating.py
index b39adb77..25cc3f95 100644
--- a/src/flask/templating.py
+++ b/src/flask/templating.py
@@ -5,12 +5,15 @@ from jinja2 import Environment as BaseEnvironment
 from jinja2 import Template
 from jinja2 import TemplateNotFound
 
-from .globals import _app_ctx_stack
-from .globals import _request_ctx_stack
+from .globals import _cv_app
+from .globals import _cv_request
+from .globals import current_app
+from .globals import request
+from .helpers import stream_with_context
 from .signals import before_render_template
 from .signals import template_rendered
 
-if t.TYPE_CHECKING:
+if t.TYPE_CHECKING:  # pragma: no cover
     from .app import Flask
     from .scaffold import Scaffold
 
@@ -19,9 +22,9 @@ def _default_template_ctx_processor() -> t.Dict[str, t.Any]:
     """Default template context processor.  Injects `request`,
     `session` and `g`.
     """
-    reqctx = _request_ctx_stack.top
-    appctx = _app_ctx_stack.top
-    rv = {}
+    appctx = _cv_app.get(None)
+    reqctx = _cv_request.get(None)
+    rv: t.Dict[str, t.Any] = {}
     if appctx is not None:
         rv["g"] = appctx.g
     if reqctx is not None:
@@ -121,9 +124,8 @@ class DispatchingJinjaLoader(BaseLoader):
         return list(result)
 
 
-def _render(template: Template, context: dict, app: "Flask") -> str:
-    """Renders the template and fires the signal"""
-
+def _render(app: "Flask", template: Template, context: t.Dict[str, t.Any]) -> str:
+    app.update_template_context(context)
     before_render_template.send(app, template=template, context=context)
     rv = template.render(context)
     template_rendered.send(app, template=template, context=context)
@@ -134,33 +136,77 @@ def render_template(
     template_name_or_list: t.Union[str, Template, t.List[t.Union[str, Template]]],
     **context: t.Any
 ) -> str:
-    """Renders a template from the template folder with the given
-    context.
+    """Render a template by name with the given context.
 
-    :param template_name_or_list: the name of the template to be
-                                  rendered, or an iterable with template names
-                                  the first one existing will be rendered
-    :param context: the variables that should be available in the
-                    context of the template.
+    :param template_name_or_list: The name of the template to render. If
+        a list is given, the first name to exist will be rendered.
+    :param context: The variables to make available in the template.
     """
-    ctx = _app_ctx_stack.top
-    ctx.app.update_template_context(context)
-    return _render(
-        ctx.app.jinja_env.get_or_select_template(template_name_or_list),
-        context,
-        ctx.app,
-    )
+    app = current_app._get_current_object()  # type: ignore[attr-defined]
+    template = app.jinja_env.get_or_select_template(template_name_or_list)
+    return _render(app, template, context)
 
 
 def render_template_string(source: str, **context: t.Any) -> str:
-    """Renders a template from the given template source string
-    with the given context. Template variables will be autoescaped.
+    """Render a template from the given source string with the given
+    context.
+
+    :param source: The source code of the template to render.
+    :param context: The variables to make available in the template.
+    """
+    app = current_app._get_current_object()  # type: ignore[attr-defined]
+    template = app.jinja_env.from_string(source)
+    return _render(app, template, context)
+
+
+def _stream(
+    app: "Flask", template: Template, context: t.Dict[str, t.Any]
+) -> t.Iterator[str]:
+    app.update_template_context(context)
+    before_render_template.send(app, template=template, context=context)
+
+    def generate() -> t.Iterator[str]:
+        yield from template.generate(context)
+        template_rendered.send(app, template=template, context=context)
+
+    rv = generate()
+
+    # If a request context is active, keep it while generating.
+    if request:
+        rv = stream_with_context(rv)
+
+    return rv
+
+
+def stream_template(
+    template_name_or_list: t.Union[str, Template, t.List[t.Union[str, Template]]],
+    **context: t.Any
+) -> t.Iterator[str]:
+    """Render a template by name with the given context as a stream.
+    This returns an iterator of strings, which can be used as a
+    streaming response from a view.
+
+    :param template_name_or_list: The name of the template to render. If
+        a list is given, the first name to exist will be rendered.
+    :param context: The variables to make available in the template.
+
+    .. versionadded:: 2.2
+    """
+    app = current_app._get_current_object()  # type: ignore[attr-defined]
+    template = app.jinja_env.get_or_select_template(template_name_or_list)
+    return _stream(app, template, context)
+
+
+def stream_template_string(source: str, **context: t.Any) -> t.Iterator[str]:
+    """Render a template from the given source string with the given
+    context as a stream. This returns an iterator of strings, which can
+    be used as a streaming response from a view.
+
+    :param source: The source code of the template to render.
+    :param context: The variables to make available in the template.
 
-    :param source: the source code of the template to be
-                   rendered
-    :param context: the variables that should be available in the
-                    context of the template.
+    .. versionadded:: 2.2
     """
-    ctx = _app_ctx_stack.top
-    ctx.app.update_template_context(context)
-    return _render(ctx.app.jinja_env.from_string(source), context, ctx.app)
+    app = current_app._get_current_object()  # type: ignore[attr-defined]
+    template = app.jinja_env.from_string(source)
+    return _stream(app, template, context)
diff --git a/src/flask/testing.py b/src/flask/testing.py
index e07e50e7..3b21b093 100644
--- a/src/flask/testing.py
+++ b/src/flask/testing.py
@@ -1,5 +1,6 @@
 import typing as t
 from contextlib import contextmanager
+from contextlib import ExitStack
 from copy import copy
 from types import TracebackType
 
@@ -10,11 +11,10 @@ from werkzeug.urls import url_parse
 from werkzeug.wrappers import Request as BaseRequest
 
 from .cli import ScriptInfo
-from .globals import _request_ctx_stack
-from .json import dumps as json_dumps
+from .globals import _cv_request
 from .sessions import SessionMixin
 
-if t.TYPE_CHECKING:
+if t.TYPE_CHECKING:  # pragma: no cover
     from werkzeug.test import TestResponse
 
     from .app import Flask
@@ -88,16 +88,14 @@ class EnvironBuilder(werkzeug.test.EnvironBuilder):
         The serialization will be configured according to the config associated
         with this EnvironBuilder's ``app``.
         """
-        kwargs.setdefault("app", self.app)
-        return json_dumps(obj, **kwargs)
+        return self.app.json.dumps(obj, **kwargs)
 
 
 class FlaskClient(Client):
-    """Works like a regular Werkzeug test client but has some knowledge about
-    how Flask works to defer the cleanup of the request context stack to the
-    end of a ``with`` body when used in a ``with`` statement.  For general
-    information about how to use this class refer to
-    :class:`werkzeug.test.Client`.
+    """Works like a regular Werkzeug test client but has knowledge about
+    Flask's contexts to defer the cleanup of the request context until
+    the end of a ``with`` block. For general information about how to
+    use this class refer to :class:`werkzeug.test.Client`.
 
     .. versionchanged:: 0.12
        `app.test_client()` includes preset default environment, which can be
@@ -108,10 +106,12 @@ class FlaskClient(Client):
     """
 
     application: "Flask"
-    preserve_context = False
 
     def __init__(self, *args: t.Any, **kwargs: t.Any) -> None:
         super().__init__(*args, **kwargs)
+        self.preserve_context = False
+        self._new_contexts: t.List[t.ContextManager[t.Any]] = []
+        self._context_stack = ExitStack()
         self.environ_base = {
             "REMOTE_ADDR": "127.0.0.1",
             "HTTP_USER_AGENT": f"werkzeug/{werkzeug.__version__}",
@@ -144,7 +144,7 @@ class FlaskClient(Client):
         app = self.application
         environ_overrides = kwargs.setdefault("environ_overrides", {})
         self.cookie_jar.inject_wsgi(environ_overrides)
-        outer_reqctx = _request_ctx_stack.top
+        outer_reqctx = _cv_request.get(None)
         with app.test_request_context(*args, **kwargs) as c:
             session_interface = app.session_interface
             sess = session_interface.open_session(app, c.request)
@@ -160,11 +160,11 @@ class FlaskClient(Client):
             # behavior.  It's important to not use the push and pop
             # methods of the actual request context object since that would
             # mean that cleanup handlers are called
-            _request_ctx_stack.push(outer_reqctx)
+            token = _cv_request.set(outer_reqctx)  # type: ignore[arg-type]
             try:
                 yield sess
             finally:
-                _request_ctx_stack.pop()
+                _cv_request.reset(token)
 
             resp = app.response_class()
             if not session_interface.is_null_session(sess):
@@ -173,11 +173,12 @@ class FlaskClient(Client):
             self.cookie_jar.extract_wsgi(c.request.environ, headers)
 
     def _copy_environ(self, other):
-        return {
-            **self.environ_base,
-            **other,
-            "flask._preserve_context": self.preserve_context,
-        }
+        out = {**self.environ_base, **other}
+
+        if self.preserve_context:
+            out["werkzeug.debug.preserve_context"] = self._new_contexts.append
+
+        return out
 
     def _request_from_builder_args(self, args, kwargs):
         kwargs["environ_base"] = self._copy_environ(kwargs.get("environ_base", {}))
@@ -214,11 +215,24 @@ class FlaskClient(Client):
             # request is None
             request = self._request_from_builder_args(args, kwargs)
 
-        return super().open(
+        # Pop any previously preserved contexts. This prevents contexts
+        # from being preserved across redirects or multiple requests
+        # within a single block.
+        self._context_stack.close()
+
+        response = super().open(
             request,
             buffered=buffered,
             follow_redirects=follow_redirects,
         )
+        response.json_module = self.application.json  # type: ignore[assignment]
+
+        # Re-push contexts that were preserved during the request.
+        while self._new_contexts:
+            cm = self._new_contexts.pop()
+            self._context_stack.enter_context(cm)
+
+        return response
 
     def __enter__(self) -> "FlaskClient":
         if self.preserve_context:
@@ -233,18 +247,7 @@ class FlaskClient(Client):
         tb: t.Optional[TracebackType],
     ) -> None:
         self.preserve_context = False
-
-        # Normally the request context is preserved until the next
-        # request in the same thread comes. When the client exits we
-        # want to clean up earlier. Pop request contexts until the stack
-        # is empty or a non-preserved one is found.
-        while True:
-            top = _request_ctx_stack.top
-
-            if top is not None and top.preserved:
-                top.pop()
-            else:
-                break
+        self._context_stack.close()
 
 
 class FlaskCliRunner(CliRunner):
diff --git a/src/flask/typing.py b/src/flask/typing.py
index a839a7e4..8857598e 100644
--- a/src/flask/typing.py
+++ b/src/flask/typing.py
@@ -1,51 +1,71 @@
 import typing as t
 
-
-if t.TYPE_CHECKING:
+if t.TYPE_CHECKING:  # pragma: no cover
     from _typeshed.wsgi import WSGIApplication  # noqa: F401
     from werkzeug.datastructures import Headers  # noqa: F401
-    from werkzeug.wrappers.response import Response  # noqa: F401
+    from werkzeug.wrappers import Response  # noqa: F401
 
 # The possible types that are directly convertible or are a Response object.
 ResponseValue = t.Union[
     "Response",
     str,
     bytes,
-    t.Dict[str, t.Any],  # any jsonify-able dict
+    t.List[t.Any],
+    # Only dict is actually accepted, but Mapping allows for TypedDict.
+    t.Mapping[str, t.Any],
     t.Iterator[str],
     t.Iterator[bytes],
 ]
-StatusCode = int
 
 # the possible types for an individual HTTP header
-HeaderName = str
+# This should be a Union, but mypy doesn't pass unless it's a TypeVar.
 HeaderValue = t.Union[str, t.List[str], t.Tuple[str, ...]]
 
 # the possible types for HTTP headers
 HeadersValue = t.Union[
-    "Headers", t.Dict[HeaderName, HeaderValue], t.List[t.Tuple[HeaderName, HeaderValue]]
+    "Headers",
+    t.Mapping[str, HeaderValue],
+    t.Sequence[t.Tuple[str, HeaderValue]],
 ]
 
 # The possible types returned by a route function.
 ResponseReturnValue = t.Union[
     ResponseValue,
     t.Tuple[ResponseValue, HeadersValue],
-    t.Tuple[ResponseValue, StatusCode],
-    t.Tuple[ResponseValue, StatusCode, HeadersValue],
+    t.Tuple[ResponseValue, int],
+    t.Tuple[ResponseValue, int, HeadersValue],
     "WSGIApplication",
 ]
 
+# Allow any subclass of werkzeug.Response, such as the one from Flask,
+# as a callback argument. Using werkzeug.Response directly makes a
+# callback annotated with flask.Response fail type checking.
+ResponseClass = t.TypeVar("ResponseClass", bound="Response")
+
 AppOrBlueprintKey = t.Optional[str]  # The App key is None, whereas blueprints are named
-AfterRequestCallable = t.Callable[["Response"], "Response"]
-BeforeFirstRequestCallable = t.Callable[[], None]
-BeforeRequestCallable = t.Callable[[], t.Optional[ResponseReturnValue]]
-TeardownCallable = t.Callable[[t.Optional[BaseException]], None]
+AfterRequestCallable = t.Union[
+    t.Callable[[ResponseClass], ResponseClass],
+    t.Callable[[ResponseClass], t.Awaitable[ResponseClass]],
+]
+BeforeFirstRequestCallable = t.Union[
+    t.Callable[[], None], t.Callable[[], t.Awaitable[None]]
+]
+BeforeRequestCallable = t.Union[
+    t.Callable[[], t.Optional[ResponseReturnValue]],
+    t.Callable[[], t.Awaitable[t.Optional[ResponseReturnValue]]],
+]
+ShellContextProcessorCallable = t.Callable[[], t.Dict[str, t.Any]]
+TeardownCallable = t.Union[
+    t.Callable[[t.Optional[BaseException]], None],
+    t.Callable[[t.Optional[BaseException]], t.Awaitable[None]],
+]
 TemplateContextProcessorCallable = t.Callable[[], t.Dict[str, t.Any]]
 TemplateFilterCallable = t.Callable[..., t.Any]
 TemplateGlobalCallable = t.Callable[..., t.Any]
 TemplateTestCallable = t.Callable[..., bool]
 URLDefaultCallable = t.Callable[[str, dict], None]
 URLValuePreprocessorCallable = t.Callable[[t.Optional[str], t.Optional[dict]], None]
+
 # This should take Exception, but that either breaks typing the argument
 # with a specific exception, or decorating multiple times with different
 # exceptions (and using a union type on the argument).
@@ -53,3 +73,8 @@ URLValuePreprocessorCallable = t.Callable[[t.Optional[str], t.Optional[dict]], N
 # https://github.com/pallets/flask/issues/4295
 # https://github.com/pallets/flask/issues/4297
 ErrorHandlerCallable = t.Callable[[t.Any], ResponseReturnValue]
+
+RouteCallable = t.Union[
+    t.Callable[..., ResponseReturnValue],
+    t.Callable[..., t.Awaitable[ResponseReturnValue]],
+]
diff --git a/src/flask/views.py b/src/flask/views.py
index 1bd5c68b..f86172b4 100644
--- a/src/flask/views.py
+++ b/src/flask/views.py
@@ -1,8 +1,8 @@
 import typing as t
 
+from . import typing as ft
 from .globals import current_app
 from .globals import request
-from .typing import ResponseReturnValue
 
 
 http_method_funcs = frozenset(
@@ -11,77 +11,106 @@ http_method_funcs = frozenset(
 
 
 class View:
-    """Alternative way to use view functions.  A subclass has to implement
-    :meth:`dispatch_request` which is called with the view arguments from
-    the URL routing system.  If :attr:`methods` is provided the methods
-    do not have to be passed to the :meth:`~flask.Flask.add_url_rule`
-    method explicitly::
+    """Subclass this class and override :meth:`dispatch_request` to
+    create a generic class-based view. Call :meth:`as_view` to create a
+    view function that creates an instance of the class with the given
+    arguments and calls its ``dispatch_request`` method with any URL
+    variables.
 
-        class MyView(View):
-            methods = ['GET']
+    See :doc:`views` for a detailed guide.
 
-            def dispatch_request(self, name):
-                return f"Hello {name}!"
+    .. code-block:: python
+
+        class Hello(View):
+            init_every_request = False
 
-        app.add_url_rule('/hello/<name>', view_func=MyView.as_view('myview'))
+            def dispatch_request(self, name):
+                return f"Hello, {name}!"
 
-    When you want to decorate a pluggable view you will have to either do that
-    when the view function is created (by wrapping the return value of
-    :meth:`as_view`) or you can use the :attr:`decorators` attribute::
+        app.add_url_rule(
+            "/hello/<name>", view_func=Hello.as_view("hello")
+        )
 
-        class SecretView(View):
-            methods = ['GET']
-            decorators = [superuser_required]
+    Set :attr:`methods` on the class to change what methods the view
+    accepts.
 
-            def dispatch_request(self):
-                ...
+    Set :attr:`decorators` on the class to apply a list of decorators to
+    the generated view function. Decorators applied to the class itself
+    will not be applied to the generated view function!
 
-    The decorators stored in the decorators list are applied one after another
-    when the view function is created.  Note that you can *not* use the class
-    based decorators since those would decorate the view class and not the
-    generated view function!
+    Set :attr:`init_every_request` to ``False`` for efficiency, unless
+    you need to store request-global data on ``self``.
     """
 
-    #: A list of methods this view can handle.
-    methods: t.Optional[t.List[str]] = None
+    #: The methods this view is registered for. Uses the same default
+    #: (``["GET", "HEAD", "OPTIONS"]``) as ``route`` and
+    #: ``add_url_rule`` by default.
+    methods: t.ClassVar[t.Optional[t.Collection[str]]] = None
 
-    #: Setting this disables or force-enables the automatic options handling.
-    provide_automatic_options: t.Optional[bool] = None
+    #: Control whether the ``OPTIONS`` method is handled automatically.
+    #: Uses the same default (``True``) as ``route`` and
+    #: ``add_url_rule`` by default.
+    provide_automatic_options: t.ClassVar[t.Optional[bool]] = None
 
-    #: The canonical way to decorate class-based views is to decorate the
-    #: return value of as_view().  However since this moves parts of the
-    #: logic from the class declaration to the place where it's hooked
-    #: into the routing system.
-    #:
-    #: You can place one or more decorators in this list and whenever the
-    #: view function is created the result is automatically decorated.
+    #: A list of decorators to apply, in order, to the generated view
+    #: function. Remember that ``@decorator`` syntax is applied bottom
+    #: to top, so the first decorator in the list would be the bottom
+    #: decorator.
     #:
     #: .. versionadded:: 0.8
-    decorators: t.List[t.Callable] = []
+    decorators: t.ClassVar[t.List[t.Callable]] = []
 
-    def dispatch_request(self) -> ResponseReturnValue:
-        """Subclasses have to override this method to implement the
-        actual view function code.  This method is called with all
-        the arguments from the URL rule.
+    #: Create a new instance of this view class for every request by
+    #: default. If a view subclass sets this to ``False``, the same
+    #: instance is used for every request.
+    #:
+    #: A single instance is more efficient, especially if complex setup
+    #: is done during init. However, storing data on ``self`` is no
+    #: longer safe across requests, and :data:`~flask.g` should be used
+    #: instead.
+    #:
+    #: .. versionadded:: 2.2
+    init_every_request: t.ClassVar[bool] = True
+
+    def dispatch_request(self) -> ft.ResponseReturnValue:
+        """The actual view function behavior. Subclasses must override
+        this and return a valid response. Any variables from the URL
+        rule are passed as keyword arguments.
         """
         raise NotImplementedError()
 
     @classmethod
     def as_view(
         cls, name: str, *class_args: t.Any, **class_kwargs: t.Any
-    ) -> t.Callable:
-        """Converts the class into an actual view function that can be used
-        with the routing system.  Internally this generates a function on the
-        fly which will instantiate the :class:`View` on each request and call
-        the :meth:`dispatch_request` method on it.
-
-        The arguments passed to :meth:`as_view` are forwarded to the
-        constructor of the class.
+    ) -> ft.RouteCallable:
+        """Convert the class into a view function that can be registered
+        for a route.
+
+        By default, the generated view will create a new instance of the
+        view class for every request and call its
+        :meth:`dispatch_request` method. If the view class sets
+        :attr:`init_every_request` to ``False``, the same instance will
+        be used for every request.
+
+        Except for ``name``, all other arguments passed to this method
+        are forwarded to the view class ``__init__`` method.
+
+        .. versionchanged:: 2.2
+            Added the ``init_every_request`` class attribute.
         """
+        if cls.init_every_request:
+
+            def view(**kwargs: t.Any) -> ft.ResponseReturnValue:
+                self = view.view_class(  # type: ignore[attr-defined]
+                    *class_args, **class_kwargs
+                )
+                return current_app.ensure_sync(self.dispatch_request)(**kwargs)
+
+        else:
+            self = cls(*class_args, **class_kwargs)
 
-        def view(*args: t.Any, **kwargs: t.Any) -> ResponseReturnValue:
-            self = view.view_class(*class_args, **class_kwargs)  # type: ignore
-            return current_app.ensure_sync(self.dispatch_request)(*args, **kwargs)
+            def view(**kwargs: t.Any) -> ft.ResponseReturnValue:
+                return current_app.ensure_sync(self.dispatch_request)(**kwargs)
 
         if cls.decorators:
             view.__name__ = name
@@ -103,50 +132,51 @@ class View:
         return view
 
 
-class MethodViewType(type):
-    """Metaclass for :class:`MethodView` that determines what methods the view
-    defines.
+class MethodView(View):
+    """Dispatches request methods to the corresponding instance methods.
+    For example, if you implement a ``get`` method, it will be used to
+    handle ``GET`` requests.
+
+    This can be useful for defining a REST API.
+
+    :attr:`methods` is automatically set based on the methods defined on
+    the class.
+
+    See :doc:`views` for a detailed guide.
+
+    .. code-block:: python
+
+        class CounterAPI(MethodView):
+            def get(self):
+                return str(session.get("counter", 0))
+
+            def post(self):
+                session["counter"] = session.get("counter", 0) + 1
+                return redirect(url_for("counter"))
+
+        app.add_url_rule(
+            "/counter", view_func=CounterAPI.as_view("counter")
+        )
     """
 
-    def __init__(cls, name, bases, d):
-        super().__init__(name, bases, d)
+    def __init_subclass__(cls, **kwargs: t.Any) -> None:
+        super().__init_subclass__(**kwargs)
 
-        if "methods" not in d:
+        if "methods" not in cls.__dict__:
             methods = set()
 
-            for base in bases:
+            for base in cls.__bases__:
                 if getattr(base, "methods", None):
-                    methods.update(base.methods)
+                    methods.update(base.methods)  # type: ignore[attr-defined]
 
             for key in http_method_funcs:
                 if hasattr(cls, key):
                     methods.add(key.upper())
 
-            # If we have no method at all in there we don't want to add a
-            # method list. This is for instance the case for the base class
-            # or another subclass of a base method view that does not introduce
-            # new methods.
             if methods:
                 cls.methods = methods
 
-
-class MethodView(View, metaclass=MethodViewType):
-    """A class-based view that dispatches request methods to the corresponding
-    class methods. For example, if you implement a ``get`` method, it will be
-    used to handle ``GET`` requests. ::
-
-        class CounterAPI(MethodView):
-            def get(self):
-                return session.get('counter', 0)
-
-            def post(self):
-                session['counter'] = session.get('counter', 0) + 1
-                return 'OK'
-
-        app.add_url_rule('/counter', view_func=CounterAPI.as_view('counter'))
-    """
-
-    def dispatch_request(self, *args: t.Any, **kwargs: t.Any) -> ResponseReturnValue:
+    def dispatch_request(self, **kwargs: t.Any) -> ft.ResponseReturnValue:
         meth = getattr(self, request.method.lower(), None)
 
         # If the request method is HEAD and we don't have a handler for it
@@ -155,4 +185,4 @@ class MethodView(View, metaclass=MethodViewType):
             meth = getattr(self, "get", None)
 
         assert meth is not None, f"Unimplemented method {request.method!r}"
-        return current_app.ensure_sync(meth)(*args, **kwargs)
+        return current_app.ensure_sync(meth)(**kwargs)
diff --git a/src/flask/wrappers.py b/src/flask/wrappers.py
index 7153876b..e36a72cb 100644
--- a/src/flask/wrappers.py
+++ b/src/flask/wrappers.py
@@ -8,7 +8,7 @@ from . import json
 from .globals import current_app
 from .helpers import _split_blueprint_path
 
-if t.TYPE_CHECKING:
+if t.TYPE_CHECKING:  # pragma: no cover
     from werkzeug.routing import Rule
 
 
@@ -25,7 +25,7 @@ class Request(RequestBase):
     specific ones.
     """
 
-    json_module = json
+    json_module: t.Any = json
 
     #: The internal URL rule that matched the request.  This can be
     #: useful to inspect which methods are allowed for the URL from
diff --git a/tests/conftest.py b/tests/conftest.py
index 17ff2f3d..670acc88 100644
--- a/tests/conftest.py
+++ b/tests/conftest.py
@@ -6,8 +6,8 @@ import textwrap
 import pytest
 from _pytest import monkeypatch
 
-import flask
-from flask import Flask as _Flask
+from flask import Flask
+from flask.globals import request_ctx
 
 
 @pytest.fixture(scope="session", autouse=True)
@@ -18,6 +18,7 @@ def _standard_os_environ():
     """
     mp = monkeypatch.MonkeyPatch()
     out = (
+        (os.environ, "FLASK_ENV_FILE", monkeypatch.notset),
         (os.environ, "FLASK_APP", monkeypatch.notset),
         (os.environ, "FLASK_ENV", monkeypatch.notset),
         (os.environ, "FLASK_DEBUG", monkeypatch.notset),
@@ -43,14 +44,13 @@ def _reset_os_environ(monkeypatch, _standard_os_environ):
     monkeypatch._setitem.extend(_standard_os_environ)
 
 
-class Flask(_Flask):
-    testing = True
-    secret_key = "test key"
-
-
 @pytest.fixture
 def app():
     app = Flask("flask_test", root_path=os.path.dirname(__file__))
+    app.config.update(
+        TESTING=True,
+        SECRET_KEY="test key",
+    )
     return app
 
 
@@ -91,8 +91,10 @@ def leak_detector():
     # make sure we're not leaking a request context since we are
     # testing flask internally in debug mode in a few cases
     leaks = []
-    while flask._request_ctx_stack.top is not None:
-        leaks.append(flask._request_ctx_stack.pop())
+    while request_ctx:
+        leaks.append(request_ctx._get_current_object())
+        request_ctx.pop()
+
     assert leaks == []
 
 
diff --git a/tests/test_appctx.py b/tests/test_appctx.py
index aeb75a55..aa3a8b4e 100644
--- a/tests/test_appctx.py
+++ b/tests/test_appctx.py
@@ -1,6 +1,8 @@
 import pytest
 
 import flask
+from flask.globals import app_ctx
+from flask.globals import request_ctx
 
 
 def test_basic_url_generation(app):
@@ -29,14 +31,14 @@ def test_url_generation_without_context_fails():
 
 def test_request_context_means_app_context(app):
     with app.test_request_context():
-        assert flask.current_app._get_current_object() == app
-    assert flask._app_ctx_stack.top is None
+        assert flask.current_app._get_current_object() is app
+    assert not flask.current_app
 
 
 def test_app_context_provides_current_app(app):
     with app.app_context():
-        assert flask.current_app._get_current_object() == app
-    assert flask._app_ctx_stack.top is None
+        assert flask.current_app._get_current_object() is app
+    assert not flask.current_app
 
 
 def test_app_tearing_down(app):
@@ -118,14 +120,14 @@ def test_app_tearing_down_with_unhandled_exception(app, client):
 
     @app.route("/")
     def index():
-        raise Exception("dummy")
+        raise ValueError("dummy")
 
-    with pytest.raises(Exception, match="dummy"):
+    with pytest.raises(ValueError, match="dummy"):
         with app.app_context():
             client.get("/")
 
     assert len(cleanup_stuff) == 1
-    assert isinstance(cleanup_stuff[0], Exception)
+    assert isinstance(cleanup_stuff[0], ValueError)
     assert str(cleanup_stuff[0]) == "dummy"
 
 
@@ -175,11 +177,11 @@ def test_context_refcounts(app, client):
 
     @app.route("/")
     def index():
-        with flask._app_ctx_stack.top:
-            with flask._request_ctx_stack.top:
+        with app_ctx:
+            with request_ctx:
                 pass
-        env = flask._request_ctx_stack.top.request.environ
-        assert env["werkzeug.request"] is not None
+
+        assert flask.request.environ["werkzeug.request"] is not None
         return ""
 
     res = client.get("/")
diff --git a/tests/test_apps/blueprintapp/__init__.py b/tests/test_apps/blueprintapp/__init__.py
index 4b057985..ad594cf1 100644
--- a/tests/test_apps/blueprintapp/__init__.py
+++ b/tests/test_apps/blueprintapp/__init__.py
@@ -2,8 +2,8 @@ from flask import Flask
 
 app = Flask(__name__)
 app.config["DEBUG"] = True
-from blueprintapp.apps.admin import admin
-from blueprintapp.apps.frontend import frontend
+from blueprintapp.apps.admin import admin  # noqa: E402
+from blueprintapp.apps.frontend import frontend  # noqa: E402
 
 app.register_blueprint(admin)
 app.register_blueprint(frontend)
diff --git a/tests/test_async.py b/tests/test_async.py
index c8bb9bf0..38be27c9 100644
--- a/tests/test_async.py
+++ b/tests/test_async.py
@@ -107,10 +107,12 @@ def test_async_before_after_request():
     def index():
         return ""
 
-    @app.before_first_request
-    async def before_first():
-        nonlocal app_first_called
-        app_first_called = True
+    with pytest.deprecated_call():
+
+        @app.before_first_request
+        async def before_first():
+            nonlocal app_first_called
+            app_first_called = True
 
     @app.before_request
     async def before():
diff --git a/tests/test_basic.py b/tests/test_basic.py
index 3dc3a0e9..9aca6679 100644
--- a/tests/test_basic.py
+++ b/tests/test_basic.py
@@ -5,6 +5,7 @@ import uuid
 import warnings
 import weakref
 from datetime import datetime
+from datetime import timezone
 from platform import python_implementation
 from threading import Thread
 
@@ -329,6 +330,11 @@ def test_session_using_session_settings(app, client):
         flask.session["testing"] = 42
         return "Hello World"
 
+    @app.route("/clear")
+    def clear():
+        flask.session.pop("testing", None)
+        return "Goodbye World"
+
     rv = client.get("/", "http://www.example.com:8080/test/")
     cookie = rv.headers["set-cookie"].lower()
     assert "domain=.example.com" in cookie
@@ -337,11 +343,6 @@ def test_session_using_session_settings(app, client):
     assert "httponly" not in cookie
     assert "samesite" in cookie
 
-    @app.route("/clear")
-    def clear():
-        flask.session.pop("testing", None)
-        return "Goodbye World"
-
     rv = client.get("/clear", "http://www.example.com:8080/test/")
     cookie = rv.headers["set-cookie"].lower()
     assert "session=;" in cookie
@@ -436,7 +437,7 @@ def test_session_expiration(app, client):
     assert "set-cookie" in rv.headers
     match = re.search(r"(?i)\bexpires=([^;]+)", rv.headers["set-cookie"])
     expires = parse_date(match.group())
-    expected = datetime.utcnow() + app.permanent_session_lifetime
+    expected = datetime.now(timezone.utc) + app.permanent_session_lifetime
     assert expires.year == expected.year
     assert expires.month == expected.month
     assert expires.day == expected.day
@@ -466,7 +467,7 @@ def test_session_stored_last(app, client):
 
 
 def test_session_special_types(app, client):
-    now = datetime.utcnow().replace(microsecond=0)
+    now = datetime.now(timezone.utc).replace(microsecond=0)
     the_uuid = uuid.uuid4()
 
     @app.route("/")
@@ -899,13 +900,6 @@ def test_error_handling(app, client):
     assert b"forbidden" == rv.data
 
 
-def test_error_handler_unknown_code(app):
-    with pytest.raises(KeyError) as exc_info:
-        app.register_error_handler(999, lambda e: ("999", 999))
-
-    assert "Use a subclass" in exc_info.value.args[0]
-
-
 def test_error_handling_processing(app, client):
     app.testing = False
 
@@ -934,13 +928,8 @@ def test_baseexception_error_handling(app, client):
     def broken_func():
         raise KeyboardInterrupt()
 
-    with client:
-        with pytest.raises(KeyboardInterrupt):
-            client.get("/")
-
-        ctx = flask._request_ctx_stack.top
-        assert ctx.preserved
-        assert type(ctx._preserved_exc) is KeyboardInterrupt
+    with pytest.raises(KeyboardInterrupt):
+        client.get("/")
 
 
 def test_before_request_and_routing_errors(app, client):
@@ -1038,7 +1027,14 @@ def test_errorhandler_precedence(app, client):
     assert rv.data == b"E2"
 
 
-def test_trapping_of_bad_request_key_errors(app, client):
+@pytest.mark.parametrize(
+    ("debug", "trap", "expect_key", "expect_abort"),
+    [(False, None, True, True), (True, None, False, True), (False, True, False, False)],
+)
+def test_trap_bad_request_key_error(app, client, debug, trap, expect_key, expect_abort):
+    app.config["DEBUG"] = debug
+    app.config["TRAP_BAD_REQUEST_ERRORS"] = trap
+
     @app.route("/key")
     def fail():
         flask.request.form["missing_key"]
@@ -1047,26 +1043,23 @@ def test_trapping_of_bad_request_key_errors(app, client):
     def allow_abort():
         flask.abort(400)
 
-    rv = client.get("/key")
-    assert rv.status_code == 400
-    assert b"missing_key" not in rv.data
-    rv = client.get("/abort")
-    assert rv.status_code == 400
+    if expect_key:
+        rv = client.get("/key")
+        assert rv.status_code == 400
+        assert b"missing_key" not in rv.data
+    else:
+        with pytest.raises(KeyError) as exc_info:
+            client.get("/key")
 
-    app.debug = True
-    with pytest.raises(KeyError) as e:
-        client.get("/key")
-    assert e.errisinstance(BadRequest)
-    assert "missing_key" in e.value.get_description()
-    rv = client.get("/abort")
-    assert rv.status_code == 400
+        assert exc_info.errisinstance(BadRequest)
+        assert "missing_key" in exc_info.value.get_description()
 
-    app.debug = False
-    app.config["TRAP_BAD_REQUEST_ERRORS"] = True
-    with pytest.raises(KeyError):
-        client.get("/key")
-    with pytest.raises(BadRequest):
-        client.get("/abort")
+    if expect_abort:
+        rv = client.get("/abort")
+        assert rv.status_code == 400
+    else:
+        with pytest.raises(BadRequest):
+            client.get("/abort")
 
 
 def test_trapping_of_all_http_exceptions(app, client):
@@ -1117,14 +1110,10 @@ def test_enctype_debug_helper(app, client):
     def index():
         return flask.request.files["foo"].filename
 
-    # with statement is important because we leave an exception on the
-    # stack otherwise and we want to ensure that this is not the case
-    # to not negatively affect other tests.
-    with client:
-        with pytest.raises(DebugFilesKeyError) as e:
-            client.post("/fail", data={"foo": "index.txt"})
-        assert "no file contents were transmitted" in str(e.value)
-        assert "This was submitted: 'index.txt'" in str(e.value)
+    with pytest.raises(DebugFilesKeyError) as e:
+        client.post("/fail", data={"foo": "index.txt"})
+    assert "no file contents were transmitted" in str(e.value)
+    assert "This was submitted: 'index.txt'" in str(e.value)
 
 
 def test_response_types(app, client):
@@ -1173,6 +1162,10 @@ def test_response_types(app, client):
     def from_dict():
         return {"foo": "bar"}, 201
 
+    @app.route("/list")
+    def from_list():
+        return ["foo", "bar"], 201
+
     assert client.get("/text").data == "Hllo Wrld".encode()
     assert client.get("/bytes").data == "Hllo Wrld".encode()
 
@@ -1212,6 +1205,10 @@ def test_response_types(app, client):
     assert rv.json == {"foo": "bar"}
     assert rv.status_code == 201
 
+    rv = client.get("/list")
+    assert rv.json == ["foo", "bar"]
+    assert rv.status_code == 201
+
 
 def test_response_type_errors():
     app = flask.Flask(__name__)
@@ -1278,6 +1275,11 @@ def test_make_response(app, req_ctx):
     assert rv.data == b"W00t"
     assert rv.mimetype == "text/html"
 
+    rv = flask.make_response(c for c in "Hello")
+    assert rv.status_code == 200
+    assert rv.data == b"Hello"
+    assert rv.mimetype == "text/html"
+
 
 def test_make_response_with_response_instance(app, req_ctx):
     rv = flask.make_response(flask.jsonify({"msg": "W00t"}), 400)
@@ -1300,28 +1302,17 @@ def test_make_response_with_response_instance(app, req_ctx):
     assert rv.headers["X-Foo"] == "bar"
 
 
-def test_jsonify_no_prettyprint(app, req_ctx):
-    app.config.update({"JSONIFY_PRETTYPRINT_REGULAR": False})
-    compressed_msg = b'{"msg":{"submsg":"W00t"},"msg2":"foobar"}\n'
-    uncompressed_msg = {"msg": {"submsg": "W00t"}, "msg2": "foobar"}
-
-    rv = flask.make_response(flask.jsonify(uncompressed_msg), 200)
-    assert rv.data == compressed_msg
-
-
-def test_jsonify_prettyprint(app, req_ctx):
-    app.config.update({"JSONIFY_PRETTYPRINT_REGULAR": True})
-    compressed_msg = {"msg": {"submsg": "W00t"}, "msg2": "foobar"}
-    pretty_response = (
-        b'{\n  "msg": {\n    "submsg": "W00t"\n  }, \n  "msg2": "foobar"\n}\n'
-    )
-
-    rv = flask.make_response(flask.jsonify(compressed_msg), 200)
-    assert rv.data == pretty_response
+@pytest.mark.parametrize("compact", [True, False])
+def test_jsonify_no_prettyprint(app, compact):
+    app.json.compact = compact
+    rv = app.json.response({"msg": {"submsg": "W00t"}, "msg2": "foobar"})
+    data = rv.data.strip()
+    assert (b" " not in data) is compact
+    assert (b"\n" not in data) is compact
 
 
 def test_jsonify_mimetype(app, req_ctx):
-    app.config.update({"JSONIFY_MIMETYPE": "application/vnd.api+json"})
+    app.json.mimetype = "application/vnd.api+json"
     msg = {"msg": {"submsg": "W00t"}}
     rv = flask.make_response(flask.jsonify(msg), 200)
     assert rv.mimetype == "application/vnd.api+json"
@@ -1331,15 +1322,15 @@ def test_json_dump_dataclass(app, req_ctx):
     from dataclasses import make_dataclass
 
     Data = make_dataclass("Data", [("name", str)])
-    value = flask.json.dumps(Data("Flask"), app=app)
-    value = flask.json.loads(value, app=app)
+    value = app.json.dumps(Data("Flask"))
+    value = app.json.loads(value)
     assert value == {"name": "Flask"}
 
 
 def test_jsonify_args_and_kwargs_check(app, req_ctx):
     with pytest.raises(TypeError) as e:
         flask.jsonify("fake args", kwargs="fake")
-    assert "behavior undefined" in str(e.value)
+    assert "args or kwargs" in str(e.value)
 
 
 def test_url_generation(app, req_ctx):
@@ -1481,11 +1472,11 @@ def test_static_route_with_host_matching():
         rv = flask.url_for("static", filename="index.html", _external=True)
         assert rv == "http://example.com/static/index.html"
     # Providing static_host without host_matching=True should error.
-    with pytest.raises(Exception):
+    with pytest.raises(AssertionError):
         flask.Flask(__name__, static_host="example.com")
     # Providing host_matching=True with static_folder
     # but without static_host should error.
-    with pytest.raises(Exception):
+    with pytest.raises(AssertionError):
         flask.Flask(__name__, host_matching=True)
     # Providing host_matching=True without static_host
     # but with static_folder=None should not error.
@@ -1542,29 +1533,21 @@ def test_server_name_subdomain():
     assert rv.data == b"subdomain"
 
 
-@pytest.mark.filterwarnings("ignore::pytest.PytestUnraisableExceptionWarning")
-@pytest.mark.filterwarnings("ignore::pytest.PytestUnhandledThreadExceptionWarning")
-def test_exception_propagation(app, client):
-    def apprunner(config_key):
-        @app.route("/")
-        def index():
-            1 // 0
+@pytest.mark.parametrize("key", ["TESTING", "PROPAGATE_EXCEPTIONS", "DEBUG", None])
+def test_exception_propagation(app, client, key):
+    app.testing = False
 
-        if config_key is not None:
-            app.config[config_key] = True
-            with pytest.raises(Exception):
-                client.get("/")
-        else:
-            assert client.get("/").status_code == 500
+    @app.route("/")
+    def index():
+        1 // 0
+
+    if key is not None:
+        app.config[key] = True
 
-    # we have to run this test in an isolated thread because if the
-    # debug flag is set to true and an exception happens the context is
-    # not torn down.  This causes other tests that run after this fail
-    # when they expect no exception on the stack.
-    for config_key in "TESTING", "PROPAGATE_EXCEPTIONS", "DEBUG", None:
-        t = Thread(target=apprunner, args=(config_key,))
-        t.start()
-        t.join()
+        with pytest.raises(ZeroDivisionError):
+            client.get("/")
+    else:
+        assert client.get("/").status_code == 500
 
 
 @pytest.mark.parametrize("debug", [True, False])
@@ -1668,7 +1651,7 @@ def test_nonascii_pathinfo(app, client):
     assert rv.data == b"Hello World!"
 
 
-def test_debug_mode_complains_after_first_request(app, client):
+def test_no_setup_after_first_request(app, client):
     app.debug = True
 
     @app.route("/")
@@ -1678,27 +1661,20 @@ def test_debug_mode_complains_after_first_request(app, client):
     assert not app.got_first_request
     assert client.get("/").data == b"Awesome"
 
-    with pytest.raises(AssertionError) as e:
+    with pytest.raises(AssertionError) as exc_info:
         app.add_url_rule("/foo", endpoint="late")
 
-    assert "A setup function was called" in str(e.value)
-
-    app.debug = False
-
-    @app.route("/foo")
-    def working():
-        return "Meh"
-
-    assert client.get("/foo").data == b"Meh"
-    assert app.got_first_request
+    assert "setup method 'add_url_rule'" in str(exc_info.value)
 
 
 def test_before_first_request_functions(app, client):
     got = []
 
-    @app.before_first_request
-    def foo():
-        got.append(42)
+    with pytest.deprecated_call():
+
+        @app.before_first_request
+        def foo():
+            got.append(42)
 
     client.get("/")
     assert got == [42]
@@ -1710,10 +1686,12 @@ def test_before_first_request_functions(app, client):
 def test_before_first_request_functions_concurrent(app, client):
     got = []
 
-    @app.before_first_request
-    def foo():
-        time.sleep(0.2)
-        got.append(42)
+    with pytest.deprecated_call():
+
+        @app.before_first_request
+        def foo():
+            time.sleep(0.2)
+            got.append(42)
 
     def get_and_assert():
         client.get("/")
@@ -1727,28 +1705,23 @@ def test_before_first_request_functions_concurrent(app, client):
 
 
 def test_routing_redirect_debugging(monkeypatch, app, client):
-    @app.route("/foo/", methods=["GET", "POST"])
-    def foo():
-        return "success"
-
-    app.debug = False
-    rv = client.post("/foo", data={}, follow_redirects=True)
-    assert rv.data == b"success"
+    app.config["DEBUG"] = True
 
-    app.debug = True
+    @app.route("/user/", methods=["GET", "POST"])
+    def user():
+        return flask.request.form["status"]
 
-    with client:
-        rv = client.post("/foo", data={}, follow_redirects=True)
-        assert rv.data == b"success"
-        rv = client.get("/foo", data={}, follow_redirects=True)
-        assert rv.data == b"success"
+    # default redirect code preserves form data
+    rv = client.post("/user", data={"status": "success"}, follow_redirects=True)
+    assert rv.data == b"success"
 
+    # 301 and 302 raise error
     monkeypatch.setattr(RequestRedirect, "code", 301)
 
-    with client, pytest.raises(AssertionError) as e:
-        client.post("/foo", data={})
+    with client, pytest.raises(AssertionError) as exc_info:
+        client.post("/user", data={"status": "error"}, follow_redirects=True)
 
-    assert "canonical URL 'http://localhost/foo/'" in str(e.value)
+    assert "canonical URL 'http://localhost/user/'" in str(exc_info.value)
 
 
 def test_route_decorator_custom_endpoint(app, client):
@@ -1776,57 +1749,6 @@ def test_route_decorator_custom_endpoint(app, client):
     assert client.get("/bar/123").data == b"123"
 
 
-def test_preserve_only_once(app, client):
-    app.debug = True
-
-    @app.route("/fail")
-    def fail_func():
-        1 // 0
-
-    for _x in range(3):
-        with pytest.raises(ZeroDivisionError):
-            client.get("/fail")
-
-    assert flask._request_ctx_stack.top is not None
-    assert flask._app_ctx_stack.top is not None
-    # implicit appctx disappears too
-    flask._request_ctx_stack.top.pop()
-    assert flask._request_ctx_stack.top is None
-    assert flask._app_ctx_stack.top is None
-
-
-def test_preserve_remembers_exception(app, client):
-    app.debug = True
-    errors = []
-
-    @app.route("/fail")
-    def fail_func():
-        1 // 0
-
-    @app.route("/success")
-    def success_func():
-        return "Okay"
-
-    @app.teardown_request
-    def teardown_handler(exc):
-        errors.append(exc)
-
-    # After this failure we did not yet call the teardown handler
-    with pytest.raises(ZeroDivisionError):
-        client.get("/fail")
-    assert errors == []
-
-    # But this request triggers it, and it's an error
-    client.get("/success")
-    assert len(errors) == 2
-    assert isinstance(errors[0], ZeroDivisionError)
-
-    # At this point another request does nothing.
-    client.get("/success")
-    assert len(errors) == 3
-    assert errors[1] is None
-
-
 def test_get_method_on_g(app_ctx):
     assert flask.g.get("x") is None
     assert flask.g.get("x", 11) == 11
diff --git a/tests/test_blueprints.py b/tests/test_blueprints.py
index fbe9eeee..1bf130f5 100644
--- a/tests/test_blueprints.py
+++ b/tests/test_blueprints.py
@@ -722,9 +722,11 @@ def test_app_request_processing(app, client):
     bp = flask.Blueprint("bp", __name__)
     evts = []
 
-    @bp.before_app_first_request
-    def before_first_request():
-        evts.append("first")
+    with pytest.deprecated_call():
+
+        @bp.before_app_first_request
+        def before_first_request():
+            evts.append("first")
 
     @bp.before_app_request
     def before_app():
diff --git a/tests/test_cli.py b/tests/test_cli.py
index 6e8b57f0..0d9625b1 100644
--- a/tests/test_cli.py
+++ b/tests/test_cli.py
@@ -1,7 +1,6 @@
 # This file was part of Flask-CLI and was modified under the terms of
 # its Revised BSD License. Copyright  2015 CERN.
 import os
-import platform
 import ssl
 import sys
 import types
@@ -17,8 +16,6 @@ from flask import Blueprint
 from flask import current_app
 from flask import Flask
 from flask.cli import AppGroup
-from flask.cli import DispatchingApp
-from flask.cli import dotenv
 from flask.cli import find_best_app
 from flask.cli import FlaskGroup
 from flask.cli import get_version
@@ -291,24 +288,22 @@ def test_scriptinfo(test_apps, monkeypatch):
     assert app.name == "testapp"
 
 
-@pytest.mark.xfail(platform.python_implementation() == "PyPy", reason="flaky on pypy")
-def test_lazy_load_error(monkeypatch):
-    """When using lazy loading, the correct exception should be
-    re-raised.
-    """
-
-    class BadExc(Exception):
-        pass
+def test_app_cli_has_app_context(app, runner):
+    def _param_cb(ctx, param, value):
+        # current_app should be available in parameter callbacks
+        return bool(current_app)
 
-    def bad_load():
-        raise BadExc
+    @app.cli.command()
+    @click.argument("value", callback=_param_cb)
+    def check(value):
+        app = click.get_current_context().obj.load_app()
+        # the loaded app should be the same as current_app
+        same_app = current_app._get_current_object() is app
+        return same_app, value
 
-    lazy = DispatchingApp(bad_load, use_eager_loading=False)
-
-    # reduce flakiness by waiting for the internal loading lock
-    with lazy._lock:
-        with pytest.raises(BadExc):
-            lazy._flush_bg_loading_exception()
+    cli = FlaskGroup(create_app=lambda: app)
+    result = runner.invoke(cli, ["check", "x"], standalone_mode=False)
+    assert result.return_value == (True, True)
 
 
 def test_with_appcontext(runner):
@@ -324,12 +319,12 @@ def test_with_appcontext(runner):
     assert result.output == "testapp\n"
 
 
-def test_appgroup(runner):
+def test_appgroup_app_context(runner):
     @click.group(cls=AppGroup)
     def cli():
         pass
 
-    @cli.command(with_appcontext=True)
+    @cli.command()
     def test():
         click.echo(current_app.name)
 
@@ -337,7 +332,7 @@ def test_appgroup(runner):
     def subgroup():
         pass
 
-    @subgroup.command(with_appcontext=True)
+    @subgroup.command()
     def test2():
         click.echo(current_app.name)
 
@@ -352,7 +347,7 @@ def test_appgroup(runner):
     assert result.output == "testappgroup\n"
 
 
-def test_flaskgroup(runner):
+def test_flaskgroup_app_context(runner):
     def create_app():
         return Flask("flaskgroup")
 
@@ -389,6 +384,19 @@ def test_flaskgroup_debug(runner, set_debug_flag):
     assert result.output == f"{not set_debug_flag}\n"
 
 
+def test_flaskgroup_nested(app, runner):
+    cli = click.Group("cli")
+    flask_group = FlaskGroup(name="flask", create_app=lambda: app)
+    cli.add_command(flask_group)
+
+    @flask_group.command()
+    def show():
+        click.echo(current_app.name)
+
+    result = runner.invoke(cli, ["flask", "show"])
+    assert result.output == "flask_test\n"
+
+
 def test_no_command_echo_loading_error():
     from flask.cli import cli
 
@@ -423,22 +431,23 @@ def test_help_echo_exception():
 
 class TestRoutes:
     @pytest.fixture
-    def invoke(self, runner):
-        def create_app():
-            app = Flask(__name__)
-            app.testing = True
+    def app(self):
+        app = Flask(__name__)
+        app.testing = True
 
-            @app.route("/get_post/<int:x>/<int:y>", methods=["GET", "POST"])
-            def yyy_get_post(x, y):
-                pass
+        @app.route("/get_post/<int:x>/<int:y>", methods=["GET", "POST"])
+        def yyy_get_post(x, y):
+            pass
 
-            @app.route("/zzz_post", methods=["POST"])
-            def aaa_post():
-                pass
+        @app.route("/zzz_post", methods=["POST"])
+        def aaa_post():
+            pass
 
-            return app
+        return app
 
-        cli = FlaskGroup(create_app=create_app)
+    @pytest.fixture
+    def invoke(self, app, runner):
+        cli = FlaskGroup(create_app=lambda: app)
         return partial(runner.invoke, cli)
 
     @pytest.fixture
@@ -463,7 +472,7 @@ class TestRoutes:
         assert result.exit_code == 0
         self.expect_order(["aaa_post", "static", "yyy_get_post"], result.output)
 
-    def test_sort(self, invoke):
+    def test_sort(self, app, invoke):
         default_output = invoke(["routes"]).output
         endpoint_output = invoke(["routes", "-s", "endpoint"]).output
         assert default_output == endpoint_output
@@ -475,10 +484,8 @@ class TestRoutes:
             ["yyy_get_post", "static", "aaa_post"],
             invoke(["routes", "-s", "rule"]).output,
         )
-        self.expect_order(
-            ["aaa_post", "yyy_get_post", "static"],
-            invoke(["routes", "-s", "match"]).output,
-        )
+        match_order = [r.endpoint for r in app.url_map.iter_rules()]
+        self.expect_order(match_order, invoke(["routes", "-s", "match"]).output)
 
     def test_all_methods(self, invoke):
         output = invoke(["routes"]).output
@@ -492,7 +499,18 @@ class TestRoutes:
         assert "No routes were registered." in result.output
 
 
-need_dotenv = pytest.mark.skipif(dotenv is None, reason="dotenv is not installed")
+def dotenv_not_available():
+    try:
+        import dotenv  # noqa: F401
+    except ImportError:
+        return True
+
+    return False
+
+
+need_dotenv = pytest.mark.skipif(
+    dotenv_not_available(), reason="dotenv is not installed"
+)
 
 
 @need_dotenv
@@ -530,7 +548,7 @@ def test_dotenv_path(monkeypatch):
 
 
 def test_dotenv_optional(monkeypatch):
-    monkeypatch.setattr("flask.cli.dotenv", None)
+    monkeypatch.setitem(sys.modules, "dotenv", None)
     monkeypatch.chdir(test_path)
     load_dotenv()
     assert "FOO" not in os.environ
@@ -602,7 +620,8 @@ def test_run_cert_import(monkeypatch):
 
 
 def test_run_cert_no_ssl(monkeypatch):
-    monkeypatch.setattr("flask.cli.ssl", None)
+    monkeypatch.setitem(sys.modules, "ssl", None)
+
     with pytest.raises(click.BadParameter):
         run_command.make_context("run", ["--cert", "not_here"])
 
diff --git a/tests/test_config.py b/tests/test_config.py
index 944b93d7..76c5d272 100644
--- a/tests/test_config.py
+++ b/tests/test_config.py
@@ -1,7 +1,6 @@
 import json
 import os
 import textwrap
-from datetime import timedelta
 
 import pytest
 
@@ -113,6 +112,10 @@ def test_config_from_mapping():
     app.config.from_mapping(SECRET_KEY="config", TEST_KEY="foo")
     common_object_test(app)
 
+    app = flask.Flask(__name__)
+    app.config.from_mapping(SECRET_KEY="config", TEST_KEY="foo", skip_key="skip")
+    common_object_test(app)
+
     app = flask.Flask(__name__)
     with pytest.raises(TypeError):
         app.config.from_mapping({}, {})
@@ -203,14 +206,6 @@ def test_session_lifetime():
     assert app.permanent_session_lifetime.seconds == 42
 
 
-def test_send_file_max_age():
-    app = flask.Flask(__name__)
-    app.config["SEND_FILE_MAX_AGE_DEFAULT"] = 3600
-    assert app.send_file_max_age_default.seconds == 3600
-    app.config["SEND_FILE_MAX_AGE_DEFAULT"] = timedelta(hours=2)
-    assert app.send_file_max_age_default.seconds == 7200
-
-
 def test_get_namespace():
     app = flask.Flask(__name__)
     app.config["FOO_OPTION_1"] = "foo option 1"
diff --git a/tests/test_helpers.py b/tests/test_helpers.py
index 58bf3c0b..0e6a8856 100644
--- a/tests/test_helpers.py
+++ b/tests/test_helpers.py
@@ -2,10 +2,10 @@ import io
 import os
 
 import pytest
+import werkzeug.exceptions
 
 import flask
 from flask.helpers import get_debug_flag
-from flask.helpers import get_env
 
 
 class FakePath:
@@ -118,11 +118,15 @@ class TestUrlFor:
         )
 
     def test_url_for_with_scheme_not_external(self, app, req_ctx):
-        @app.route("/")
-        def index():
-            return "42"
+        app.add_url_rule("/", endpoint="index")
 
-        pytest.raises(ValueError, flask.url_for, "index", _scheme="https")
+        # Implicit external with scheme.
+        url = flask.url_for("index", _scheme="https")
+        assert url == "https://localhost/"
+
+        # Error when external=False with scheme
+        with pytest.raises(ValueError):
+            flask.url_for("index", _scheme="https", _external=False)
 
     def test_url_for_with_alternating_schemes(self, app, req_ctx):
         @app.route("/")
@@ -158,6 +162,51 @@ class TestUrlFor:
         assert flask.url_for("myview", _method="POST") == "/myview/create"
 
 
+def test_redirect_no_app():
+    response = flask.redirect("https://localhost", 307)
+    assert response.location == "https://localhost"
+    assert response.status_code == 307
+
+
+def test_redirect_with_app(app):
+    def redirect(location, code=302):
+        raise ValueError
+
+    app.redirect = redirect
+
+    with app.app_context(), pytest.raises(ValueError):
+        flask.redirect("other")
+
+
+def test_abort_no_app():
+    with pytest.raises(werkzeug.exceptions.Unauthorized):
+        flask.abort(401)
+
+    with pytest.raises(LookupError):
+        flask.abort(900)
+
+
+def test_app_aborter_class():
+    class MyAborter(werkzeug.exceptions.Aborter):
+        pass
+
+    class MyFlask(flask.Flask):
+        aborter_class = MyAborter
+
+    app = MyFlask(__name__)
+    assert isinstance(app.aborter, MyAborter)
+
+
+def test_abort_with_app(app):
+    class My900Error(werkzeug.exceptions.HTTPException):
+        code = 900
+
+    app.aborter.mapping[900] = My900Error
+
+    with app.app_context(), pytest.raises(My900Error):
+        flask.abort(900)
+
+
 class TestNoImports:
     """Test Flasks are created without import.
 
@@ -272,20 +321,6 @@ class TestHelpers:
             assert get_debug_flag() == expected_flag
         assert get_debug_flag() == expected_default_flag
 
-    @pytest.mark.parametrize(
-        "env, ref_env, debug",
-        [
-            ("", "production", False),
-            ("production", "production", False),
-            ("development", "development", True),
-            ("other", "other", False),
-        ],
-    )
-    def test_get_env(self, monkeypatch, env, ref_env, debug):
-        monkeypatch.setenv("FLASK_ENV", env)
-        assert get_debug_flag() == debug
-        assert get_env() == ref_env
-
     def test_make_response(self):
         app = flask.Flask(__name__)
         with app.test_request_context():
diff --git a/tests/test_instance_config.py b/tests/test_instance_config.py
index ee573664..c8cf0bf7 100644
--- a/tests/test_instance_config.py
+++ b/tests/test_instance_config.py
@@ -1,4 +1,3 @@
-import os
 import sys
 
 import pytest
@@ -15,19 +14,6 @@ def test_explicit_instance_paths(modules_tmpdir):
     assert app.instance_path == str(modules_tmpdir)
 
 
-@pytest.mark.xfail(reason="weird interaction with tox")
-def test_main_module_paths(modules_tmpdir, purge_module):
-    app = modules_tmpdir.join("main_app.py")
-    app.write('import flask\n\napp = flask.Flask("__main__")')
-    purge_module("main_app")
-
-    from main_app import app
-
-    here = os.path.abspath(os.getcwd())
-    assert app.instance_path == os.path.join(here, "instance")
-
-
-@pytest.mark.xfail(reason="weird interaction with tox")
 def test_uninstalled_module_paths(modules_tmpdir, purge_module):
     app = modules_tmpdir.join("config_module_app.py").write(
         "import os\n"
@@ -42,7 +28,6 @@ def test_uninstalled_module_paths(modules_tmpdir, purge_module):
     assert app.instance_path == str(modules_tmpdir.join("instance"))
 
 
-@pytest.mark.xfail(reason="weird interaction with tox")
 def test_uninstalled_package_paths(modules_tmpdir, purge_module):
     app = modules_tmpdir.mkdir("config_package_app")
     init = app.join("__init__.py")
@@ -59,6 +44,25 @@ def test_uninstalled_package_paths(modules_tmpdir, purge_module):
     assert app.instance_path == str(modules_tmpdir.join("instance"))
 
 
+def test_uninstalled_namespace_paths(tmpdir, monkeypatch, purge_module):
+    def create_namespace(package):
+        project = tmpdir.join(f"project-{package}")
+        monkeypatch.syspath_prepend(str(project))
+        project.join("namespace").join(package).join("__init__.py").write(
+            "import flask\napp = flask.Flask(__name__)\n", ensure=True
+        )
+        return project
+
+    _ = create_namespace("package1")
+    project2 = create_namespace("package2")
+    purge_module("namespace.package2")
+    purge_module("namespace")
+
+    from namespace.package2 import app
+
+    assert app.instance_path == str(project2.join("instance"))
+
+
 def test_installed_module_paths(
     modules_tmpdir, modules_tmpdir_prefix, purge_module, site_packages, limit_loader
 ):
diff --git a/tests/test_json.py b/tests/test_json.py
index 9210275a..ba9f38dc 100644
--- a/tests/test_json.py
+++ b/tests/test_json.py
@@ -8,6 +8,7 @@ from werkzeug.http import http_date
 
 import flask
 from flask import json
+from flask.json.provider import DefaultJSONProvider
 
 
 @pytest.mark.parametrize("debug", (True, False))
@@ -48,9 +49,8 @@ def test_json_custom_mimetypes(app, client):
     "test_value,expected", [(True, '"\\u2603"'), (False, '"\u2603"')]
 )
 def test_json_as_unicode(test_value, expected, app, app_ctx):
-
-    app.config["JSON_AS_ASCII"] = test_value
-    rv = flask.json.dumps("\N{SNOWMAN}")
+    app.json.ensure_ascii = test_value
+    rv = app.json.dumps("\N{SNOWMAN}")
     assert rv == expected
 
 
@@ -170,7 +170,7 @@ def test_jsonify_aware_datetimes(tz):
     dt = datetime.datetime(2017, 1, 1, 12, 34, 56, tzinfo=tzinfo)
     gmt = FixedOffset(hours=0, name="GMT")
     expected = dt.astimezone(gmt).strftime('"%a, %d %b %Y %H:%M:%S %Z"')
-    assert flask.json.JSONEncoder().encode(dt) == expected
+    assert flask.json.dumps(dt) == expected
 
 
 def test_jsonify_uuid_types(app, client):
@@ -225,74 +225,32 @@ def test_json_customization(app, client):
         def __init__(self, val):
             self.val = val
 
-    class MyEncoder(flask.json.JSONEncoder):
-        def default(self, o):
-            if isinstance(o, X):
-                return f"<{o.val}>"
-            return flask.json.JSONEncoder.default(self, o)
+    def default(o):
+        if isinstance(o, X):
+            return f"<{o.val}>"
 
-    class MyDecoder(flask.json.JSONDecoder):
-        def __init__(self, *args, **kwargs):
-            kwargs.setdefault("object_hook", self.object_hook)
-            flask.json.JSONDecoder.__init__(self, *args, **kwargs)
+        return DefaultJSONProvider.default(o)
 
+    class CustomProvider(DefaultJSONProvider):
         def object_hook(self, obj):
             if len(obj) == 1 and "_foo" in obj:
                 return X(obj["_foo"])
-            return obj
-
-    app.json_encoder = MyEncoder
-    app.json_decoder = MyDecoder
-
-    @app.route("/", methods=["POST"])
-    def index():
-        return flask.json.dumps(flask.request.get_json()["x"])
-
-    rv = client.post(
-        "/",
-        data=flask.json.dumps({"x": {"_foo": 42}}),
-        content_type="application/json",
-    )
-    assert rv.data == b'"<42>"'
-
 
-def test_blueprint_json_customization(app, client):
-    class X:
-        __slots__ = ("val",)
-
-        def __init__(self, val):
-            self.val = val
-
-    class MyEncoder(flask.json.JSONEncoder):
-        def default(self, o):
-            if isinstance(o, X):
-                return f"<{o.val}>"
-
-            return flask.json.JSONEncoder.default(self, o)
+            return obj
 
-    class MyDecoder(flask.json.JSONDecoder):
-        def __init__(self, *args, **kwargs):
+        def loads(self, s, **kwargs):
             kwargs.setdefault("object_hook", self.object_hook)
-            flask.json.JSONDecoder.__init__(self, *args, **kwargs)
-
-        def object_hook(self, obj):
-            if len(obj) == 1 and "_foo" in obj:
-                return X(obj["_foo"])
-
-            return obj
+            return super().loads(s, **kwargs)
 
-    bp = flask.Blueprint("bp", __name__)
-    bp.json_encoder = MyEncoder
-    bp.json_decoder = MyDecoder
+    app.json = CustomProvider(app)
+    app.json.default = default
 
-    @bp.route("/bp", methods=["POST"])
+    @app.route("/", methods=["POST"])
     def index():
         return flask.json.dumps(flask.request.get_json()["x"])
 
-    app.register_blueprint(bp)
-
     rv = client.post(
-        "/bp",
+        "/",
         data=flask.json.dumps({"x": {"_foo": 42}}),
         content_type="application/json",
     )
@@ -330,8 +288,7 @@ def test_modified_url_encoding(app, client):
 
 def test_json_key_sorting(app, client):
     app.debug = True
-
-    assert app.config["JSON_SORT_KEYS"]
+    assert app.json.sort_keys
     d = dict.fromkeys(range(20), "foo")
 
     @app.route("/")
diff --git a/tests/test_reqctx.py b/tests/test_reqctx.py
index 1a478917..6c38b661 100644
--- a/tests/test_reqctx.py
+++ b/tests/test_reqctx.py
@@ -3,6 +3,7 @@ import warnings
 import pytest
 
 import flask
+from flask.globals import request_ctx
 from flask.sessions import SecureCookieSessionInterface
 from flask.sessions import SessionInterface
 
@@ -116,7 +117,7 @@ def test_context_binding(app):
         assert index() == "Hello World!"
     with app.test_request_context("/meh"):
         assert meh() == "http://localhost/meh"
-    assert flask._request_ctx_stack.top is None
+    assert not flask.request
 
 
 def test_context_test(app):
@@ -152,7 +153,7 @@ class TestGreenletContextCopying:
         @app.route("/")
         def index():
             flask.session["fizz"] = "buzz"
-            reqctx = flask._request_ctx_stack.top.copy()
+            reqctx = request_ctx.copy()
 
             def g():
                 assert not flask.request
@@ -226,7 +227,6 @@ def test_session_error_pops_context():
 
 
 def test_session_dynamic_cookie_name():
-
     # This session interface will use a cookie with a different name if the
     # requested url ends with the string "dynamic_cookie"
     class PathAwareSessionInterface(SecureCookieSessionInterface):
diff --git a/tests/test_session_interface.py b/tests/test_session_interface.py
index 39562f5a..613da37f 100644
--- a/tests/test_session_interface.py
+++ b/tests/test_session_interface.py
@@ -1,4 +1,5 @@
 import flask
+from flask.globals import request_ctx
 from flask.sessions import SessionInterface
 
 
@@ -13,7 +14,7 @@ def test_open_session_with_endpoint():
             pass
 
         def open_session(self, app, request):
-            flask._request_ctx_stack.top.match_request()
+            request_ctx.match_request()
             assert request.endpoint is not None
 
     app = flask.Flask(__name__)
diff --git a/tests/test_signals.py b/tests/test_signals.py
index 719eb3ef..8aa69836 100644
--- a/tests/test_signals.py
+++ b/tests/test_signals.py
@@ -123,8 +123,7 @@ def test_request_exception_signal():
         flask.got_request_exception.disconnect(record, app)
 
 
-def test_appcontext_signals():
-    app = flask.Flask(__name__)
+def test_appcontext_signals(app, client):
     recorded = []
 
     def record_push(sender, **kwargs):
@@ -140,10 +139,8 @@ def test_appcontext_signals():
     flask.appcontext_pushed.connect(record_push, app)
     flask.appcontext_popped.connect(record_pop, app)
     try:
-        with app.test_client() as c:
-            rv = c.get("/")
-            assert rv.data == b"Hello"
-            assert recorded == ["push"]
+        rv = client.get("/")
+        assert rv.data == b"Hello"
         assert recorded == ["push", "pop"]
     finally:
         flask.appcontext_pushed.disconnect(record_push, app)
@@ -174,12 +171,12 @@ def test_flash_signal(app):
         flask.message_flashed.disconnect(record, app)
 
 
-def test_appcontext_tearing_down_signal():
-    app = flask.Flask(__name__)
+def test_appcontext_tearing_down_signal(app, client):
+    app.testing = False
     recorded = []
 
-    def record_teardown(sender, **kwargs):
-        recorded.append(("tear_down", kwargs))
+    def record_teardown(sender, exc):
+        recorded.append(exc)
 
     @app.route("/")
     def index():
@@ -187,10 +184,9 @@ def test_appcontext_tearing_down_signal():
 
     flask.appcontext_tearing_down.connect(record_teardown, app)
     try:
-        with app.test_client() as c:
-            rv = c.get("/")
-            assert rv.status_code == 500
-            assert recorded == []
-        assert recorded == [("tear_down", {"exc": None})]
+        rv = client.get("/")
+        assert rv.status_code == 500
+        assert len(recorded) == 1
+        assert isinstance(recorded[0], ZeroDivisionError)
     finally:
         flask.appcontext_tearing_down.disconnect(record_teardown, app)
diff --git a/tests/test_templating.py b/tests/test_templating.py
index a53120ea..863417c0 100644
--- a/tests/test_templating.py
+++ b/tests/test_templating.py
@@ -29,6 +29,15 @@ def test_original_win(app, client):
     assert rv.data == b"42"
 
 
+def test_simple_stream(app, client):
+    @app.route("/")
+    def index():
+        return flask.stream_template_string("{{ config }}", config=42)
+
+    rv = client.get("/")
+    assert rv.data == b"42"
+
+
 def test_request_less_rendering(app, app_ctx):
     app.config["WORLD_NAME"] = "Special World"
 
@@ -388,11 +397,9 @@ def test_templates_auto_reload_debug_run(app, monkeypatch):
     monkeypatch.setattr(werkzeug.serving, "run_simple", run_simple_mock)
 
     app.run()
-    assert not app.templates_auto_reload
     assert not app.jinja_env.auto_reload
 
     app.run(debug=True)
-    assert app.templates_auto_reload
     assert app.jinja_env.auto_reload
 
 
diff --git a/tests/test_testing.py b/tests/test_testing.py
index a78502f4..40f6fe1b 100644
--- a/tests/test_testing.py
+++ b/tests/test_testing.py
@@ -5,6 +5,7 @@ import werkzeug
 import flask
 from flask import appcontext_popped
 from flask.cli import ScriptInfo
+from flask.globals import _cv_request
 from flask.json import jsonify
 from flask.testing import EnvironBuilder
 from flask.testing import FlaskCliRunner
@@ -111,7 +112,7 @@ def test_path_is_url(app):
 
 def test_environbuilder_json_dumps(app):
     """EnvironBuilder.json_dumps() takes settings from the app."""
-    app.config["JSON_AS_ASCII"] = False
+    app.json.ensure_ascii = False
     eb = EnvironBuilder(app, json="\u20ac")
     assert eb.input_stream.read().decode("utf8") == '"\u20ac"'
 
@@ -187,7 +188,6 @@ def test_session_transactions(app, client):
 
 def test_session_transactions_no_null_sessions():
     app = flask.Flask(__name__)
-    app.testing = True
 
     with app.test_client() as c:
         with pytest.raises(RuntimeError) as e:
@@ -254,29 +254,6 @@ def test_reuse_client(client):
         assert client.get("/").status_code == 404
 
 
-def test_test_client_calls_teardown_handlers(app, client):
-    called = []
-
-    @app.teardown_request
-    def remember(error):
-        called.append(error)
-
-    with client:
-        assert called == []
-        client.get("/")
-        assert called == []
-    assert called == [None]
-
-    del called[:]
-    with client:
-        assert called == []
-        client.get("/")
-        assert called == []
-        client.get("/")
-        assert called == [None]
-    assert called == [None, None]
-
-
 def test_full_url_request(app, client):
     @app.route("/action", methods=["POST"])
     def action():
@@ -412,13 +389,15 @@ def test_cli_custom_obj(app):
 def test_client_pop_all_preserved(app, req_ctx, client):
     @app.route("/")
     def index():
-        # stream_with_context pushes a third context, preserved by client
-        return flask.Response(flask.stream_with_context("hello"))
+        # stream_with_context pushes a third context, preserved by response
+        return flask.stream_with_context("hello")
 
-    # req_ctx fixture pushed an initial context, not marked preserved
+    # req_ctx fixture pushed an initial context
     with client:
         # request pushes a second request context, preserved by client
-        client.get("/")
+        rv = client.get("/")
 
+    # close the response, releasing the context held by stream_with_context
+    rv.close()
     # only req_ctx fixture should still be pushed
-    assert flask._request_ctx_stack.top is req_ctx
+    assert _cv_request.get(None) is req_ctx
diff --git a/tests/test_user_error_handler.py b/tests/test_user_error_handler.py
index d9f94a3f..79c5a73c 100644
--- a/tests/test_user_error_handler.py
+++ b/tests/test_user_error_handler.py
@@ -11,29 +11,35 @@ def test_error_handler_no_match(app, client):
     class CustomException(Exception):
         pass
 
-    class UnacceptableCustomException(BaseException):
-        pass
-
     @app.errorhandler(CustomException)
     def custom_exception_handler(e):
         assert isinstance(e, CustomException)
         return "custom"
 
-    with pytest.raises(
-        AssertionError, match="Custom exceptions must be subclasses of Exception."
-    ):
-        app.register_error_handler(UnacceptableCustomException, None)
+    with pytest.raises(TypeError) as exc_info:
+        app.register_error_handler(CustomException(), None)
+
+    assert "CustomException() is an instance, not a class." in str(exc_info.value)
+
+    with pytest.raises(ValueError) as exc_info:
+        app.register_error_handler(list, None)
+
+    assert "'list' is not a subclass of Exception." in str(exc_info.value)
 
     @app.errorhandler(500)
     def handle_500(e):
         assert isinstance(e, InternalServerError)
-        original = getattr(e, "original_exception", None)
 
-        if original is not None:
-            return f"wrapped {type(original).__name__}"
+        if e.original_exception is not None:
+            return f"wrapped {type(e.original_exception).__name__}"
 
         return "direct"
 
+    with pytest.raises(ValueError) as exc_info:
+        app.register_error_handler(999, None)
+
+    assert "Use a subclass of HTTPException" in str(exc_info.value)
+
     @app.route("/custom")
     def custom_test():
         raise CustomException()
diff --git a/tests/test_views.py b/tests/test_views.py
index 0e215252..8d870def 100644
--- a/tests/test_views.py
+++ b/tests/test_views.py
@@ -240,3 +240,21 @@ def test_remove_method_from_parent(app, client):
     assert client.get("/").data == b"GET"
     assert client.post("/").status_code == 405
     assert sorted(View.methods) == ["GET"]
+
+
+def test_init_once(app, client):
+    n = 0
+
+    class CountInit(flask.views.View):
+        init_every_request = False
+
+        def __init__(self):
+            nonlocal n
+            n += 1
+
+        def dispatch_request(self):
+            return str(n)
+
+    app.add_url_rule("/", view_func=CountInit.as_view("index"))
+    assert client.get("/").data == b"1"
+    assert client.get("/").data == b"1"
diff --git a/tests/typing/typing_app_decorators.py b/tests/typing/typing_app_decorators.py
new file mode 100644
index 00000000..6b2188aa
--- /dev/null
+++ b/tests/typing/typing_app_decorators.py
@@ -0,0 +1,38 @@
+from __future__ import annotations
+
+import typing as t
+
+from flask import Flask
+from flask import Response
+
+app = Flask(__name__)
+
+
+@app.after_request
+def after_sync(response: Response) -> Response:
+    return Response()
+
+
+@app.after_request
+async def after_async(response: Response) -> Response:
+    return Response()
+
+
+@app.before_request
+def before_sync() -> None:
+    ...
+
+
+@app.before_request
+async def before_async() -> None:
+    ...
+
+
+@app.teardown_appcontext
+def teardown_sync(exc: t.Optional[BaseException]) -> None:
+    ...
+
+
+@app.teardown_appcontext
+async def teardown_async(exc: t.Optional[BaseException]) -> None:
+    ...
diff --git a/tests/typing/typing_error_handler.py b/tests/typing/typing_error_handler.py
new file mode 100644
index 00000000..ec9c886f
--- /dev/null
+++ b/tests/typing/typing_error_handler.py
@@ -0,0 +1,33 @@
+from __future__ import annotations
+
+from http import HTTPStatus
+
+from werkzeug.exceptions import BadRequest
+from werkzeug.exceptions import NotFound
+
+from flask import Flask
+
+app = Flask(__name__)
+
+
+@app.errorhandler(400)
+@app.errorhandler(HTTPStatus.BAD_REQUEST)
+@app.errorhandler(BadRequest)
+def handle_400(e: BadRequest) -> str:
+    return ""
+
+
+@app.errorhandler(ValueError)
+def handle_custom(e: ValueError) -> str:
+    return ""
+
+
+@app.errorhandler(ValueError)
+def handle_accept_base(e: Exception) -> str:
+    return ""
+
+
+@app.errorhandler(BadRequest)
+@app.errorhandler(404)
+def handle_multiple(e: BadRequest | NotFound) -> str:
+    return ""
diff --git a/tests/typing/typing_route.py b/tests/typing/typing_route.py
new file mode 100644
index 00000000..566280c0
--- /dev/null
+++ b/tests/typing/typing_route.py
@@ -0,0 +1,114 @@
+from __future__ import annotations
+
+import typing as t
+from http import HTTPStatus
+
+import typing_extensions as te
+
+from flask import Flask
+from flask import jsonify
+from flask import stream_template
+from flask.templating import render_template
+from flask.views import View
+from flask.wrappers import Response
+
+app = Flask(__name__)
+
+
+@app.route("/str")
+def hello_str() -> str:
+    return "<p>Hello, World!</p>"
+
+
+@app.route("/bytes")
+def hello_bytes() -> bytes:
+    return b"<p>Hello, World!</p>"
+
+
+@app.route("/json")
+def hello_json() -> Response:
+    return jsonify("Hello, World!")
+
+
+@app.route("/json/dict")
+def hello_json_dict() -> t.Dict[str, t.Any]:
+    return {"response": "Hello, World!"}
+
+
+@app.route("/json/dict")
+def hello_json_list() -> t.List[t.Any]:
+    return [{"message": "Hello"}, {"message": "World"}]
+
+
+class StatusJSON(te.TypedDict):
+    status: str
+
+
+@app.route("/typed-dict")
+def typed_dict() -> StatusJSON:
+    return {"status": "ok"}
+
+
+@app.route("/generator")
+def hello_generator() -> t.Generator[str, None, None]:
+    def show() -> t.Generator[str, None, None]:
+        for x in range(100):
+            yield f"data:{x}\n\n"
+
+    return show()
+
+
+@app.route("/generator-expression")
+def hello_generator_expression() -> t.Iterator[bytes]:
+    return (f"data:{x}\n\n".encode() for x in range(100))
+
+
+@app.route("/iterator")
+def hello_iterator() -> t.Iterator[str]:
+    return iter([f"data:{x}\n\n" for x in range(100)])
+
+
+@app.route("/status")
+@app.route("/status/<int:code>")
+def tuple_status(code: int = 200) -> tuple[str, int]:
+    return "hello", code
+
+
+@app.route("/status-enum")
+def tuple_status_enum() -> tuple[str, int]:
+    return "hello", HTTPStatus.OK
+
+
+@app.route("/headers")
+def tuple_headers() -> tuple[str, dict[str, str]]:
+    return "Hello, World!", {"Content-Type": "text/plain"}
+
+
+@app.route("/template")
+@app.route("/template/<name>")
+def return_template(name: str | None = None) -> str:
+    return render_template("index.html", name=name)
+
+
+@app.route("/template")
+def return_template_stream() -> t.Iterator[str]:
+    return stream_template("index.html", name="Hello")
+
+
+@app.route("/async")
+async def async_route() -> str:
+    return "Hello"
+
+
+class RenderTemplateView(View):
+    def __init__(self: RenderTemplateView, template_name: str) -> None:
+        self.template_name = template_name
+
+    def dispatch_request(self: RenderTemplateView) -> str:
+        return render_template(self.template_name)
+
+
+app.add_url_rule(
+    "/about",
+    view_func=RenderTemplateView.as_view("about_page", template_name="about.html"),
+)
diff --git a/tox.ini b/tox.ini
index 077d66f2..08c6dca2 100644
--- a/tox.ini
+++ b/tox.ini
@@ -1,7 +1,8 @@
 [tox]
 envlist =
-    py3{11,10,9,8,7},pypy3{8,7}
-    py310-min
+    py3{12,11,10,9,8,7}
+    pypy3{9,8,7}
+    py311-min
     py37-dev
     style
     typing
@@ -9,11 +10,17 @@ envlist =
 skip_missing_interpreters = true
 
 [testenv]
+package = wheel
+wheel_build_env = .pkg
+envtmpdir = {toxworkdir}/tmp/{envname}
 deps =
     -r requirements/tests.txt
     min: -r requirements/tests-pallets-min.txt
-    dev: -r requirements/tests-pallets-dev.txt
-
+    dev: https://github.com/pallets/werkzeug/archive/refs/heads/main.tar.gz
+    dev: https://github.com/pallets/jinja/archive/refs/heads/main.tar.gz
+    dev: https://github.com/pallets/markupsafe/archive/refs/heads/main.tar.gz
+    dev: https://github.com/pallets/itsdangerous/archive/refs/heads/main.tar.gz
+    dev: https://github.com/pallets/click/archive/refs/heads/main.tar.gz
 #    examples/tutorial[test]
 #    examples/javascript[test]
 # commands = pytest -v --tb=short --basetemp={envtmpdir} {posargs:tests examples}
@@ -22,12 +29,16 @@ commands = pytest -v --tb=short --basetemp={envtmpdir} {posargs:tests}
 [testenv:style]
 deps = pre-commit
 skip_install = true
-commands = pre-commit run --all-files --show-diff-on-failure
+commands = pre-commit run --all-files
 
 [testenv:typing]
+package = wheel
+wheel_build_env = .pkg
 deps = -r requirements/typing.txt
 commands = mypy
 
 [testenv:docs]
+package = wheel
+wheel_build_env = .pkg
 deps = -r requirements/docs.txt
 commands = sphinx-build -W -b html -d {envtmpdir}/doctrees docs {envtmpdir}/html
